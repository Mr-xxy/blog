{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"source/favicon.ico","path":"favicon.ico","modified":0,"renderable":0},{"_id":"themes/Next/source/css/main.styl","path":"css/main.styl","modified":0,"renderable":1},{"_id":"themes/Next/source/images/algolia_logo.svg","path":"images/algolia_logo.svg","modified":0,"renderable":1},{"_id":"themes/Next/source/images/avatar.gif","path":"images/avatar.gif","modified":0,"renderable":1},{"_id":"themes/Next/source/images/apple-touch-icon-next.png","path":"images/apple-touch-icon-next.png","modified":0,"renderable":1},{"_id":"themes/Next/source/images/cc-by-nc-nd.svg","path":"images/cc-by-nc-nd.svg","modified":0,"renderable":1},{"_id":"themes/Next/source/images/cc-by-nc-sa.svg","path":"images/cc-by-nc-sa.svg","modified":0,"renderable":1},{"_id":"themes/Next/source/images/cc-by-nc.svg","path":"images/cc-by-nc.svg","modified":0,"renderable":1},{"_id":"themes/Next/source/images/cc-by-nd.svg","path":"images/cc-by-nd.svg","modified":0,"renderable":1},{"_id":"themes/Next/source/images/cc-by-sa.svg","path":"images/cc-by-sa.svg","modified":0,"renderable":1},{"_id":"themes/Next/source/images/favicon-32x32-next.png","path":"images/favicon-32x32-next.png","modified":0,"renderable":1},{"_id":"themes/Next/source/images/favicon-16x16-next.png","path":"images/favicon-16x16-next.png","modified":0,"renderable":1},{"_id":"themes/Next/source/images/cc-zero.svg","path":"images/cc-zero.svg","modified":0,"renderable":1},{"_id":"themes/Next/source/images/cc-by.svg","path":"images/cc-by.svg","modified":0,"renderable":1},{"_id":"themes/Next/source/images/loading.gif","path":"images/loading.gif","modified":0,"renderable":1},{"_id":"themes/Next/source/images/placeholder.gif","path":"images/placeholder.gif","modified":0,"renderable":1},{"_id":"themes/Next/source/images/quote-l.svg","path":"images/quote-l.svg","modified":0,"renderable":1},{"_id":"themes/Next/source/images/quote-r.svg","path":"images/quote-r.svg","modified":0,"renderable":1},{"_id":"themes/Next/source/images/logo.svg","path":"images/logo.svg","modified":0,"renderable":1},{"_id":"themes/Next/source/images/searchicon.png","path":"images/searchicon.png","modified":0,"renderable":1},{"_id":"themes/Next/source/images/favicon.ico","path":"images/favicon.ico","modified":0,"renderable":1},{"_id":"themes/Next/source/js/src/affix.js","path":"js/src/affix.js","modified":0,"renderable":1},{"_id":"themes/Next/source/js/src/algolia-search.js","path":"js/src/algolia-search.js","modified":0,"renderable":1},{"_id":"themes/Next/source/js/src/bootstrap.js","path":"js/src/bootstrap.js","modified":0,"renderable":1},{"_id":"themes/Next/source/js/src/exturl.js","path":"js/src/exturl.js","modified":0,"renderable":1},{"_id":"themes/Next/source/js/src/hook-duoshuo.js","path":"js/src/hook-duoshuo.js","modified":0,"renderable":1},{"_id":"themes/Next/source/js/src/js.cookie.js","path":"js/src/js.cookie.js","modified":0,"renderable":1},{"_id":"themes/Next/source/js/src/scroll-cookie.js","path":"js/src/scroll-cookie.js","modified":0,"renderable":1},{"_id":"themes/Next/source/js/src/post-details.js","path":"js/src/post-details.js","modified":0,"renderable":1},{"_id":"themes/Next/source/js/src/motion.js","path":"js/src/motion.js","modified":0,"renderable":1},{"_id":"themes/Next/source/js/src/scrollspy.js","path":"js/src/scrollspy.js","modified":0,"renderable":1},{"_id":"themes/Next/source/js/src/utils.js","path":"js/src/utils.js","modified":0,"renderable":1},{"_id":"themes/Next/source/lib/algolia-instant-search/instantsearch.min.css","path":"lib/algolia-instant-search/instantsearch.min.css","modified":0,"renderable":1},{"_id":"themes/Next/source/lib/canvas-nest/canvas-nest.min.js","path":"lib/canvas-nest/canvas-nest.min.js","modified":0,"renderable":1},{"_id":"themes/Next/source/lib/canvas-ribbon/canvas-ribbon.js","path":"lib/canvas-ribbon/canvas-ribbon.js","modified":0,"renderable":1},{"_id":"themes/Next/source/lib/fastclick/LICENSE","path":"lib/fastclick/LICENSE","modified":0,"renderable":1},{"_id":"themes/Next/source/lib/fastclick/README.md","path":"lib/fastclick/README.md","modified":0,"renderable":1},{"_id":"themes/Next/source/lib/fastclick/bower.json","path":"lib/fastclick/bower.json","modified":0,"renderable":1},{"_id":"themes/Next/source/lib/font-awesome/HELP-US-OUT.txt","path":"lib/font-awesome/HELP-US-OUT.txt","modified":0,"renderable":1},{"_id":"themes/Next/source/lib/font-awesome/bower.json","path":"lib/font-awesome/bower.json","modified":0,"renderable":1},{"_id":"themes/Next/source/lib/jquery_lazyload/CONTRIBUTING.md","path":"lib/jquery_lazyload/CONTRIBUTING.md","modified":0,"renderable":1},{"_id":"themes/Next/source/lib/jquery_lazyload/README.md","path":"lib/jquery_lazyload/README.md","modified":0,"renderable":1},{"_id":"themes/Next/source/lib/jquery_lazyload/bower.json","path":"lib/jquery_lazyload/bower.json","modified":0,"renderable":1},{"_id":"themes/Next/source/lib/jquery_lazyload/jquery.lazyload.js","path":"lib/jquery_lazyload/jquery.lazyload.js","modified":0,"renderable":1},{"_id":"themes/Next/source/lib/needsharebutton/needsharebutton.css","path":"lib/needsharebutton/needsharebutton.css","modified":0,"renderable":1},{"_id":"themes/Next/source/lib/jquery_lazyload/jquery.scrollstop.js","path":"lib/jquery_lazyload/jquery.scrollstop.js","modified":0,"renderable":1},{"_id":"themes/Next/source/lib/needsharebutton/needsharebutton.js","path":"lib/needsharebutton/needsharebutton.js","modified":0,"renderable":1},{"_id":"themes/Next/source/lib/needsharebutton/font-embedded.css","path":"lib/needsharebutton/font-embedded.css","modified":0,"renderable":1},{"_id":"themes/Next/source/lib/pace/pace-theme-barber-shop.min.css","path":"lib/pace/pace-theme-barber-shop.min.css","modified":0,"renderable":1},{"_id":"themes/Next/source/lib/pace/pace-theme-big-counter.min.css","path":"lib/pace/pace-theme-big-counter.min.css","modified":0,"renderable":1},{"_id":"themes/Next/source/lib/pace/pace-theme-center-atom.min.css","path":"lib/pace/pace-theme-center-atom.min.css","modified":0,"renderable":1},{"_id":"themes/Next/source/lib/pace/pace-theme-bounce.min.css","path":"lib/pace/pace-theme-bounce.min.css","modified":0,"renderable":1},{"_id":"themes/Next/source/lib/pace/pace-theme-center-circle.min.css","path":"lib/pace/pace-theme-center-circle.min.css","modified":0,"renderable":1},{"_id":"themes/Next/source/lib/pace/pace-theme-center-radar.min.css","path":"lib/pace/pace-theme-center-radar.min.css","modified":0,"renderable":1},{"_id":"themes/Next/source/lib/pace/pace-theme-center-simple.min.css","path":"lib/pace/pace-theme-center-simple.min.css","modified":0,"renderable":1},{"_id":"themes/Next/source/lib/pace/pace-theme-corner-indicator.min.css","path":"lib/pace/pace-theme-corner-indicator.min.css","modified":0,"renderable":1},{"_id":"themes/Next/source/lib/pace/pace-theme-fill-left.min.css","path":"lib/pace/pace-theme-fill-left.min.css","modified":0,"renderable":1},{"_id":"themes/Next/source/lib/pace/pace-theme-flash.min.css","path":"lib/pace/pace-theme-flash.min.css","modified":0,"renderable":1},{"_id":"themes/Next/source/lib/pace/pace-theme-loading-bar.min.css","path":"lib/pace/pace-theme-loading-bar.min.css","modified":0,"renderable":1},{"_id":"themes/Next/source/lib/pace/pace-theme-mac-osx.min.css","path":"lib/pace/pace-theme-mac-osx.min.css","modified":0,"renderable":1},{"_id":"themes/Next/source/lib/pace/pace-theme-minimal.min.css","path":"lib/pace/pace-theme-minimal.min.css","modified":0,"renderable":1},{"_id":"themes/Next/source/lib/pace/pace.min.js","path":"lib/pace/pace.min.js","modified":0,"renderable":1},{"_id":"themes/Next/source/lib/three/canvas_lines.min.js","path":"lib/three/canvas_lines.min.js","modified":0,"renderable":1},{"_id":"themes/Next/source/lib/three/canvas_sphere.min.js","path":"lib/three/canvas_sphere.min.js","modified":0,"renderable":1},{"_id":"themes/Next/source/lib/three/three-waves.min.js","path":"lib/three/three-waves.min.js","modified":0,"renderable":1},{"_id":"themes/Next/source/lib/velocity/bower.json","path":"lib/velocity/bower.json","modified":0,"renderable":1},{"_id":"themes/Next/source/lib/velocity/velocity.min.js","path":"lib/velocity/velocity.min.js","modified":0,"renderable":1},{"_id":"themes/Next/source/lib/velocity/velocity.ui.js","path":"lib/velocity/velocity.ui.js","modified":0,"renderable":1},{"_id":"themes/Next/source/lib/velocity/velocity.ui.min.js","path":"lib/velocity/velocity.ui.min.js","modified":0,"renderable":1},{"_id":"themes/Next/source/lib/jquery/index.js","path":"lib/jquery/index.js","modified":0,"renderable":1},{"_id":"themes/Next/source/js/src/schemes/pisces.js","path":"js/src/schemes/pisces.js","modified":0,"renderable":1},{"_id":"themes/Next/source/lib/Han/dist/han.css","path":"lib/Han/dist/han.css","modified":0,"renderable":1},{"_id":"themes/Next/source/lib/Han/dist/han.min.css","path":"lib/Han/dist/han.min.css","modified":0,"renderable":1},{"_id":"themes/Next/source/lib/Han/dist/han.min.js","path":"lib/Han/dist/han.min.js","modified":0,"renderable":1},{"_id":"themes/Next/source/lib/fancybox/source/blank.gif","path":"lib/fancybox/source/blank.gif","modified":0,"renderable":1},{"_id":"themes/Next/source/lib/fancybox/source/fancybox_loading.gif","path":"lib/fancybox/source/fancybox_loading.gif","modified":0,"renderable":1},{"_id":"themes/Next/source/lib/fancybox/source/fancybox_loading@2x.gif","path":"lib/fancybox/source/fancybox_loading@2x.gif","modified":0,"renderable":1},{"_id":"themes/Next/source/lib/fancybox/source/fancybox_overlay.png","path":"lib/fancybox/source/fancybox_overlay.png","modified":0,"renderable":1},{"_id":"themes/Next/source/lib/fancybox/source/fancybox_sprite.png","path":"lib/fancybox/source/fancybox_sprite.png","modified":0,"renderable":1},{"_id":"themes/Next/source/lib/fancybox/source/fancybox_sprite@2x.png","path":"lib/fancybox/source/fancybox_sprite@2x.png","modified":0,"renderable":1},{"_id":"themes/Next/source/lib/fancybox/source/jquery.fancybox.css","path":"lib/fancybox/source/jquery.fancybox.css","modified":0,"renderable":1},{"_id":"themes/Next/source/lib/fancybox/source/jquery.fancybox.pack.js","path":"lib/fancybox/source/jquery.fancybox.pack.js","modified":0,"renderable":1},{"_id":"themes/Next/source/lib/fancybox/source/jquery.fancybox.js","path":"lib/fancybox/source/jquery.fancybox.js","modified":0,"renderable":1},{"_id":"themes/Next/source/lib/fastclick/lib/fastclick.js","path":"lib/fastclick/lib/fastclick.js","modified":0,"renderable":1},{"_id":"themes/Next/source/lib/fastclick/lib/fastclick.min.js","path":"lib/fastclick/lib/fastclick.min.js","modified":0,"renderable":1},{"_id":"themes/Next/source/lib/font-awesome/css/font-awesome.css.map","path":"lib/font-awesome/css/font-awesome.css.map","modified":0,"renderable":1},{"_id":"themes/Next/source/lib/font-awesome/css/font-awesome.css","path":"lib/font-awesome/css/font-awesome.css","modified":0,"renderable":1},{"_id":"themes/Next/source/lib/font-awesome/css/font-awesome.min.css","path":"lib/font-awesome/css/font-awesome.min.css","modified":0,"renderable":1},{"_id":"themes/Next/source/lib/ua-parser-js/dist/ua-parser.min.js","path":"lib/ua-parser-js/dist/ua-parser.min.js","modified":0,"renderable":1},{"_id":"themes/Next/source/lib/ua-parser-js/dist/ua-parser.pack.js","path":"lib/ua-parser-js/dist/ua-parser.pack.js","modified":0,"renderable":1},{"_id":"themes/Next/source/lib/Han/dist/han.js","path":"lib/Han/dist/han.js","modified":0,"renderable":1},{"_id":"themes/Next/source/lib/font-awesome/fonts/fontawesome-webfont.woff","path":"lib/font-awesome/fonts/fontawesome-webfont.woff","modified":0,"renderable":1},{"_id":"themes/Next/source/lib/font-awesome/fonts/fontawesome-webfont.woff2","path":"lib/font-awesome/fonts/fontawesome-webfont.woff2","modified":0,"renderable":1},{"_id":"themes/Next/source/lib/velocity/velocity.js","path":"lib/velocity/velocity.js","modified":0,"renderable":1},{"_id":"themes/Next/source/lib/Han/dist/font/han-space.otf","path":"lib/Han/dist/font/han-space.otf","modified":0,"renderable":1},{"_id":"themes/Next/source/lib/Han/dist/font/han-space.woff","path":"lib/Han/dist/font/han-space.woff","modified":0,"renderable":1},{"_id":"themes/Next/source/lib/Han/dist/font/han.otf","path":"lib/Han/dist/font/han.otf","modified":0,"renderable":1},{"_id":"themes/Next/source/lib/Han/dist/font/han.woff2","path":"lib/Han/dist/font/han.woff2","modified":0,"renderable":1},{"_id":"themes/Next/source/lib/Han/dist/font/han.woff","path":"lib/Han/dist/font/han.woff","modified":0,"renderable":1},{"_id":"themes/Next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.css","path":"lib/fancybox/source/helpers/jquery.fancybox-buttons.css","modified":0,"renderable":1},{"_id":"themes/Next/source/lib/fancybox/source/helpers/fancybox_buttons.png","path":"lib/fancybox/source/helpers/fancybox_buttons.png","modified":0,"renderable":1},{"_id":"themes/Next/source/lib/fancybox/source/helpers/jquery.fancybox-media.js","path":"lib/fancybox/source/helpers/jquery.fancybox-media.js","modified":0,"renderable":1},{"_id":"themes/Next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.js","path":"lib/fancybox/source/helpers/jquery.fancybox-buttons.js","modified":0,"renderable":1},{"_id":"themes/Next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","path":"lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","modified":0,"renderable":1},{"_id":"themes/Next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","path":"lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","modified":0,"renderable":1},{"_id":"themes/Next/source/lib/font-awesome/fonts/FontAwesome.otf","path":"lib/font-awesome/fonts/FontAwesome.otf","modified":0,"renderable":1},{"_id":"themes/Next/source/lib/font-awesome/fonts/fontawesome-webfont.eot","path":"lib/font-awesome/fonts/fontawesome-webfont.eot","modified":0,"renderable":1},{"_id":"themes/Next/source/lib/font-awesome/fonts/fontawesome-webfont.ttf","path":"lib/font-awesome/fonts/fontawesome-webfont.ttf","modified":0,"renderable":1},{"_id":"themes/Next/source/lib/algolia-instant-search/instantsearch.min.js","path":"lib/algolia-instant-search/instantsearch.min.js","modified":0,"renderable":1},{"_id":"themes/Next/source/lib/three/three.min.js","path":"lib/three/three.min.js","modified":0,"renderable":1},{"_id":"themes/Next/source/lib/font-awesome/fonts/fontawesome-webfont.svg","path":"lib/font-awesome/fonts/fontawesome-webfont.svg","modified":0,"renderable":1}],"Cache":[{"_id":"source/.DS_Store","hash":"ec15a3de6ad7d3723b85072c6f238388f8a1789f","modified":1561019279978},{"_id":"source/favicon.ico","hash":"c78cdd5fab76a7c6113cdf8f57e8c23dcb7f484e","modified":1525328384625},{"_id":"themes/Next/.bowerrc","hash":"3228a58ed0ece9f85e1e3136352094080b8dece1","modified":1525412794196},{"_id":"themes/Next/.editorconfig","hash":"792fd2bd8174ece1a75d5fd24ab16594886f3a7f","modified":1525412794196},{"_id":"themes/Next/.gitattributes","hash":"44bd4729c74ccb88110804f41746fec07bf487d4","modified":1525412794196},{"_id":"themes/Next/.gitignore","hash":"0b5c2ffd41f66eb1849d6426ba8cf9649eeed329","modified":1525412794197},{"_id":"themes/Next/.hound.yml","hash":"b76daa84c9ca3ad292c78412603370a367cc2bc3","modified":1525412794197},{"_id":"themes/Next/.jshintrc","hash":"9928f81bd822f6a8d67fdbc909b517178533bca9","modified":1525412794198},{"_id":"themes/Next/.stylintrc","hash":"b28e24704a5d8de08346c45286574c8e76cc109f","modified":1525412794198},{"_id":"themes/Next/.javascript_ignore","hash":"8a224b381155f10e6eb132a4d815c5b52962a9d1","modified":1525412794197},{"_id":"themes/Next/.travis.yml","hash":"d60d4a5375fea23d53b2156b764a99b2e56fa660","modified":1525412794198},{"_id":"themes/Next/LICENSE","hash":"f293bcfcdc06c0b77ba13570bb8af55eb5c059fd","modified":1525412794198},{"_id":"themes/Next/README.cn.md","hash":"2c766b3369ed477bce134a5450dab45bef161504","modified":1525412794198},{"_id":"themes/Next/README.md","hash":"8ce60ce578963eb4e1eb5e33e1efc2fc4779af9c","modified":1525412794198},{"_id":"themes/Next/bower.json","hash":"0674f11d3d514e087a176da0e1d85c2286aa5fba","modified":1525412794199},{"_id":"themes/Next/gulpfile.coffee","hash":"031bffc483e417b20e90eceb6cf358e7596d2e69","modified":1525412794199},{"_id":"themes/Next/_config.yml","hash":"07e845ad35643b2b444717e0c477779967302e02","modified":1525429206164},{"_id":"themes/Next/package.json","hash":"036d3a1346203d2f1a3958024df7f74e7ac07bfe","modified":1525412794219},{"_id":"source/_posts/.DS_Store","hash":"e3f64bded8c782e2ff48a375ae506670d668ca51","modified":1525401877530},{"_id":"source/_posts/git-usage.md","hash":"3d425bcdfdeb25005bdcde5b574bd1b8a05c68ed","modified":1525346598845},{"_id":"source/_posts/Bower.md","hash":"7589e7800c70edf8871360fd6218738d7f3a3756","modified":1525748321241},{"_id":"source/_posts/js-Array-indexOf方法.md","hash":"6c39732b3bab52a8ede0a9b935e3a0af11b3706a","modified":1577244810376},{"_id":"source/_posts/js-clone.md","hash":"6fef1961aee99e8ea6f8f38fb97d41d5e5ef4518","modified":1525748343155},{"_id":"source/_posts/js-dataType.md","hash":"4b77abaf8fa57fd3c3e87d4304d2e3f538d9934c","modified":1525748368789},{"_id":"source/_posts/js-drag.md","hash":"490ae9ecba87edb84f8cdeb35cbd093e8e272b9b","modified":1525346598843},{"_id":"source/_posts/js-实现路由.md","hash":"52a1c05c359cb852ac3b5ff91c2755d89f04649e","modified":1525748368786},{"_id":"source/_posts/markdown摘要.md","hash":"df4a8593c549662d5ffce3bbea6a19f7af436626","modified":1526032769327},{"_id":"source/_posts/vue-proxy_defineproperty优劣.md","hash":"6584010f387bdbe6565e27e05594276c24908ff2","modified":1525756226537},{"_id":"source/_posts/vue-react-EventBus.md","hash":"d27770766465ebf61e85c42e1f6501d27d1b6aba","modified":1525748343159},{"_id":"source/about/index.md","hash":"e0ec4849ab294533cf67d6b13c89ac8ced1b0f21","modified":1525428623600},{"_id":"source/categories/index.md","hash":"b3bf010c8e2892e4d9a5a87397ac4ad1aa6bb182","modified":1525419545632},{"_id":"source/tags/index.md","hash":"6b5e8086ab6228f24bfd71c903b1cac8831b3096","modified":1525419458860},{"_id":"themes/Next/.git/FETCH_HEAD","hash":"778b51a21e3c53e17a5b722a6329f3f7c0eb829f","modified":1525412914395},{"_id":"themes/Next/.git/description","hash":"9635f1b7e12c045212819dd934d809ef07efa2f4","modified":1525412659920},{"_id":"themes/Next/.git/config","hash":"bf7d1df65cf34d0f25a7184a58c37a09f72e4be7","modified":1525412794191},{"_id":"themes/Next/.git/ORIG_HEAD","hash":"7999da428ebb87e5a2b27315d8d5123c1ccdfaa5","modified":1525412914409},{"_id":"themes/Next/.git/index","hash":"796e8f4c9567da9a68aaa198460cc9c4038c104b","modified":1525412794306},{"_id":"themes/Next/.git/HEAD","hash":"acbaef275e46a7f14c1ef456fff2c8bbe8c84724","modified":1525412794190},{"_id":"themes/Next/.git/packed-refs","hash":"69237944e31c16fe545d1f47b0b1e5b1d99660da","modified":1525412794188},{"_id":"themes/Next/.github/CONTRIBUTING.md","hash":"3b5eafd32abb718e56ccf8d1cee0607ad8ce611d","modified":1525412794196},{"_id":"themes/Next/.github/ISSUE_TEMPLATE.md","hash":"50d48c47162817a3810a9d9ad51104e83947419a","modified":1525412794197},{"_id":"themes/Next/.github/PULL_REQUEST_TEMPLATE.md","hash":"902f627155a65099e0a37842ff396a58d0dc306f","modified":1525412794197},{"_id":"themes/Next/.github/browserstack_logo.png","hash":"a6c43887f64a7f48a2814e3714eaa1215e542037","modified":1525412794197},{"_id":"themes/Next/languages/de.yml","hash":"057e7df11ddeb1c8c15a5d7c5ff29430d725ec6b","modified":1525412794199},{"_id":"themes/Next/languages/default.yml","hash":"44ef3f26917f467459326c2c8be2f73e4d947f35","modified":1525412794199},{"_id":"themes/Next/languages/en.yml","hash":"7e680d9bb8f3a3a9d1ba1c9d312b3d257183dded","modified":1525412794200},{"_id":"themes/Next/languages/fr-FR.yml","hash":"7e4eb7011b8feee641cfb11c6e73180b0ded1c0f","modified":1525412794200},{"_id":"themes/Next/languages/ja.yml","hash":"3c76e16fd19b262864475faa6854b718bc08c4d8","modified":1525412794200},{"_id":"themes/Next/languages/it.yml","hash":"aa595f2bda029f73ef7bfa104b4c55c3f4e9fb4c","modified":1525412794200},{"_id":"themes/Next/languages/id.yml","hash":"b5de1ea66dd9ef54cac9a1440eaa4e3f5fc011f5","modified":1525412794200},{"_id":"themes/Next/languages/ko.yml","hash":"ea5b46056e73ebcee121d5551627af35cbffc900","modified":1525412794200},{"_id":"themes/Next/languages/nl-NL.yml","hash":"edca4f3598857dbc3cbf19ed412213329b6edd47","modified":1525412794200},{"_id":"themes/Next/languages/pt-BR.yml","hash":"b1694ae766ed90277bcc4daca4b1cfa19cdcb72b","modified":1525412794200},{"_id":"themes/Next/languages/pt.yml","hash":"44b61f2d085b827b507909a0b8f8ce31c6ef5d04","modified":1525412794201},{"_id":"themes/Next/languages/ru.yml","hash":"98ec6f0b7183282e11cffc7ff586ceb82400dd75","modified":1525412794201},{"_id":"themes/Next/languages/vi.yml","hash":"fd08d3c8d2c62965a98ac420fdaf95e54c25d97c","modified":1525412794201},{"_id":"themes/Next/languages/zh-hk.yml","hash":"9396f41ae76e4fef99b257c93c7354e661f6e0fa","modified":1525412794201},{"_id":"themes/Next/languages/zh-tw.yml","hash":"50b71abb3ecc0686f9739e179e2f829cd074ecd9","modified":1525412794202},{"_id":"themes/Next/languages/zh-Hans.yml","hash":"6a50dd7023b78c3a9b045684768781e711360f78","modified":1525428860260},{"_id":"themes/Next/layout/_layout.swig","hash":"da0929166674ea637e0ad454f85ad0d7bac4aff2","modified":1525412794202},{"_id":"themes/Next/layout/archive.swig","hash":"f0a8225feafd971419837cdb4bcfec98a4a59b2f","modified":1525412794218},{"_id":"themes/Next/layout/category.swig","hash":"4472255f4a3e3dd6d79201523a9526dcabdfbf18","modified":1525412794218},{"_id":"themes/Next/layout/index.swig","hash":"783611349c941848a0e26ee2f1dc44dd14879bd1","modified":1525412794218},{"_id":"themes/Next/layout/page.swig","hash":"969caaee05bdea725e99016eb63d810893a73e99","modified":1525412794218},{"_id":"themes/Next/scripts/merge-configs.js","hash":"81e86717ecfb775986b945d17f0a4ba27532ef07","modified":1525412794220},{"_id":"themes/Next/layout/post.swig","hash":"b3589a8e46288a10d20e41c7a5985d2493725aec","modified":1525412794219},{"_id":"themes/Next/layout/tag.swig","hash":"7e0a7d7d832883eddb1297483ad22c184e4368de","modified":1525412794219},{"_id":"themes/Next/scripts/merge.js","hash":"9130dabe6a674c54b535f322b17d75fe6081472f","modified":1525412794220},{"_id":"themes/Next/layout/schedule.swig","hash":"d86f8de4e118f8c4d778b285c140474084a271db","modified":1525412794219},{"_id":"themes/Next/test/.jshintrc","hash":"19f93d13d1689fe033c82eb2d5f3ce30b6543cc0","modified":1525412794304},{"_id":"themes/Next/test/helpers.js","hash":"a1f5de25154c3724ffc24a91ddc576cdbd60864f","modified":1525412794304},{"_id":"themes/Next/test/intern.js","hash":"11fa8a4f5c3b4119a179ae0a2584c8187f907a73","modified":1525412794304},{"_id":"themes/Next/source/fonts/.gitkeep","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1525412794241},{"_id":"themes/Next/.git/hooks/post-update.sample","hash":"b614c2f63da7dca9f1db2e7ade61ef30448fc96c","modified":1525412659921},{"_id":"themes/Next/.git/hooks/commit-msg.sample","hash":"ee1ed5aad98a435f2020b6de35c173b75d9affac","modified":1525412659920},{"_id":"themes/Next/.git/hooks/applypatch-msg.sample","hash":"4de88eb95a5e93fd27e78b5fb3b5231a8d8917dd","modified":1525412659921},{"_id":"themes/Next/.git/hooks/pre-applypatch.sample","hash":"f208287c1a92525de9f5462e905a9d31de1e2d75","modified":1525412659922},{"_id":"themes/Next/.git/hooks/pre-push.sample","hash":"5c8518bfd1d1d3d2c1a7194994c0a16d8a313a41","modified":1525412659922},{"_id":"themes/Next/.git/hooks/pre-commit.sample","hash":"36aed8976dcc08b5076844f0ec645b18bc37758f","modified":1525412659921},{"_id":"themes/Next/.git/hooks/pre-rebase.sample","hash":"288efdc0027db4cfd8b7c47c4aeddba09b6ded12","modified":1525412659920},{"_id":"themes/Next/.git/hooks/pre-receive.sample","hash":"705a17d259e7896f0082fe2e9f2c0c3b127be5ac","modified":1525412659921},{"_id":"themes/Next/.git/hooks/prepare-commit-msg.sample","hash":"2584806ba147152ae005cb675aa4f01d5d068456","modified":1525412659921},{"_id":"themes/Next/.git/hooks/update.sample","hash":"e729cd61b27c128951d139de8e7c63d1a3758dde","modified":1525412659922},{"_id":"themes/Next/.git/logs/HEAD","hash":"57879eef94f7dd37fd0ba4403c065d49c515d7ab","modified":1525412794190},{"_id":"themes/Next/.git/info/exclude","hash":"bb5a85730dcf100facee799c05cc4f6affec0745","modified":1525412659920},{"_id":"themes/Next/layout/_custom/header.swig","hash":"adc83b19e793491b1c6ea0fd8b46cd9f32e592fc","modified":1525412794202},{"_id":"themes/Next/layout/_custom/sidebar.swig","hash":"adc83b19e793491b1c6ea0fd8b46cd9f32e592fc","modified":1525412794202},{"_id":"themes/Next/layout/_macro/post-collapse.swig","hash":"31322a7f57936cf2dc62e824af5490da5354cf02","modified":1525412794202},{"_id":"themes/Next/layout/_macro/post-copyright.swig","hash":"665a928604f99d2ba7dc4a4a9150178229568cc6","modified":1525412794202},{"_id":"themes/Next/layout/_macro/reward.swig","hash":"4bcd8bd00129450108fff0be8988335fda0a4e46","modified":1525421535612},{"_id":"themes/Next/layout/_macro/post.swig","hash":"446a35a2cd389f8cfc3aa38973a9b44ad0740134","modified":1525412794203},{"_id":"themes/Next/layout/_macro/sidebar.swig","hash":"6a54c3c85ff6b19d275827a327abbf4bd99b2ebf","modified":1525412794203},{"_id":"themes/Next/layout/_macro/wechat-subscriber.swig","hash":"39852700e4084ecccffa6d4669168e5cc0514c9e","modified":1525412794203},{"_id":"themes/Next/layout/_partials/comments.swig","hash":"4a6f5b1792b2e5262b7fdab9a716b3108e2f09c7","modified":1525412794203},{"_id":"themes/Next/layout/_partials/header.swig","hash":"ed042be6252848058c90109236ec988e392d91d4","modified":1525412794204},{"_id":"themes/Next/layout/_partials/page-header.swig","hash":"1efd925d34a5d4ba2dc0838d9c86ba911e705fc9","modified":1525412794204},{"_id":"themes/Next/layout/_partials/head.swig","hash":"6b94fe8f3279daea5623c49ef4bb35917ba57510","modified":1525412794204},{"_id":"themes/Next/layout/_partials/footer.swig","hash":"ad2dd529e921425044320b7bb5b876d109a65d7d","modified":1633939125521},{"_id":"themes/Next/layout/_partials/pagination.swig","hash":"9e8e21d194ef44d271b1cca0bc1448c14d7edf4f","modified":1525412794204},{"_id":"themes/Next/layout/_partials/search.swig","hash":"9dbd378e94abfcb3f864a5b8dbbf18d212ca2ee0","modified":1525412794205},{"_id":"themes/Next/layout/_scripts/commons.swig","hash":"766b2bdda29523ed6cd8d7aa197f996022f8fd94","modified":1525412794207},{"_id":"themes/Next/layout/_scripts/boostrap.swig","hash":"03aaebe9d50f6acb007ec38cc04acd1cfceb404d","modified":1525412794207},{"_id":"themes/Next/layout/_scripts/vendors.swig","hash":"a266f96ad06ee87bdeae6e105a4b53cd587bbd04","modified":1525412794208},{"_id":"themes/Next/layout/_third-party/duoshuo-hot-articles.swig","hash":"5d4638c46aef65bf32a01681495b62416ccc98db","modified":1525412794214},{"_id":"themes/Next/layout/_third-party/exturl.swig","hash":"7c04a42319d728be356746363aff8ea247791d24","modified":1525412794214},{"_id":"themes/Next/layout/_third-party/mathjax.swig","hash":"6d25596d6a7c57700d37b607f8d9a62d89708683","modified":1525412794215},{"_id":"themes/Next/layout/_third-party/needsharebutton.swig","hash":"5fe0447cc88a5a63b530cf0426f93c4634811876","modified":1525412794215},{"_id":"themes/Next/layout/_third-party/rating.swig","hash":"fc93b1a7e6aed0dddb1f3910142b48d8ab61174e","modified":1525412794215},{"_id":"themes/Next/layout/_third-party/schedule.swig","hash":"22369026c87fc23893c35a7f250b42f3bb1b60f1","modified":1525412794216},{"_id":"themes/Next/layout/_third-party/scroll-cookie.swig","hash":"1ddb2336a1a19b47af3017047012c01ec5f54529","modified":1525412794216},{"_id":"themes/Next/scripts/tags/button.js","hash":"d023f10a00077f47082b0517e2ad666e6e994f60","modified":1525412794220},{"_id":"themes/Next/scripts/tags/center-quote.js","hash":"535fc542781021c4326dec24d8495cbb1387634a","modified":1525412794221},{"_id":"themes/Next/scripts/tags/exturl.js","hash":"8d7e60f60779bde050d20fd76f6fdc36fc85e06d","modified":1525412794221},{"_id":"themes/Next/scripts/tags/full-image.js","hash":"8eeb3fb89540299bdbb799edfdfdac3743b50596","modified":1525412794221},{"_id":"themes/Next/scripts/tags/group-pictures.js","hash":"49252824cd53184dc9b97b2f2d87ff28e1b3ef27","modified":1525412794221},{"_id":"themes/Next/scripts/tags/label.js","hash":"2f8f41a7316372f0d1ed6b51190dc4acd3e16fff","modified":1525412794221},{"_id":"themes/Next/scripts/tags/lazy-image.js","hash":"eeeabede68cf263de9e6593ecf682f620da16f0a","modified":1525412794222},{"_id":"themes/Next/scripts/tags/note.js","hash":"64de4e9d01cf3b491ffc7d53afdf148ee5ad9779","modified":1525412794222},{"_id":"themes/Next/scripts/tags/tabs.js","hash":"5786545d51c38e8ca38d1bfc7dd9e946fc70a316","modified":1525412794222},{"_id":"themes/Next/source/css/main.styl","hash":"20702c48d6053c92c5bcdbc68e8d0ef1369848a0","modified":1525412794241},{"_id":"themes/Next/source/images/algolia_logo.svg","hash":"ec119560b382b2624e00144ae01c137186e91621","modified":1525412794241},{"_id":"themes/Next/source/images/avatar.gif","hash":"264082bb3a1af70d5499c7d22b0902cb454b6d12","modified":1525412794242},{"_id":"themes/Next/source/images/apple-touch-icon-next.png","hash":"2959dbc97f31c80283e67104fe0854e2369e40aa","modified":1525412794242},{"_id":"themes/Next/source/images/cc-by-nc-nd.svg","hash":"c6524ece3f8039a5f612feaf865d21ec8a794564","modified":1525412794242},{"_id":"themes/Next/source/images/cc-by-nc-sa.svg","hash":"3031be41e8753c70508aa88e84ed8f4f653f157e","modified":1525412794242},{"_id":"themes/Next/source/images/cc-by-nc.svg","hash":"8d39b39d88f8501c0d27f8df9aae47136ebc59b7","modified":1525412794242},{"_id":"themes/Next/source/images/cc-by-nd.svg","hash":"c563508ce9ced1e66948024ba1153400ac0e0621","modified":1525412794243},{"_id":"themes/Next/source/images/cc-by-sa.svg","hash":"aa4742d733c8af8d38d4c183b8adbdcab045872e","modified":1525412794243},{"_id":"themes/Next/source/images/favicon-32x32-next.png","hash":"0749d7b24b0d2fae1c8eb7f671ad4646ee1894b1","modified":1525412794244},{"_id":"themes/Next/source/images/favicon-16x16-next.png","hash":"943a0d67a9cdf8c198109b28f9dbd42f761d11c3","modified":1525412794244},{"_id":"themes/Next/source/images/cc-zero.svg","hash":"87669bf8ac268a91d027a0a4802c92a1473e9030","modified":1525412794243},{"_id":"themes/Next/source/images/cc-by.svg","hash":"28a0a4fe355a974a5e42f68031652b76798d4f7e","modified":1525412794243},{"_id":"themes/Next/source/images/loading.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1525412794244},{"_id":"themes/Next/source/images/placeholder.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1525412794245},{"_id":"themes/Next/source/images/quote-l.svg","hash":"94e870b4c8c48da61d09522196d4dd40e277a98f","modified":1525412794245},{"_id":"themes/Next/source/images/quote-r.svg","hash":"e60ae504f9d99b712c793c3740c6b100d057d4ec","modified":1525412794245},{"_id":"themes/Next/source/images/logo.svg","hash":"d29cacbae1bdc4bbccb542107ee0524fe55ad6de","modified":1525412794244},{"_id":"themes/Next/source/images/searchicon.png","hash":"67727a6a969be0b2659b908518fa6706eed307b8","modified":1525412794245},{"_id":"themes/Next/source/images/favicon.ico","hash":"c78cdd5fab76a7c6113cdf8f57e8c23dcb7f484e","modified":1525328384000},{"_id":"themes/Next/layout/_scripts/schemes/mist.swig","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1525412794208},{"_id":"themes/Next/layout/_scripts/schemes/muse.swig","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1525412794208},{"_id":"themes/Next/source/css/_mixins/Mist.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1525412794236},{"_id":"themes/Next/source/css/_mixins/Muse.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1525412794236},{"_id":"themes/Next/source/css/_mixins/custom.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1525412794236},{"_id":"themes/Next/source/css/_variables/Muse.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1525412794240},{"_id":"themes/Next/source/css/_variables/custom.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1525412794241},{"_id":"themes/Next/.git/refs/heads/master","hash":"7999da428ebb87e5a2b27315d8d5123c1ccdfaa5","modified":1525412794190},{"_id":"themes/Next/layout/_partials/head/custom-head.swig","hash":"9e1b9666efa77f4cf8d8261bcfa445a9ac608e53","modified":1525412794204},{"_id":"themes/Next/layout/_partials/head/external-fonts.swig","hash":"7ce76358411184482bb0934e70037949dd0da8ca","modified":1525412794204},{"_id":"themes/Next/layout/_partials/search/localsearch.swig","hash":"957701729b85fb0c5bfcf2fb99c19d54582f91ed","modified":1525412794205},{"_id":"themes/Next/layout/_partials/search/tinysou.swig","hash":"eefe2388ff3d424694045eda21346989b123977c","modified":1525412794205},{"_id":"themes/Next/layout/_partials/search/swiftype.swig","hash":"959b7e04a96a5596056e4009b73b6489c117597e","modified":1525412794205},{"_id":"themes/Next/layout/_partials/share/baidushare.swig","hash":"1f1107468aaf03f7d0dcd7eb2b653e2813a675b4","modified":1525412794206},{"_id":"themes/Next/layout/_partials/share/add-this.swig","hash":"23e23dc0f76ef3c631f24c65277adf7ea517b383","modified":1525412794206},{"_id":"themes/Next/layout/_partials/share/jiathis.swig","hash":"048fd5e98149469f8c28c21ba3561a7a67952c9b","modified":1525412794206},{"_id":"themes/Next/layout/_partials/share/duoshuo_share.swig","hash":"89c5a5240ecb223acfe1d12377df5562a943fd5d","modified":1525412794206},{"_id":"themes/Next/layout/_scripts/pages/post-details.swig","hash":"069d1357c717572256e5cdee09574ebce529cbae","modified":1525412794207},{"_id":"themes/Next/layout/_scripts/schemes/gemini.swig","hash":"a44acf9b0d0f44ef3dfc767376a95c984cc127de","modified":1525412794208},{"_id":"themes/Next/layout/_scripts/schemes/pisces.swig","hash":"a44acf9b0d0f44ef3dfc767376a95c984cc127de","modified":1525412794208},{"_id":"themes/Next/layout/_third-party/analytics/analytics-with-widget.swig","hash":"98df9d72e37dd071e882f2d5623c9d817815b139","modified":1525412794209},{"_id":"themes/Next/layout/_third-party/analytics/application-insights.swig","hash":"60426bf73f8a89ba61fb1be2df3ad5398e32c4ef","modified":1525412794209},{"_id":"themes/Next/layout/_third-party/analytics/baidu-analytics.swig","hash":"deda6a814ed48debc694c4e0c466f06c127163d0","modified":1525412794209},{"_id":"themes/Next/layout/_third-party/analytics/busuanzi-counter.swig","hash":"18e7bef8923d83ea42df6c97405e515a876cede4","modified":1525412794209},{"_id":"themes/Next/layout/_third-party/analytics/facebook-sdk.swig","hash":"a234c5cd1f75ca5731e814d0dbb92fdcf9240d1b","modified":1525412794209},{"_id":"themes/Next/layout/_third-party/analytics/firestore.swig","hash":"1cd01c6e92ab1913d48e556a92bb4f28b6dc4996","modified":1525412794210},{"_id":"themes/Next/layout/_third-party/analytics/google-analytics.swig","hash":"5d9943d74cc2e0a91badcf4f755c6de77eab193a","modified":1525412794210},{"_id":"themes/Next/layout/_third-party/analytics/index.swig","hash":"5e9bb24c750b49513d9a65799e832f07410002ac","modified":1525412794210},{"_id":"themes/Next/layout/_third-party/analytics/cnzz-analytics.swig","hash":"8160b27bee0aa372c7dc7c8476c05bae57f58d0f","modified":1525412794209},{"_id":"themes/Next/layout/_third-party/analytics/tencent-mta.swig","hash":"0ddc94ed4ba0c19627765fdf1abc4d8efbe53d5a","modified":1525412794211},{"_id":"themes/Next/layout/_third-party/analytics/lean-analytics.swig","hash":"fc65b9c98a0a8ab43a5e7aabff6c5f03838e09c8","modified":1525412794210},{"_id":"themes/Next/layout/_third-party/analytics/vkontakte-api.swig","hash":"c3971fd154d781088e1cc665035f8561a4098f4c","modified":1525412794211},{"_id":"themes/Next/layout/_third-party/analytics/tencent-analytics.swig","hash":"3658414379e0e8a34c45c40feadc3edc8dc55f88","modified":1525412794211},{"_id":"themes/Next/layout/_third-party/comments/changyan.swig","hash":"0e3378f7c39b2b0f69638290873ede6b6b6825c0","modified":1525412794212},{"_id":"themes/Next/layout/_third-party/comments/disqus.swig","hash":"c316758546dc9ba6c60cb4d852c17ca6bb6d6724","modified":1525412794212},{"_id":"themes/Next/layout/_third-party/comments/gitment.swig","hash":"10160daceaa6f1ecf632323d422ebe2caae49ddf","modified":1525412794213},{"_id":"themes/Next/layout/_third-party/comments/hypercomments.swig","hash":"3e8dc5c6c912628a37e3b5f886bec7b2e5ed14ea","modified":1525412794213},{"_id":"themes/Next/layout/_third-party/comments/duoshuo.swig","hash":"a356b2185d40914447fde817eb3d358ab6b3e4c3","modified":1525412794212},{"_id":"themes/Next/layout/_third-party/comments/index.swig","hash":"aa0629277d751c55c6d973e7691bf84af9b17a60","modified":1525412794213},{"_id":"themes/Next/layout/_third-party/comments/valine.swig","hash":"fcabbb241f894c9a6309c44e126cf3e8fea81fd4","modified":1525412794214},{"_id":"themes/Next/layout/_third-party/comments/youyan.swig","hash":"8b6650f77fe0a824c8075b2659e0403e0c78a705","modified":1525412794214},{"_id":"themes/Next/layout/_third-party/comments/livere.swig","hash":"8a2e393d2e49f7bf560766d8a07cd461bf3fce4f","modified":1525412794213},{"_id":"themes/Next/layout/_third-party/search/index.swig","hash":"c747fb5c6b1f500e8f0c583e44195878b66e4e29","modified":1525412794217},{"_id":"themes/Next/layout/_third-party/search/localsearch.swig","hash":"385c066af96bee30be2459dbec8aae1f15d382f5","modified":1525412794217},{"_id":"themes/Next/layout/_third-party/search/tinysou.swig","hash":"cb3a5d36dbe1630bab84e03a52733a46df7c219b","modified":1525412794217},{"_id":"themes/Next/layout/_third-party/seo/baidu-push.swig","hash":"c057b17f79e8261680fbae8dc4e81317a127c799","modified":1525412794218},{"_id":"themes/Next/source/css/_custom/custom.styl","hash":"328d9a9696cc2ccf59c67d3c26000d569f46344c","modified":1525412794235},{"_id":"themes/Next/source/css/_mixins/Gemini.styl","hash":"2aa5b7166a85a8aa34b17792ae4f58a5a96df6cc","modified":1525412794235},{"_id":"themes/Next/source/css/_mixins/Pisces.styl","hash":"9ab65361ba0a12a986edd103e56492644c2db0b8","modified":1525412794236},{"_id":"themes/Next/source/css/_mixins/base.styl","hash":"82f9055955920ed88a2ab6a20ab02169abb2c634","modified":1525412794236},{"_id":"themes/Next/source/css/_variables/Mist.styl","hash":"be087dcc060e8179f7e7f60ab4feb65817bd3d9f","modified":1525412794240},{"_id":"themes/Next/source/css/_variables/Gemini.styl","hash":"99fbb4686ea9a3e03a4726ed7cf4d8f529034452","modified":1525412794240},{"_id":"themes/Next/source/css/_variables/Pisces.styl","hash":"f29165e36489a87ba32d17dddfd2720d84e3f3ec","modified":1525412794241},{"_id":"themes/Next/source/css/_variables/base.styl","hash":"29c261fa6b4046322559074d75239c6b272fb8a3","modified":1525412794241},{"_id":"themes/Next/source/js/src/affix.js","hash":"978e0422b5bf1b560236d8d10ebc1adcf66392e3","modified":1525412794245},{"_id":"themes/Next/source/js/src/algolia-search.js","hash":"b172f697ed339a24b1e80261075232978d164c35","modified":1525412794246},{"_id":"themes/Next/source/js/src/bootstrap.js","hash":"034bc8113e0966fe2096ba5b56061bbf10ef0512","modified":1525412794246},{"_id":"themes/Next/source/js/src/exturl.js","hash":"e42e2aaab7bf4c19a0c8e779140e079c6aa5c0b1","modified":1525412794246},{"_id":"themes/Next/source/js/src/hook-duoshuo.js","hash":"a6119070c0119f33e08b29da7d2cce2635eb40a0","modified":1525412794246},{"_id":"themes/Next/source/js/src/js.cookie.js","hash":"9b37973a90fd50e71ea91682265715e45ae82c75","modified":1525412794246},{"_id":"themes/Next/source/js/src/scroll-cookie.js","hash":"09dc828cbf5f31158ff6250d2bf7c3cde6365c67","modified":1525412794247},{"_id":"themes/Next/source/js/src/post-details.js","hash":"a13f45f7aa8291cf7244ec5ba93907d119c5dbdd","modified":1525412794247},{"_id":"themes/Next/source/js/src/motion.js","hash":"754b294394f102c8fd9423a1789ddb1201677898","modified":1525412794247},{"_id":"themes/Next/source/js/src/scrollspy.js","hash":"fe4da1b9fe73518226446f5f27d2831e4426fc35","modified":1525412794248},{"_id":"themes/Next/source/js/src/utils.js","hash":"9b1325801d27213083d1487a12b1a62b539ab6f8","modified":1525412794248},{"_id":"themes/Next/source/lib/algolia-instant-search/instantsearch.min.css","hash":"90ef19edc982645b118b095615838d9c5eaba0de","modified":1525412794252},{"_id":"themes/Next/source/lib/canvas-nest/canvas-nest.min.js","hash":"0387e75e23b1db108a755073fe52a0d03eb391a7","modified":1525412794255},{"_id":"themes/Next/source/lib/canvas-ribbon/canvas-ribbon.js","hash":"ff5915eb2596e890a2fc6697c864f861a1995ec0","modified":1525412794255},{"_id":"themes/Next/source/lib/fancybox/.bower.json","hash":"cc40a9b11e52348e554c84e4a5c058056f6b7aeb","modified":1525412794255},{"_id":"themes/Next/source/lib/fancybox/.gitattributes","hash":"2db21acfbd457452462f71cc4048a943ee61b8e0","modified":1525412794256},{"_id":"themes/Next/source/lib/fastclick/.bower.json","hash":"93ebd5b35e632f714dcf1753e1f6db77ec74449b","modified":1525412794260},{"_id":"themes/Next/source/lib/fastclick/LICENSE","hash":"dcd5b6b43095d9e90353a28b09cb269de8d4838e","modified":1525412794260},{"_id":"themes/Next/source/lib/fastclick/README.md","hash":"1decd8e1adad2cd6db0ab50cf56de6035156f4ea","modified":1525412794260},{"_id":"themes/Next/source/lib/fastclick/bower.json","hash":"13379463c7463b4b96d13556b46faa4cc38d81e6","modified":1525412794260},{"_id":"themes/Next/source/lib/font-awesome/.bower.json","hash":"a2aaaf12378db56bd10596ba3daae30950eac051","modified":1525412794261},{"_id":"themes/Next/source/lib/font-awesome/.npmignore","hash":"dcf470ab3a358103bb896a539cc03caeda10fa8b","modified":1525412794261},{"_id":"themes/Next/source/lib/font-awesome/.gitignore","hash":"69d152fa46b517141ec3b1114dd6134724494d83","modified":1525412794261},{"_id":"themes/Next/source/lib/font-awesome/HELP-US-OUT.txt","hash":"4f7bf961f1bed448f6ba99aeb9219fabf930ba96","modified":1525412794261},{"_id":"themes/Next/source/lib/font-awesome/bower.json","hash":"279a8a718ab6c930a67c41237f0aac166c1b9440","modified":1525412794262},{"_id":"themes/Next/source/lib/jquery/.bower.json","hash":"91745c2cc6c946c7275f952b2b0760b880cea69e","modified":1525412794288},{"_id":"themes/Next/source/lib/jquery_lazyload/.bower.json","hash":"b7638afc93e9cd350d0783565ee9a7da6805ad8e","modified":1525412794289},{"_id":"themes/Next/source/lib/jquery_lazyload/CONTRIBUTING.md","hash":"4891864c24c28efecd81a6a8d3f261145190f901","modified":1525412794290},{"_id":"themes/Next/source/lib/jquery_lazyload/README.md","hash":"895d50fa29759af7835256522e9dd7dac597765c","modified":1525412794290},{"_id":"themes/Next/source/lib/jquery_lazyload/bower.json","hash":"65bc85d12197e71c40a55c0cd7f6823995a05222","modified":1525412794290},{"_id":"themes/Next/source/lib/jquery_lazyload/jquery.lazyload.js","hash":"481fd478650e12b67c201a0ea41e92743f8b45a3","modified":1525412794290},{"_id":"themes/Next/source/lib/needsharebutton/needsharebutton.css","hash":"3ef0020a1815ca6151ea4886cd0d37421ae3695c","modified":1525412794292},{"_id":"themes/Next/source/lib/jquery_lazyload/jquery.scrollstop.js","hash":"0e9a81785a011c98be5ea821a8ed7d411818cfd1","modified":1525412794291},{"_id":"themes/Next/source/lib/needsharebutton/needsharebutton.js","hash":"9885fd9bea5e7ebafc5b1de9d17be5e106248d96","modified":1525412794292},{"_id":"themes/Next/source/lib/needsharebutton/font-embedded.css","hash":"c39d37278c1e178838732af21bd26cd0baeddfe0","modified":1525412794292},{"_id":"themes/Next/source/lib/pace/pace-theme-barber-shop.min.css","hash":"ee0d51446cb4ffe1bb96bd7bc8c8e046dddfcf46","modified":1525412794292},{"_id":"themes/Next/source/lib/pace/pace-theme-big-counter.min.css","hash":"5b561dc328af4c4d512e20a76fe964d113a32ba8","modified":1525412794293},{"_id":"themes/Next/source/lib/pace/pace-theme-center-atom.min.css","hash":"dcf79c24fe5350fb73d8038573a104e73639e9d3","modified":1525412794293},{"_id":"themes/Next/source/lib/pace/pace-theme-bounce.min.css","hash":"f6bdb9a785b7979dd8ec5c60e278af955ef1e585","modified":1525412794293},{"_id":"themes/Next/source/lib/pace/pace-theme-center-circle.min.css","hash":"a4066769c78affbfbc5e30a600e2c7862cd532e0","modified":1525412794294},{"_id":"themes/Next/source/lib/pace/pace-theme-center-radar.min.css","hash":"ab7cba998bf4c03b13df342bf43647fa4f419783","modified":1525412794294},{"_id":"themes/Next/source/lib/pace/pace-theme-center-simple.min.css","hash":"67f44c947548bd4d77e7590d3f59e236cbf9e98a","modified":1525412794294},{"_id":"themes/Next/source/lib/pace/pace-theme-corner-indicator.min.css","hash":"b3c64c973f31884e3d8145989476707333406b9a","modified":1525412794294},{"_id":"themes/Next/source/lib/pace/pace-theme-fill-left.min.css","hash":"0bec1e235a4a2cccda3f993b205424e1441a44ae","modified":1525412794294},{"_id":"themes/Next/source/lib/pace/pace-theme-flash.min.css","hash":"13ace22c40312d7bbd8d9c1e50eff897a7a497d8","modified":1525412794295},{"_id":"themes/Next/source/lib/pace/pace-theme-loading-bar.min.css","hash":"7ee28875dfc1230d76c537f6605766e8d4011e9f","modified":1525412794295},{"_id":"themes/Next/source/lib/pace/pace-theme-mac-osx.min.css","hash":"9f2e7b51b084da407863826b25265b31150b3821","modified":1525412794295},{"_id":"themes/Next/source/lib/pace/pace-theme-minimal.min.css","hash":"9cd783cceb8a191f3c8b5d81f7a430ecc3e489d3","modified":1525412794295},{"_id":"themes/Next/source/lib/pace/pace.min.js","hash":"9944dfb7814b911090e96446cea4d36e2b487234","modified":1525412794295},{"_id":"themes/Next/source/lib/three/canvas_lines.min.js","hash":"dce4a3b65f8bf958f973690caa7ec4952f353b0c","modified":1525412794296},{"_id":"themes/Next/source/lib/three/canvas_sphere.min.js","hash":"d8ea241a53c135a650f7335d2b6982b899fd58a9","modified":1525412794296},{"_id":"themes/Next/source/lib/three/three-waves.min.js","hash":"d968cba6b3a50b3626a02d67b544f349d83b147c","modified":1525412794297},{"_id":"themes/Next/source/lib/velocity/.bower.json","hash":"05f960846f1c7a93dab1d3f9a1121e86812e8c88","modified":1525412794301},{"_id":"themes/Next/source/lib/velocity/bower.json","hash":"2ec99573e84c7117368beccb9e94b6bf35d2db03","modified":1525412794301},{"_id":"themes/Next/source/lib/velocity/velocity.min.js","hash":"2f1afadc12e4cf59ef3b405308d21baa97e739c6","modified":1525412794303},{"_id":"themes/Next/source/lib/velocity/velocity.ui.js","hash":"6a1d101eab3de87527bb54fcc8c7b36b79d8f0df","modified":1525412794303},{"_id":"themes/Next/source/lib/velocity/velocity.ui.min.js","hash":"ed5e534cd680a25d8d14429af824f38a2c7d9908","modified":1525412794304},{"_id":"themes/Next/source/lib/jquery/index.js","hash":"41b4bfbaa96be6d1440db6e78004ade1c134e276","modified":1525412794289},{"_id":"themes/Next/.git/logs/refs/heads/master","hash":"57879eef94f7dd37fd0ba4403c065d49c515d7ab","modified":1525412794191},{"_id":"themes/Next/.git/refs/remotes/origin/HEAD","hash":"d9427cda09aba1cdde5c69c2b13c905bddb0bc51","modified":1525412794190},{"_id":"themes/Next/layout/_third-party/search/algolia-search/assets.swig","hash":"28ff4ed6714c59124569ffcbd10f1173d53ca923","modified":1525412794216},{"_id":"themes/Next/layout/_third-party/search/algolia-search/dom.swig","hash":"ba698f49dd3a868c95b240d802f5b1b24ff287e4","modified":1525412794217},{"_id":"themes/Next/source/css/_common/components/back-to-top-sidebar.styl","hash":"4719ce717962663c5c33ef97b1119a0b3a4ecdc3","modified":1525412794223},{"_id":"themes/Next/source/css/_common/components/buttons.styl","hash":"7e509c7c28c59f905b847304dd3d14d94b6f3b8e","modified":1525412794223},{"_id":"themes/Next/source/css/_common/components/back-to-top.styl","hash":"31050fc7a25784805b4843550151c93bfa55c9c8","modified":1525412794223},{"_id":"themes/Next/source/css/_common/components/comments.styl","hash":"471f1627891aca5c0e1973e09fbcb01e1510d193","modified":1525412794223},{"_id":"themes/Next/source/css/_common/components/components.styl","hash":"a6bb5256be6195e76addbda12f4ed7c662d65e7a","modified":1525412794223},{"_id":"themes/Next/source/css/_common/components/pagination.styl","hash":"c5d48863f332ff8ce7c88dec2c893f709d7331d3","modified":1525412794227},{"_id":"themes/Next/source/css/_common/components/tag-cloud.styl","hash":"dd8a3b22fc2f222ac6e6c05bd8a773fb039169c0","modified":1525412794230},{"_id":"themes/Next/source/css/_common/outline/outline.styl","hash":"2186be20e317505cd31886f1291429cc21f76703","modified":1525412794234},{"_id":"themes/Next/source/css/_common/scaffolding/base.styl","hash":"f7c44b0ee46cf2cf82a4c9455ba8d8b55299976f","modified":1525412794234},{"_id":"themes/Next/source/css/_common/scaffolding/mobile.styl","hash":"47a46583a1f3731157a3f53f80ed1ed5e2753e8e","modified":1525412794235},{"_id":"themes/Next/source/css/_common/scaffolding/helpers.styl","hash":"9c25c75311e1bd4d68df031d3f2ae6d141a90766","modified":1525412794234},{"_id":"themes/Next/source/css/_common/scaffolding/normalize.styl","hash":"ece571f38180febaf02ace8187ead8318a300ea7","modified":1525412794235},{"_id":"themes/Next/source/css/_common/scaffolding/scaffolding.styl","hash":"a280a583b7615e939aaddbf778f5c108ef8a2a6c","modified":1525412794235},{"_id":"themes/Next/source/css/_common/scaffolding/tables.styl","hash":"64f5d56c08d74a338813df1265580ca0cbf0190b","modified":1525412794235},{"_id":"themes/Next/source/css/_schemes/Gemini/index.styl","hash":"18c3336ee3d09bd2da6a876e1336539f03d5a973","modified":1525412794236},{"_id":"themes/Next/source/css/_schemes/Mist/_base.styl","hash":"c2d079788d6fc2e9a191ccdae94e50d55bf849dc","modified":1525412794236},{"_id":"themes/Next/source/css/_schemes/Mist/_header.styl","hash":"5ae7906dc7c1d9468c7f4b4a6feddddc555797a1","modified":1525412794236},{"_id":"themes/Next/source/css/_schemes/Mist/_logo.styl","hash":"38e5df90c8689a71c978fd83ba74af3d4e4e5386","modified":1525412794237},{"_id":"themes/Next/source/css/_schemes/Mist/_menu.styl","hash":"b0dcca862cd0cc6e732e33d975b476d744911742","modified":1525412794237},{"_id":"themes/Next/source/css/_schemes/Mist/_posts-expanded.styl","hash":"3b25edfa187d1bbbd0d38b50dd013cef54758abf","modified":1525412794237},{"_id":"themes/Next/source/css/_schemes/Mist/_search.styl","hash":"1452cbe674cc1d008e1e9640eb4283841058fc64","modified":1525412794237},{"_id":"themes/Next/source/css/_schemes/Mist/index.styl","hash":"9a5581a770af8964064fef7afd3e16963e45547f","modified":1525412794237},{"_id":"themes/Next/source/css/_schemes/Muse/_logo.styl","hash":"8829bc556ca38bfec4add4f15a2f028092ac6d46","modified":1525412794238},{"_id":"themes/Next/source/css/_schemes/Muse/_layout.styl","hash":"0efa036a15c18f5abb058b7c0fad1dd9ac5eed4c","modified":1525412794238},{"_id":"themes/Next/source/css/_schemes/Muse/_menu.styl","hash":"4aac01962520d60b03b23022ab601ad4bd19c08c","modified":1525412794238},{"_id":"themes/Next/source/css/_schemes/Muse/_search.styl","hash":"1452cbe674cc1d008e1e9640eb4283841058fc64","modified":1525412794238},{"_id":"themes/Next/source/css/_schemes/Muse/index.styl","hash":"a0e2030a606c934fb2c5c7373aaae04a1caac4c5","modified":1525412794238},{"_id":"themes/Next/source/css/_schemes/Pisces/_brand.styl","hash":"c4ed249798296f60bda02351fe6404fb3ef2126f","modified":1525412794239},{"_id":"themes/Next/source/css/_schemes/Pisces/_layout.styl","hash":"5b93958239d3d2bf9aeaede44eced2434d784462","modified":1525412794239},{"_id":"themes/Next/source/css/_schemes/Pisces/_menu.styl","hash":"215de948be49bcf14f06d500cef9f7035e406a43","modified":1525412794239},{"_id":"themes/Next/source/css/_schemes/Pisces/_posts.styl","hash":"2f878213cb24c5ddc18877f6d15ec5c5f57745ac","modified":1525412794239},{"_id":"themes/Next/source/css/_schemes/Pisces/_sidebar.styl","hash":"9d16fa3c14ed76b71229f022b63a02fd0f580958","modified":1525412794240},{"_id":"themes/Next/source/css/_schemes/Pisces/index.styl","hash":"69ecd6c97e7cdfd822ac8102b45ad0ede85050db","modified":1525412794240},{"_id":"themes/Next/source/js/src/schemes/pisces.js","hash":"8050a5b2683d1d77238c5762b6bd89c543daed6e","modified":1525412794247},{"_id":"themes/Next/source/lib/Han/dist/han.css","hash":"bd40da3fba8735df5850956814e312bd7b3193d7","modified":1525412794250},{"_id":"themes/Next/source/lib/Han/dist/han.min.css","hash":"a0c9e32549a8b8cf327ab9227b037f323cdb60ee","modified":1525412794251},{"_id":"themes/Next/source/lib/Han/dist/han.min.js","hash":"f559c68a25065a14f47da954a7617d87263e409d","modified":1525412794252},{"_id":"themes/Next/source/lib/fancybox/source/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1525412794256},{"_id":"themes/Next/source/lib/fancybox/source/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1525412794256},{"_id":"themes/Next/source/lib/fancybox/source/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1525412794256},{"_id":"themes/Next/source/lib/fancybox/source/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1525412794257},{"_id":"themes/Next/source/lib/fancybox/source/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1525412794257},{"_id":"themes/Next/source/lib/fancybox/source/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1525412794257},{"_id":"themes/Next/source/lib/fancybox/source/jquery.fancybox.css","hash":"5f163444617b6cf267342f06ac166a237bb62df9","modified":1525412794259},{"_id":"themes/Next/source/lib/fancybox/source/jquery.fancybox.pack.js","hash":"53360764b429c212f424399384417ccc233bb3be","modified":1525412794259},{"_id":"themes/Next/source/lib/fancybox/source/jquery.fancybox.js","hash":"1cf3d47b5ccb7cb6e9019c64f2a88d03a64853e4","modified":1525412794259},{"_id":"themes/Next/source/lib/fastclick/lib/fastclick.js","hash":"06cef196733a710e77ad7e386ced6963f092dc55","modified":1525412794260},{"_id":"themes/Next/source/lib/fastclick/lib/fastclick.min.js","hash":"2cae0f5a6c5d6f3cb993015e6863f9483fc4de18","modified":1525412794261},{"_id":"themes/Next/source/lib/font-awesome/css/font-awesome.css.map","hash":"0189d278706509412bac4745f96c83984e1d59f4","modified":1525412794262},{"_id":"themes/Next/source/lib/font-awesome/css/font-awesome.css","hash":"0140952c64e3f2b74ef64e050f2fe86eab6624c8","modified":1525412794262},{"_id":"themes/Next/source/lib/font-awesome/css/font-awesome.min.css","hash":"512c7d79033e3028a9be61b540cf1a6870c896f8","modified":1525412794262},{"_id":"themes/Next/source/lib/ua-parser-js/dist/ua-parser.min.js","hash":"38628e75e4412cc6f11074e03e1c6d257aae495b","modified":1525412794300},{"_id":"themes/Next/source/lib/ua-parser-js/dist/ua-parser.pack.js","hash":"214dad442a92d36af77ed0ca1d9092b16687f02f","modified":1525412794300},{"_id":"themes/Next/source/lib/Han/dist/han.js","hash":"e345397e0585c9fed1449e614ec13e0224acf2ab","modified":1525412794251},{"_id":"themes/Next/source/lib/font-awesome/fonts/fontawesome-webfont.woff","hash":"28b782240b3e76db824e12c02754a9731a167527","modified":1525412794287},{"_id":"themes/Next/source/lib/font-awesome/fonts/fontawesome-webfont.woff2","hash":"d6f48cba7d076fb6f2fd6ba993a75b9dc1ecbf0c","modified":1525412794287},{"_id":"themes/Next/source/lib/velocity/velocity.js","hash":"9f08181baea0cc0e906703b7e5df9111b9ef3373","modified":1525412794302},{"_id":"themes/Next/.git/logs/refs/remotes/origin/HEAD","hash":"57879eef94f7dd37fd0ba4403c065d49c515d7ab","modified":1525412794189},{"_id":"themes/Next/source/css/_common/components/header/headerband.styl","hash":"d27448f199fc2f9980b601bc22b87f08b5d64dd1","modified":1525412794224},{"_id":"themes/Next/source/css/_common/components/footer/footer.styl","hash":"7905a7f625702b45645d8be1268cb8af3f698c70","modified":1525412794224},{"_id":"themes/Next/source/css/_common/components/header/site-meta.styl","hash":"6c00f6e0978f4d8f9a846a15579963728aaa6a17","modified":1525412794225},{"_id":"themes/Next/source/css/_common/components/header/header.styl","hash":"ae1ca14e51de67b07dba8f61ec79ee0e2e344574","modified":1525412794224},{"_id":"themes/Next/source/css/_common/components/header/menu.styl","hash":"8a2421cb9005352905fae9d41a847ae56957247e","modified":1525412794224},{"_id":"themes/Next/source/css/_common/components/header/site-nav.styl","hash":"49c2b2c14a1e7fcc810c6be4b632975d0204c281","modified":1525412794225},{"_id":"themes/Next/source/css/_common/components/highlight/diff.styl","hash":"96f32ea6c3265a3889e6abe57587f6e2a2a40dfb","modified":1525412794225},{"_id":"themes/Next/source/css/_common/components/highlight/highlight.styl","hash":"25dc25f61a232f03ca72472b7852f882448ec185","modified":1525412794225},{"_id":"themes/Next/source/css/_common/components/pages/archive.styl","hash":"f5aa2ba3bfffc15475e7e72a55b5c9d18609fdf5","modified":1525412794226},{"_id":"themes/Next/source/css/_common/components/pages/pages.styl","hash":"2039590632bba3943c39319d80ef630af7928185","modified":1525412794226},{"_id":"themes/Next/source/css/_common/components/pages/categories.styl","hash":"4eff5b252d7b614e500fc7d52c97ce325e57d3ab","modified":1525412794226},{"_id":"themes/Next/source/css/_common/components/highlight/theme.styl","hash":"b76387934fb6bb75212b23c1a194486892cc495e","modified":1525412794225},{"_id":"themes/Next/source/css/_common/components/pages/post-detail.styl","hash":"9bf4362a4d0ae151ada84b219d39fbe5bb8c790e","modified":1525412794226},{"_id":"themes/Next/source/css/_common/components/post/post-button.styl","hash":"e72a89e0f421444453e149ba32c77a64bd8e44e8","modified":1525412794227},{"_id":"themes/Next/source/css/_common/components/pages/schedule.styl","hash":"a82afbb72d83ee394aedc7b37ac0008a9823b4f4","modified":1525412794226},{"_id":"themes/Next/source/css/_common/components/post/post-collapse.styl","hash":"0f7f522cc6bfb3401d5afd62b0fcdf48bb2d604b","modified":1525412794227},{"_id":"themes/Next/source/css/_common/components/post/post-copyright.styl","hash":"f54367c0feda6986c030cc4d15a0ca6ceea14bcb","modified":1525412794227},{"_id":"themes/Next/source/css/_common/components/post/post-eof.styl","hash":"2cdc094ecf907a02fce25ad4a607cd5c40da0f2b","modified":1525412794227},{"_id":"themes/Next/source/css/_common/components/post/post-gallery.styl","hash":"387ce23bba52b22a586b2dfb4ec618fe1ffd3926","modified":1525412794228},{"_id":"themes/Next/source/css/_common/components/post/post-expand.styl","hash":"535b3b4f8cb1eec2558e094320e7dfb01f94c0e7","modified":1525412794227},{"_id":"themes/Next/source/css/_common/components/post/post-meta.styl","hash":"aea21141015ca8c409d8b33e3e34ec505f464e93","modified":1525412794228},{"_id":"themes/Next/source/css/_common/components/post/post-nav.styl","hash":"a5d8617a24d7cb6c5ad91ea621183ca2c0917331","modified":1525412794228},{"_id":"themes/Next/source/css/_common/components/post/post-rtl.styl","hash":"017074ef58166e2d69c53bb7590a0e7a8947a1ed","modified":1525412794228},{"_id":"themes/Next/source/css/_common/components/post/post-title.styl","hash":"d5a4e4fc17f1f7e7c3a61b52d8e2e9677e139de7","modified":1525412794228},{"_id":"themes/Next/source/css/_common/components/post/post-tags.styl","hash":"a352ae5b1f8857393bf770d2e638bf15f0c9585d","modified":1525412794228},{"_id":"themes/Next/source/css/_common/components/post/post-reward.styl","hash":"8178cd4abbc74a9d1a139b3eb9fc1d677e2118d0","modified":1525421128386},{"_id":"themes/Next/source/css/_common/components/post/post-type.styl","hash":"10251257aceecb117233c9554dcf8ecfef8e2104","modified":1525412794229},{"_id":"themes/Next/source/css/_common/components/post/post-widgets.styl","hash":"e4055a0d2cd2b0ad9dc55928e2f3e7bd4e499da3","modified":1525412794229},{"_id":"themes/Next/source/css/_common/components/post/post.styl","hash":"262debfd4442fa03d9919ceb88b948339df03fb0","modified":1525412794229},{"_id":"themes/Next/source/css/_common/components/sidebar/sidebar-author-links.styl","hash":"0a6c0efffdf18bddbc1d1238feaed282b09cd0fe","modified":1525412794229},{"_id":"themes/Next/source/css/_common/components/sidebar/sidebar-blogroll.styl","hash":"89dd4f8b1f1cce3ad46cf2256038472712387d02","modified":1525412794229},{"_id":"themes/Next/source/css/_common/components/sidebar/sidebar-author.styl","hash":"920343e41c124221a17f050bbb989494d44f7a24","modified":1525412794229},{"_id":"themes/Next/source/css/_common/components/sidebar/sidebar-dimmer.styl","hash":"efa5e5022e205b52786ce495d4879f5e7b8f84b2","modified":1525412794229},{"_id":"themes/Next/source/css/_common/components/sidebar/sidebar-feed-link.styl","hash":"9486ddd2cb255227db102d09a7df4cae0fabad72","modified":1525412794230},{"_id":"themes/Next/source/css/_common/components/sidebar/sidebar-toc.styl","hash":"12937cae17c96c74d5c58db6cb29de3b2dfa14a2","modified":1525412794230},{"_id":"themes/Next/source/css/_common/components/sidebar/sidebar-toggle.styl","hash":"f7784aba0c1cd20d824c918c120012d57a5eaa2a","modified":1525412794230},{"_id":"themes/Next/source/css/_common/components/sidebar/sidebar.styl","hash":"50305b6ad7d09d2ffa4854e39f41ec1f4fe984fd","modified":1525412794230},{"_id":"themes/Next/source/css/_common/components/sidebar/site-state.styl","hash":"3623e7fa4324ec1307370f33d8f287a9e20a5578","modified":1525412794230},{"_id":"themes/Next/source/css/_common/components/sidebar/sidebar-nav.styl","hash":"45fa7193435a8eae9960267438750b4c9fa9587f","modified":1525412794230},{"_id":"themes/Next/source/css/_common/components/tags/group-pictures.styl","hash":"4851b981020c5cbc354a1af9b831a2dcb3cf9d39","modified":1525412794231},{"_id":"themes/Next/source/css/_common/components/tags/blockquote-center.styl","hash":"c2abe4d87148e23e15d49ee225bc650de60baf46","modified":1525412794231},{"_id":"themes/Next/source/css/_common/components/tags/exturl.styl","hash":"1b3cc9f4e5a7f6e05b4100e9990b37b20d4a2005","modified":1525412794231},{"_id":"themes/Next/source/css/_common/components/tags/label.styl","hash":"4a457d265d62f287c63d48764ce45d9bcfc9ec5a","modified":1525412794231},{"_id":"themes/Next/source/css/_common/components/tags/full-image.styl","hash":"37e951e734a252fe8a81f452b963df2ba90bfe90","modified":1525412794231},{"_id":"themes/Next/source/css/_common/components/tags/note.styl","hash":"32c9156bea5bac9e9ad0b4c08ffbca8b3d9aac4b","modified":1525412794232},{"_id":"themes/Next/source/css/_common/components/tags/tabs.styl","hash":"4ab5deed8c3b0c338212380f678f8382672e1bcb","modified":1525412794232},{"_id":"themes/Next/source/css/_common/components/tags/note-modern.styl","hash":"ee7528900578ef4753effe05b346381c40de5499","modified":1525412794231},{"_id":"themes/Next/source/css/_common/components/tags/tags.styl","hash":"ead0d0f2321dc71505788c7f689f92257cf14947","modified":1525412794232},{"_id":"themes/Next/source/css/_common/components/third-party/algolia-search.styl","hash":"fd42777b9125fd8969dc39d4f15473e2b91b4142","modified":1525412794232},{"_id":"themes/Next/source/css/_common/components/third-party/busuanzi-counter.styl","hash":"d4e6d8d7b34dc69994593c208f875ae8f7e8a3ae","modified":1525412794232},{"_id":"themes/Next/source/css/_common/components/third-party/duoshuo.styl","hash":"2340dd9b3202c61d73cc708b790fac5adddbfc7f","modified":1525412794233},{"_id":"themes/Next/source/css/_common/components/third-party/baidushare.styl","hash":"93b08815c4d17e2b96fef8530ec1f1064dede6ef","modified":1525412794232},{"_id":"themes/Next/source/css/_common/components/third-party/gitment.styl","hash":"34935b40237c074be5f5e8818c14ccfd802b7439","modified":1525412794233},{"_id":"themes/Next/source/css/_common/components/third-party/localsearch.styl","hash":"d89c4b562b528e4746696b2ad8935764d133bdae","modified":1525412794233},{"_id":"themes/Next/source/css/_common/components/third-party/needsharebutton.styl","hash":"a5e3e6b4b4b814a9fe40b34d784fed67d6d977fa","modified":1525412794234},{"_id":"themes/Next/source/css/_common/components/third-party/third-party.styl","hash":"1ccfbd4d0f5754b2dc2719a91245c95f547a7652","modified":1525412794234},{"_id":"themes/Next/source/css/_common/components/third-party/jiathis.styl","hash":"327b5f63d55ec26f7663185c1a778440588d9803","modified":1525412794233},{"_id":"themes/Next/source/css/_common/components/third-party/han.styl","hash":"cce6772e2cdb4db85d35486ae4c6c59367fbdd40","modified":1525412794233},{"_id":"themes/Next/source/css/_schemes/Mist/outline/outline.styl","hash":"5dc4859c66305f871e56cba78f64bfe3bf1b5f01","modified":1525412794237},{"_id":"themes/Next/source/css/_schemes/Mist/sidebar/sidebar-blogroll.styl","hash":"817587e46df49e819858c8ecbafa08b53d5ff040","modified":1525412794238},{"_id":"themes/Next/source/css/_schemes/Muse/sidebar/sidebar-blogroll.styl","hash":"817587e46df49e819858c8ecbafa08b53d5ff040","modified":1525412794239},{"_id":"themes/Next/source/lib/Han/dist/font/han-space.otf","hash":"07436f011b44051f61b8329c99de4bec64e86f4b","modified":1525412794249},{"_id":"themes/Next/source/lib/Han/dist/font/han-space.woff","hash":"7a635062b10bf5662ae1d218ba0980171005d060","modified":1525412794249},{"_id":"themes/Next/source/lib/Han/dist/font/han.otf","hash":"f1f6bb8f461f5672e000380195d3d2358a28494c","modified":1525412794249},{"_id":"themes/Next/source/lib/Han/dist/font/han.woff2","hash":"623af3ed5423371ac136a4fe0e8cc7bb7396037a","modified":1525412794250},{"_id":"themes/Next/source/lib/Han/dist/font/han.woff","hash":"f38ff9b2eecaa17b50b66aa2dae87e9e7436d195","modified":1525412794250},{"_id":"themes/Next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.css","hash":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1525412794257},{"_id":"themes/Next/source/lib/fancybox/source/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1525412794257},{"_id":"themes/Next/source/lib/fancybox/source/helpers/jquery.fancybox-media.js","hash":"3bdf69ed2469e4fb57f5a95f17300eef891ff90d","modified":1525412794258},{"_id":"themes/Next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.js","hash":"91e41741c2e93f732c82aaacec4cfc6e3f3ec876","modified":1525412794258},{"_id":"themes/Next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","hash":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1525412794258},{"_id":"themes/Next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","hash":"53e194f4a72e649c04fb586dd57762b8c022800b","modified":1525412794258},{"_id":"themes/Next/source/lib/font-awesome/fonts/FontAwesome.otf","hash":"048707bc52ac4b6563aaa383bfe8660a0ddc908c","modified":1525412794264},{"_id":"themes/Next/source/lib/font-awesome/fonts/fontawesome-webfont.eot","hash":"d980c2ce873dc43af460d4d572d441304499f400","modified":1525412794265},{"_id":"themes/Next/source/lib/font-awesome/fonts/fontawesome-webfont.ttf","hash":"13b1eab65a983c7a73bc7997c479d66943f7c6cb","modified":1525412794285},{"_id":"themes/Next/.git/objects/pack/pack-44f8d26b13b40bf6211ee93287b429a93cb2b5b4.idx","hash":"d5ba13477eb1a0d4ef3bd4c1d6bb51ecf57cb37f","modified":1525412794174},{"_id":"themes/Next/source/lib/algolia-instant-search/instantsearch.min.js","hash":"9ccc6f8144f54e86df9a3fd33a18368d81cf3a4f","modified":1525412794254},{"_id":"themes/Next/source/lib/three/three.min.js","hash":"73f4cdc17e51a72b9bf5b9291f65386d615c483b","modified":1525412794300},{"_id":"themes/Next/source/lib/font-awesome/fonts/fontawesome-webfont.svg","hash":"98a8aa5cf7d62c2eff5f07ede8d844b874ef06ed","modified":1525412794268},{"_id":"themes/Next/.git/objects/pack/pack-44f8d26b13b40bf6211ee93287b429a93cb2b5b4.pack","hash":"b2fe56e7ec4d44ebc5be59f9296fa57f7ee42a03","modified":1525412794166},{"_id":"public/baidusitemap.xml","hash":"680577e0a96314d33650c06f45566635948acdcf","modified":1599189325293},{"_id":"public/content.json","hash":"09c687b96d96bf822a4a4cadb6f25f0f0af3df4e","modified":1599189325328},{"_id":"public/atom.xml","hash":"e2241f37697cdf68da623463c154202bc69df313","modified":1599189325329},{"_id":"public/sitemap.xml","hash":"e4cc59ba7e8b716a2b68761925f0656e3a002c02","modified":1599189325329},{"_id":"public/categories/index.html","hash":"835aef43a3001926d9fc4a0ab10795e5da82217c","modified":1633939146663},{"_id":"public/tags/index.html","hash":"d11426e2b695e9d07ac05df8c3e35cecf66e8fec","modified":1633939146664},{"_id":"public/about/index.html","hash":"5f2e0464de054073aa5ad149914481cdbd345036","modified":1633939146661},{"_id":"public/archives/2017/index.html","hash":"1dddf60669c60fafe60d5d3346bdce1bf2189e76","modified":1633939146666},{"_id":"public/archives/2017/08/index.html","hash":"b5cad975abe275c3efd16ba9b4b30c3bb5724aac","modified":1633939146664},{"_id":"public/archives/2017/11/index.html","hash":"4c7100f21758af02ad10afd6f967c6a88b40ab25","modified":1633939146665},{"_id":"public/archives/2017/12/index.html","hash":"7a5477e188dbca7e1c3155e92755813317c8d200","modified":1633939146665},{"_id":"public/archives/2018/03/index.html","hash":"68f5bdf9b6a86faaacbda23d81c0dd0092b01dce","modified":1633939146665},{"_id":"public/archives/2018/04/index.html","hash":"d36b91efe93de6bf4590bdddc85cb1ad8126d659","modified":1633939146665},{"_id":"public/archives/2018/05/index.html","hash":"3022a2f782d7519ed637b01b76c639aef78e8900","modified":1633939146665},{"_id":"public/categories/技术分享/index.html","hash":"09d082b1919baad174d54ada6b9e2822e4e906d7","modified":1633939146666},{"_id":"public/categories/面试题/index.html","hash":"3a86fff6ad90b0d0c01e0ad9c9a4b1bd72738416","modified":1633939146666},{"_id":"public/categories/面试题/vue/index.html","hash":"9d551cbc5db824639b46c37732a7e5eebf61bb4c","modified":1633939146664},{"_id":"public/categories/面试题/vue/react/index.html","hash":"84d84845b83e73a8a72c2df1246bf9eb54dd878c","modified":1633939146664},{"_id":"public/tags/git/index.html","hash":"5ee88f72cd51c2f5dd8fc6e732daed0ff70126f1","modified":1633939146670},{"_id":"public/tags/Bower/index.html","hash":"599c2fdd482f7ad401c363bd88e7568f35cb54f5","modified":1633939146670},{"_id":"public/tags/indexOf/index.html","hash":"cd3ae064b6ab52b6e90c472ac96715434a660a68","modified":1633939146670},{"_id":"public/tags/javascript深克隆/index.html","hash":"cb0a7fccdf8d9af05b9710206f040899b7e4456a","modified":1633939146670},{"_id":"public/tags/route/index.html","hash":"1df709a32528570732502b33ee89faac921387e5","modified":1633939146670},{"_id":"public/tags/javascript数据类型/index.html","hash":"16fe1673c354cfb4d846de75c25ef64ad2bb09ee","modified":1633939146670},{"_id":"public/tags/markdown/index.html","hash":"2e3ec4c823de99202ec1752d77f718972dfc5fb2","modified":1633939146670},{"_id":"public/tags/vue/index.html","hash":"2a86850e8ada20bc0baf8aaaa314e865ecbea4f0","modified":1633939146670},{"_id":"public/tags/proxy/index.html","hash":"40bd2b77a4898ab8dcacefdf478bb5976b709bc2","modified":1633939146670},{"_id":"public/tags/defineproperty/index.html","hash":"85ca8d415e52cb9e6fc21ef699d66bd8cb3c1e43","modified":1633939146670},{"_id":"public/tags/Event-Bus/index.html","hash":"a09db817e6a47feeff3f79002ded4b2f18ab833c","modified":1633939146670},{"_id":"public/2018/05/18/js-Array-indexOf方法/index.html","hash":"6780dca71013719812f59dad8605f10d38bd9d08","modified":1577244656154},{"_id":"public/2018/05/11/markdown摘要/index.html","hash":"2806c7f4f0ae0b07d43688c735f7857f4af5670f","modified":1633939146665},{"_id":"public/2018/05/08/vue-proxy_defineproperty优劣/index.html","hash":"7f9af859b8f5100076b50722b40db180fef637df","modified":1633939146665},{"_id":"public/2018/05/05/js-实现路由/index.html","hash":"c5ab66553f7a2b2e611db97ab098fc1690cfcc8f","modified":1633939146665},{"_id":"public/2018/04/23/vue-react-EventBus/index.html","hash":"9718d83eb69e23b9ccf0ebbd9e6c7768aa2255bb","modified":1633939146665},{"_id":"public/2018/04/07/js-clone/index.html","hash":"dbccc855311e91ed90a4974c13786341e1274e48","modified":1633939146665},{"_id":"public/2018/03/06/js-dataType/index.html","hash":"580952ece3506498886a82233c85c104978402cc","modified":1633939146665},{"_id":"public/2017/12/03/Bower/index.html","hash":"3d7d4f84c286e5e716a65ff49563fcb648fda4ef","modified":1633939146665},{"_id":"public/2017/08/16/js-drag/index.html","hash":"fe0f47dc1b518dbd63b0fc4da2cafa1ba90634a5","modified":1633939146666},{"_id":"public/2017/11/07/git-usage/index.html","hash":"7b7ba2f4a72b9059c475a2804a8a646011102fa8","modified":1633939146665},{"_id":"public/archives/index.html","hash":"c35efb6f566857a118cf4f72784ab8b2f150ed74","modified":1633939146666},{"_id":"public/archives/2018/index.html","hash":"e135f46ac63bc44d5326def5d5301683a044aa2b","modified":1633939146666},{"_id":"public/index.html","hash":"f516e2068d56d26d8af7e24cb2d08e8548c21b56","modified":1633939146671},{"_id":"public/favicon.ico","hash":"c78cdd5fab76a7c6113cdf8f57e8c23dcb7f484e","modified":1577091190075},{"_id":"public/images/algolia_logo.svg","hash":"ec119560b382b2624e00144ae01c137186e91621","modified":1577091190075},{"_id":"public/images/avatar.gif","hash":"264082bb3a1af70d5499c7d22b0902cb454b6d12","modified":1577091190075},{"_id":"public/images/apple-touch-icon-next.png","hash":"2959dbc97f31c80283e67104fe0854e2369e40aa","modified":1577091190075},{"_id":"public/images/cc-by-nc-nd.svg","hash":"c6524ece3f8039a5f612feaf865d21ec8a794564","modified":1577091190075},{"_id":"public/images/cc-by-nc-sa.svg","hash":"3031be41e8753c70508aa88e84ed8f4f653f157e","modified":1577091190075},{"_id":"public/images/cc-by-nc.svg","hash":"8d39b39d88f8501c0d27f8df9aae47136ebc59b7","modified":1577091190075},{"_id":"public/images/cc-by-nd.svg","hash":"c563508ce9ced1e66948024ba1153400ac0e0621","modified":1577091190075},{"_id":"public/images/cc-by-sa.svg","hash":"aa4742d733c8af8d38d4c183b8adbdcab045872e","modified":1577091190075},{"_id":"public/images/favicon-32x32-next.png","hash":"0749d7b24b0d2fae1c8eb7f671ad4646ee1894b1","modified":1577091190075},{"_id":"public/images/favicon-16x16-next.png","hash":"943a0d67a9cdf8c198109b28f9dbd42f761d11c3","modified":1577091190075},{"_id":"public/images/cc-zero.svg","hash":"87669bf8ac268a91d027a0a4802c92a1473e9030","modified":1577091190075},{"_id":"public/images/cc-by.svg","hash":"28a0a4fe355a974a5e42f68031652b76798d4f7e","modified":1577091190076},{"_id":"public/images/loading.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1577091190076},{"_id":"public/images/placeholder.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1577091190076},{"_id":"public/images/quote-l.svg","hash":"94e870b4c8c48da61d09522196d4dd40e277a98f","modified":1577091190076},{"_id":"public/images/quote-r.svg","hash":"e60ae504f9d99b712c793c3740c6b100d057d4ec","modified":1577091190076},{"_id":"public/images/logo.svg","hash":"d29cacbae1bdc4bbccb542107ee0524fe55ad6de","modified":1577091190076},{"_id":"public/images/searchicon.png","hash":"67727a6a969be0b2659b908518fa6706eed307b8","modified":1577091190076},{"_id":"public/images/favicon.ico","hash":"c78cdd5fab76a7c6113cdf8f57e8c23dcb7f484e","modified":1577091190076},{"_id":"public/lib/fastclick/LICENSE","hash":"dcd5b6b43095d9e90353a28b09cb269de8d4838e","modified":1577091190076},{"_id":"public/lib/font-awesome/HELP-US-OUT.txt","hash":"4f7bf961f1bed448f6ba99aeb9219fabf930ba96","modified":1577091190076},{"_id":"public/lib/fancybox/source/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1577091190076},{"_id":"public/lib/fancybox/source/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1577091190076},{"_id":"public/lib/fancybox/source/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1577091190076},{"_id":"public/lib/fancybox/source/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1577091190076},{"_id":"public/lib/fancybox/source/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1577091190076},{"_id":"public/lib/fancybox/source/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1577091190076},{"_id":"public/lib/font-awesome/css/font-awesome.css.map","hash":"0189d278706509412bac4745f96c83984e1d59f4","modified":1577091190076},{"_id":"public/lib/Han/dist/font/han-space.otf","hash":"07436f011b44051f61b8329c99de4bec64e86f4b","modified":1577091190076},{"_id":"public/lib/Han/dist/font/han-space.woff","hash":"7a635062b10bf5662ae1d218ba0980171005d060","modified":1577091190076},{"_id":"public/lib/Han/dist/font/han.otf","hash":"f1f6bb8f461f5672e000380195d3d2358a28494c","modified":1577091190076},{"_id":"public/lib/Han/dist/font/han.woff2","hash":"623af3ed5423371ac136a4fe0e8cc7bb7396037a","modified":1577091190076},{"_id":"public/lib/Han/dist/font/han.woff","hash":"f38ff9b2eecaa17b50b66aa2dae87e9e7436d195","modified":1577091190077},{"_id":"public/lib/fancybox/source/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1577091190077},{"_id":"public/assets/algolia/algoliasearchLite.min.js","hash":"f80a0615dbe4fb9d88b11ca53dbd5e3009d68c46","modified":1577091190077},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.woff","hash":"28b782240b3e76db824e12c02754a9731a167527","modified":1577091190555},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.woff2","hash":"d6f48cba7d076fb6f2fd6ba993a75b9dc1ecbf0c","modified":1577091190557},{"_id":"public/assets/algolia/algoliasearchLite.js","hash":"96646dbfb8f703f34dcca30bf227c7db04eaccbc","modified":1577091190557},{"_id":"public/assets/algolia/algoliasearch.min.js","hash":"cd28c96e446b7f5e40a9d33b354f4c22ecc26ea9","modified":1577091190558},{"_id":"public/js/src/affix.js","hash":"978e0422b5bf1b560236d8d10ebc1adcf66392e3","modified":1577091190564},{"_id":"public/js/src/algolia-search.js","hash":"b172f697ed339a24b1e80261075232978d164c35","modified":1577091190564},{"_id":"public/js/src/bootstrap.js","hash":"034bc8113e0966fe2096ba5b56061bbf10ef0512","modified":1577091190564},{"_id":"public/js/src/exturl.js","hash":"e42e2aaab7bf4c19a0c8e779140e079c6aa5c0b1","modified":1577091190564},{"_id":"public/js/src/hook-duoshuo.js","hash":"a6119070c0119f33e08b29da7d2cce2635eb40a0","modified":1577091190564},{"_id":"public/js/src/js.cookie.js","hash":"9b37973a90fd50e71ea91682265715e45ae82c75","modified":1577091190564},{"_id":"public/js/src/scroll-cookie.js","hash":"09dc828cbf5f31158ff6250d2bf7c3cde6365c67","modified":1577091190564},{"_id":"public/js/src/motion.js","hash":"754b294394f102c8fd9423a1789ddb1201677898","modified":1577091190575},{"_id":"public/js/src/post-details.js","hash":"a13f45f7aa8291cf7244ec5ba93907d119c5dbdd","modified":1577091190565},{"_id":"public/js/src/utils.js","hash":"9b1325801d27213083d1487a12b1a62b539ab6f8","modified":1577091190575},{"_id":"public/js/src/scrollspy.js","hash":"fe4da1b9fe73518226446f5f27d2831e4426fc35","modified":1577091190565},{"_id":"public/lib/algolia-instant-search/instantsearch.min.css","hash":"90ef19edc982645b118b095615838d9c5eaba0de","modified":1577091190565},{"_id":"public/lib/canvas-nest/canvas-nest.min.js","hash":"0387e75e23b1db108a755073fe52a0d03eb391a7","modified":1577091190565},{"_id":"public/lib/canvas-ribbon/canvas-ribbon.js","hash":"ff5915eb2596e890a2fc6697c864f861a1995ec0","modified":1577091190565},{"_id":"public/lib/fastclick/README.html","hash":"da3c74d484c73cc7df565e8abbfa4d6a5a18d4da","modified":1577091190565},{"_id":"public/lib/fastclick/bower.json","hash":"4dcecf83afddba148464d5339c93f6d0aa9f42e9","modified":1577091190565},{"_id":"public/lib/font-awesome/bower.json","hash":"64394a2a9aa00f8e321d8daa5e51a420f0e96dad","modified":1577091190565},{"_id":"public/lib/jquery_lazyload/CONTRIBUTING.html","hash":"a6358170d346af13b1452ac157b60505bec7015c","modified":1577091190565},{"_id":"public/lib/jquery_lazyload/README.html","hash":"bde24335f6bc09d8801c0dcd7274f71b466552bd","modified":1577091190565},{"_id":"public/lib/jquery_lazyload/bower.json","hash":"ae3c3b61e6e7f9e1d7e3585ad854380ecc04cf53","modified":1577091190565},{"_id":"public/lib/jquery_lazyload/jquery.lazyload.js","hash":"481fd478650e12b67c201a0ea41e92743f8b45a3","modified":1577091190575},{"_id":"public/lib/needsharebutton/needsharebutton.css","hash":"3ef0020a1815ca6151ea4886cd0d37421ae3695c","modified":1577091190565},{"_id":"public/lib/jquery_lazyload/jquery.scrollstop.js","hash":"0e9a81785a011c98be5ea821a8ed7d411818cfd1","modified":1577091190565},{"_id":"public/lib/pace/pace-theme-big-counter.min.css","hash":"5b561dc328af4c4d512e20a76fe964d113a32ba8","modified":1577091190565},{"_id":"public/lib/pace/pace-theme-barber-shop.min.css","hash":"ee0d51446cb4ffe1bb96bd7bc8c8e046dddfcf46","modified":1577091190565},{"_id":"public/lib/pace/pace-theme-center-atom.min.css","hash":"dcf79c24fe5350fb73d8038573a104e73639e9d3","modified":1577091190565},{"_id":"public/lib/pace/pace-theme-bounce.min.css","hash":"f6bdb9a785b7979dd8ec5c60e278af955ef1e585","modified":1577091190565},{"_id":"public/lib/pace/pace-theme-center-circle.min.css","hash":"a4066769c78affbfbc5e30a600e2c7862cd532e0","modified":1577091190565},{"_id":"public/lib/pace/pace-theme-center-radar.min.css","hash":"ab7cba998bf4c03b13df342bf43647fa4f419783","modified":1577091190566},{"_id":"public/lib/pace/pace-theme-center-simple.min.css","hash":"67f44c947548bd4d77e7590d3f59e236cbf9e98a","modified":1577091190566},{"_id":"public/lib/pace/pace-theme-corner-indicator.min.css","hash":"b3c64c973f31884e3d8145989476707333406b9a","modified":1577091190566},{"_id":"public/lib/pace/pace-theme-fill-left.min.css","hash":"0bec1e235a4a2cccda3f993b205424e1441a44ae","modified":1577091190566},{"_id":"public/lib/pace/pace-theme-loading-bar.min.css","hash":"7ee28875dfc1230d76c537f6605766e8d4011e9f","modified":1577091190575},{"_id":"public/lib/pace/pace-theme-flash.min.css","hash":"13ace22c40312d7bbd8d9c1e50eff897a7a497d8","modified":1577091190566},{"_id":"public/lib/pace/pace-theme-mac-osx.min.css","hash":"9f2e7b51b084da407863826b25265b31150b3821","modified":1577091190566},{"_id":"public/lib/pace/pace-theme-minimal.min.css","hash":"9cd783cceb8a191f3c8b5d81f7a430ecc3e489d3","modified":1577091190566},{"_id":"public/lib/pace/pace.min.js","hash":"9944dfb7814b911090e96446cea4d36e2b487234","modified":1577091190575},{"_id":"public/lib/velocity/bower.json","hash":"0ef14e7ccdfba5db6eb3f8fc6aa3b47282c36409","modified":1577091190566},{"_id":"public/lib/velocity/velocity.ui.min.js","hash":"ed5e534cd680a25d8d14429af824f38a2c7d9908","modified":1577091190575},{"_id":"public/js/src/schemes/pisces.js","hash":"8050a5b2683d1d77238c5762b6bd89c543daed6e","modified":1577091190566},{"_id":"public/lib/fancybox/source/jquery.fancybox.css","hash":"5f163444617b6cf267342f06ac166a237bb62df9","modified":1577091190566},{"_id":"public/lib/fastclick/lib/fastclick.min.js","hash":"2cae0f5a6c5d6f3cb993015e6863f9483fc4de18","modified":1577091190566},{"_id":"public/lib/ua-parser-js/dist/ua-parser.min.js","hash":"38628e75e4412cc6f11074e03e1c6d257aae495b","modified":1577091190576},{"_id":"public/lib/ua-parser-js/dist/ua-parser.pack.js","hash":"214dad442a92d36af77ed0ca1d9092b16687f02f","modified":1577091190576},{"_id":"public/lib/fancybox/source/helpers/jquery.fancybox-buttons.css","hash":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1577091190566},{"_id":"public/lib/fancybox/source/helpers/jquery.fancybox-buttons.js","hash":"91e41741c2e93f732c82aaacec4cfc6e3f3ec876","modified":1577091190566},{"_id":"public/lib/fancybox/source/helpers/jquery.fancybox-media.js","hash":"3bdf69ed2469e4fb57f5a95f17300eef891ff90d","modified":1577091190566},{"_id":"public/lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","hash":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1577091190566},{"_id":"public/lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","hash":"53e194f4a72e649c04fb586dd57762b8c022800b","modified":1577091190566},{"_id":"public/css/main.css","hash":"bd592776202e9dd8aae4a6e3305fa0a248e5aef5","modified":1577091190566},{"_id":"public/lib/needsharebutton/font-embedded.css","hash":"c39d37278c1e178838732af21bd26cd0baeddfe0","modified":1577091190599},{"_id":"public/lib/needsharebutton/needsharebutton.js","hash":"9885fd9bea5e7ebafc5b1de9d17be5e106248d96","modified":1577091190580},{"_id":"public/lib/three/canvas_lines.min.js","hash":"dce4a3b65f8bf958f973690caa7ec4952f353b0c","modified":1577091190592},{"_id":"public/lib/three/three-waves.min.js","hash":"d968cba6b3a50b3626a02d67b544f349d83b147c","modified":1577091190593},{"_id":"public/lib/three/canvas_sphere.min.js","hash":"d8ea241a53c135a650f7335d2b6982b899fd58a9","modified":1577091190592},{"_id":"public/lib/velocity/velocity.min.js","hash":"2f1afadc12e4cf59ef3b405308d21baa97e739c6","modified":1577091190593},{"_id":"public/lib/velocity/velocity.ui.js","hash":"6a1d101eab3de87527bb54fcc8c7b36b79d8f0df","modified":1577091190593},{"_id":"public/lib/jquery/index.js","hash":"41b4bfbaa96be6d1440db6e78004ade1c134e276","modified":1577091190619},{"_id":"public/lib/Han/dist/han.css","hash":"bd40da3fba8735df5850956814e312bd7b3193d7","modified":1577091190607},{"_id":"public/lib/Han/dist/han.min.css","hash":"a0c9e32549a8b8cf327ab9227b037f323cdb60ee","modified":1577091190600},{"_id":"public/lib/Han/dist/han.min.js","hash":"f559c68a25065a14f47da954a7617d87263e409d","modified":1577091190594},{"_id":"public/lib/fancybox/source/jquery.fancybox.pack.js","hash":"53360764b429c212f424399384417ccc233bb3be","modified":1577091190580},{"_id":"public/lib/fancybox/source/jquery.fancybox.js","hash":"1cf3d47b5ccb7cb6e9019c64f2a88d03a64853e4","modified":1577091190600},{"_id":"public/lib/fastclick/lib/fastclick.js","hash":"06cef196733a710e77ad7e386ced6963f092dc55","modified":1577091190585},{"_id":"public/lib/font-awesome/css/font-awesome.css","hash":"0140952c64e3f2b74ef64e050f2fe86eab6624c8","modified":1577091190594},{"_id":"public/lib/font-awesome/css/font-awesome.min.css","hash":"512c7d79033e3028a9be61b540cf1a6870c896f8","modified":1577091190585},{"_id":"public/lib/Han/dist/han.js","hash":"e345397e0585c9fed1449e614ec13e0224acf2ab","modified":1577091190617},{"_id":"public/lib/velocity/velocity.js","hash":"9f08181baea0cc0e906703b7e5df9111b9ef3373","modified":1577091190622},{"_id":"public/lib/algolia-instant-search/instantsearch.min.js","hash":"9ccc6f8144f54e86df9a3fd33a18368d81cf3a4f","modified":1577091190632},{"_id":"public/lib/three/three.min.js","hash":"73f4cdc17e51a72b9bf5b9291f65386d615c483b","modified":1577091190635},{"_id":"public/lib/font-awesome/fonts/FontAwesome.otf","hash":"048707bc52ac4b6563aaa383bfe8660a0ddc908c","modified":1577091190566},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.eot","hash":"d980c2ce873dc43af460d4d572d441304499f400","modified":1577091190566},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.ttf","hash":"13b1eab65a983c7a73bc7997c479d66943f7c6cb","modified":1577091190566},{"_id":"public/assets/algolia/algoliasearch.js","hash":"b8da98df4cb4a8f6059a956a7a4a19f1ae4f3fe3","modified":1577091190567},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.svg","hash":"98a8aa5cf7d62c2eff5f07ede8d844b874ef06ed","modified":1577091190594},{"_id":"source/_posts/js数组排序和算法排序.md","hash":"3ddaaeb9139b2b266c5243c9e0ae3651ec4fc5ad","modified":1577254074676},{"_id":"public/archives/page/2/index.html","hash":"5a29ff8886e7ab49d8458fc5070528e26f822e87","modified":1633939146666},{"_id":"public/archives/2019/index.html","hash":"3658494a39c0452833f5a73908c77bbca0f012e5","modified":1633939146665},{"_id":"public/archives/2019/06/index.html","hash":"cf65d04f1be2d4ae416ef51ca1b5b4dbae905b97","modified":1633939146670},{"_id":"public/page/2/index.html","hash":"6b8b6ede9f1b21be85728071cee52d7446a5cf99","modified":1633939146671},{"_id":"public/tags/排序/index.html","hash":"63a11bb03edb0a3f811678ab37419765b30bf307","modified":1633939146670},{"_id":"public/2019/06/12/js数组排序和算法排序/index.html","hash":"bc3f27f71e601063a4a9da3c5cf35018f7507db6","modified":1577244656153},{"_id":"source/_posts/3分钟了解BFC.md","hash":"6e8c685f5a60611825e73d015e4274499161f84e","modified":1577254112280},{"_id":"source/_posts/Hook.md","hash":"989684fa9c666fe57e9d6676183922469da5ceb0","modified":1577253910855},{"_id":"source/_posts/diff.md","hash":"00a730faf1c79066db522661db26c219fa747de5","modified":1577244850428},{"_id":"public/archives/2018/07/index.html","hash":"b737f1552b210c81f4c7f3bb1d723ca0437cfe7b","modified":1633939146665},{"_id":"public/archives/2019/03/index.html","hash":"4c9702e3dcaf0239c109a283b8277131b66603f2","modified":1633939146665},{"_id":"public/archives/2019/07/index.html","hash":"c8268a5155078023ad3486958f1a26d8ecce531d","modified":1577244439575},{"_id":"public/tags/bfc/index.html","hash":"da87d59f2caf1d08143db26233119d4c6cf84b41","modified":1633939146670},{"_id":"public/tags/算法-diff/index.html","hash":"2461806203a7ca8389e59a554dec64735642bc12","modified":1577244656153},{"_id":"public/2019/07/12/Hook/index.html","hash":"b0b7ea3086b901bb3d5bcb1f3634f9fca8b8f22f","modified":1577244439575},{"_id":"public/2019/03/10/diff/index.html","hash":"83470c42d94868c50b3e916dc1d67ff0926899bd","modified":1633939146665},{"_id":"public/2018/07/11/3分钟了解BFC/index.html","hash":"2fda6a18c86ee59f41caf6692a165300ea23b139","modified":1633939146665},{"_id":"public/tags/hook/index.html","hash":"a2e7bb423da2c36a9d522d3c3214a26fcb7ac5e8","modified":1633939146670},{"_id":"public/2019/06/10/Hook/index.html","hash":"089e4f50db7aecb95787645b5f178c49d620f0cd","modified":1633939146665},{"_id":"public/2019/04/12/js数组排序和算法排序/index.html","hash":"b46eeef81e1051ec3c0664fac250e48a4df9d709","modified":1633939146665},{"_id":"public/2017/05/18/js-Array-indexOf方法/index.html","hash":"64081cd93a96c39ff86ff812dab53b4b86f2cda3","modified":1633939146666},{"_id":"public/archives/2017/05/index.html","hash":"6a7d3cf9a1bc0bfe4e299d04f57cc441887dc30b","modified":1633939146664},{"_id":"public/archives/2019/04/index.html","hash":"fa1af55f7f5809e8d00e052db3474014962d20c5","modified":1633939146665},{"_id":"public/tags/算法/index.html","hash":"5a1af012b6faa278edb15dbff84bc81162808a6a","modified":1633939146670},{"_id":"themes/Next/.DS_Store","hash":"df2fbeb1400acda0909a32c1cf6bf492f1121e07","modified":1586225836379},{"_id":"source/_posts/DFS和BFS.md","hash":"e69efa437e6b4d26843e19b775b07b0584ae9a52","modified":1586335670472},{"_id":"public/archives/2020/index.html","hash":"c85906135869b1a8fcc5dfb29879f614081fd1b3","modified":1633939146671},{"_id":"public/archives/2020/04/index.html","hash":"ecf25ae8a74ee42c51f6aacf50b75fe43cad9dba","modified":1633939146670},{"_id":"public/tags/dfs-bfs/index.html","hash":"bb76422633ede3dcc6728f5dd647e002e7c49123","modified":1586335486012},{"_id":"public/2020/04/08/DFS和BFS/index.html","hash":"848a0bcc971349165962388c000245f7160c1f25","modified":1633939146665},{"_id":"public/tags/bfs/index.html","hash":"0490dec502f073598cf7afca5be02f5f873b58d1","modified":1633939146670},{"_id":"public/tags/dfs/index.html","hash":"a7c24ec5b85a6f8710369abe40f5d859819bc812","modified":1633939146670},{"_id":"source/_posts/JavaScript 中的位运算和权限设计.md","hash":"22d7066bd496aead860cb6e7f12feb1f052152ed","modified":1589524084632},{"_id":"source/_posts/回流和重绘.md","hash":"c0de5b9b28a88be34fcecddff3fdab34aa7483d5","modified":1589522695232},{"_id":"public/categories/技术分享/page/2/index.html","hash":"45ff1851d236a66d40bb9caa83a9467ed2b6fca7","modified":1633939146664},{"_id":"public/archives/2020/03/index.html","hash":"890a7c7797d44133068c4e69d3781079a1c48f89","modified":1633939146670},{"_id":"public/tags/浏览器渲染/index.html","hash":"60fc36b53e165133e66eae754292607d2f1a8b73","modified":1633939146670},{"_id":"public/2020/04/12/JavaScript 中的位运算和权限设计/index.html","hash":"22a9e28296f3f3a0479fb708de24f9e0a1ec8a52","modified":1633939146665},{"_id":"public/2020/03/11/回流和重绘/index.html","hash":"e0c675c26a7fe5ef3e98aeac4539c385079ddb12","modified":1633939146665},{"_id":"source/_posts/Composition API.md","hash":"72d3853b4cf67e102e7695a73eb893143e8dabc9","modified":1599189308600},{"_id":"public/2018/07/11/Composition API/index.html","hash":"3af76441231e2a40ce6e3b80c728349c525882d0","modified":1599189097409},{"_id":"public/archives/2020/09/index.html","hash":"a1ff511ea8e92f19c0f6c620a9dc8874d9855b69","modified":1633939146670},{"_id":"public/tags/vue3/index.html","hash":"d3b58b1d2c6306f472244da53920cb24aaaf8891","modified":1633939146670},{"_id":"public/2020/09/01/Composition API/index.html","hash":"7d4f228c6c981a97588c153de39b45f3a6b3bde3","modified":1633939146665}],"Category":[{"name":"技术分享","_id":"cjhbjw6qc0004fx9m3uwjnf91"},{"name":"面试题","_id":"cjhbjw6qo000efx9m5friox20"},{"name":"vue","parent":"cjhbjw6qo000efx9m5friox20","_id":"cjhbjw6qv000vfx9ma61rlopx"},{"name":"react","parent":"cjhbjw6qv000vfx9ma61rlopx","_id":"cjhbjw6qx0017fx9matm0pqpk"}],"Data":[],"Page":[{"title":"关于我","date":"2018-05-03T07:05:15.000Z","_content":" <img src=\"http://leqikeji.cn/myImgs/title.jpg\" width = \"200\" height = \"200\" style=\"border-radius: 50%;margin-top:25px\"/>\n<div style=\"width:300px;margin:0 auto\">\n     **name:** 解翔宇\n\n     **email:** [stevenDxxy@163.com](mailto:stevenDxxy@163.com)\n\n     **github:** [https://github.com/experor-xxy](https://github.com/experor-xxy)\n\n     **weibo:** [奶茶依旧y](https://weibo.com/u/3182373863/home)\n</div>\n","source":"about/index.md","raw":"---\ntitle: 关于我\ndate: 2018-05-03 15:05:15\n---\n <img src=\"http://leqikeji.cn/myImgs/title.jpg\" width = \"200\" height = \"200\" style=\"border-radius: 50%;margin-top:25px\"/>\n<div style=\"width:300px;margin:0 auto\">\n     **name:** 解翔宇\n\n     **email:** [stevenDxxy@163.com](mailto:stevenDxxy@163.com)\n\n     **github:** [https://github.com/experor-xxy](https://github.com/experor-xxy)\n\n     **weibo:** [奶茶依旧y](https://weibo.com/u/3182373863/home)\n</div>\n","updated":"2018-05-04T10:10:23.600Z","path":"about/index.html","comments":1,"layout":"page","_id":"cjhbjw6q80001fx9mmyoejvzh","content":"<p> <img src=\"http://leqikeji.cn/myImgs/title.jpg\" width=\"200\" height=\"200\" style=\"border-radius: 50%;margin-top:25px\"></p>\n<div style=\"width:300px;margin:0 auto\"><br>     <strong>name:</strong> 解翔宇<br><br>     <strong>email:</strong> <a href=\"mailto:stevenDxxy@163.com\" target=\"_blank\" rel=\"noopener\">stevenDxxy@163.com</a><br><br>     <strong>github:</strong> <a href=\"https://github.com/experor-xxy\" target=\"_blank\" rel=\"noopener\">https://github.com/experor-xxy</a><br><br>     <strong>weibo:</strong> <a href=\"https://weibo.com/u/3182373863/home\" target=\"_blank\" rel=\"noopener\">奶茶依旧y</a><br></div>\n","site":{"data":{}},"excerpt":"","more":"<p> <img src=\"http://leqikeji.cn/myImgs/title.jpg\" width=\"200\" height=\"200\" style=\"border-radius: 50%;margin-top:25px\"></p>\n<div style=\"width:300px;margin:0 auto\"><br>     <strong>name:</strong> 解翔宇<br><br>     <strong>email:</strong> <a href=\"mailto:stevenDxxy@163.com\" target=\"_blank\" rel=\"noopener\">stevenDxxy@163.com</a><br><br>     <strong>github:</strong> <a href=\"https://github.com/experor-xxy\" target=\"_blank\" rel=\"noopener\">https://github.com/experor-xxy</a><br><br>     <strong>weibo:</strong> <a href=\"https://weibo.com/u/3182373863/home\" target=\"_blank\" rel=\"noopener\">奶茶依旧y</a><br></div>\n"},{"title":"分类","date":"2018-05-04T07:38:26.000Z","type":"categories","_content":"","source":"categories/index.md","raw":"---\ntitle: 分类\ndate: 2018-05-04 15:38:26\ntype: \"categories\"\n---\n","updated":"2018-05-04T07:39:05.632Z","path":"categories/index.html","comments":1,"layout":"page","_id":"cjhbjw6qb0003fx9m58qr841i","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"标签","date":"2018-05-04T06:58:01.000Z","type":"tags","_content":"","source":"tags/index.md","raw":"---\ntitle: 标签\ndate: 2018-05-04 14:58:01\ntype: \"tags\"\n---\n","updated":"2018-05-04T07:37:38.860Z","path":"tags/index.html","comments":1,"layout":"page","_id":"cjhbjw6vn001kfx9mu0sm5g3i","content":"","site":{"data":{}},"excerpt":"","more":""}],"Post":[{"title":"Git基本操作","id":"840","date":"2017-11-07T14:38:50.000Z","_content":"\n#### 版本移动\n\n回退到上个版本\n\n> git reset --hard HEAD^\n\n前进到之后版本（可以找到commit id）\n\n> git reset --hard [commit id ]\n\n前进到之后版本（找不到commit id）\n\n> git reflog\n>   git reset --hard [commit id ]\n\n<!-- more -->\n\n#### 撤销更改\n\n未保存至暂存区或恢复到暂存区时的状态\n\n> git checkout -- [file]\n\n已保存至暂存区\n\n> git reset HEAD [file] (取消暂存区存储)\n>   git checkout [file]\n\n#### 删除文件\n\n从版本库中删除文件\n\n> git rm [file]\n>   git commit -m \"remove file\"\n\n找回文件\n\n> git checkout -- [file]\n\n#### 分支操作\n\n创建分支\n\n> git checkout -b [branch name]\n>   或\n>   git branch [branch name]\n>   git checkout [branch name]\n\n查看分支\n\n> git branch\n\n切换分支\n\n> git checkout [branch name]\n\n合并分支\n\n> git merge [branch name]\n\n删除分支\n\n> git branch -d [branch name]","source":"_posts/git-usage.md","raw":"---\ntitle: Git基本操作\ntags:\n  - git\nid: 840\ncategories:\n  - 技术分享\ndate: 2017-11-07 22:38:50\n---\n\n#### 版本移动\n\n回退到上个版本\n\n> git reset --hard HEAD^\n\n前进到之后版本（可以找到commit id）\n\n> git reset --hard [commit id ]\n\n前进到之后版本（找不到commit id）\n\n> git reflog\n>   git reset --hard [commit id ]\n\n<!-- more -->\n\n#### 撤销更改\n\n未保存至暂存区或恢复到暂存区时的状态\n\n> git checkout -- [file]\n\n已保存至暂存区\n\n> git reset HEAD [file] (取消暂存区存储)\n>   git checkout [file]\n\n#### 删除文件\n\n从版本库中删除文件\n\n> git rm [file]\n>   git commit -m \"remove file\"\n\n找回文件\n\n> git checkout -- [file]\n\n#### 分支操作\n\n创建分支\n\n> git checkout -b [branch name]\n>   或\n>   git branch [branch name]\n>   git checkout [branch name]\n\n查看分支\n\n> git branch\n\n切换分支\n\n> git checkout [branch name]\n\n合并分支\n\n> git merge [branch name]\n\n删除分支\n\n> git branch -d [branch name]","slug":"git-usage","published":1,"updated":"2018-05-03T11:23:18.845Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjhbjw6q20000fx9mikq9aoto","content":"<h4 id=\"版本移动\"><a href=\"#版本移动\" class=\"headerlink\" title=\"版本移动\"></a>版本移动</h4><p>回退到上个版本</p>\n<blockquote>\n<p>git reset –hard HEAD^</p>\n</blockquote>\n<p>前进到之后版本（可以找到commit id）</p>\n<blockquote>\n<p>git reset –hard [commit id ]</p>\n</blockquote>\n<p>前进到之后版本（找不到commit id）</p>\n<blockquote>\n<p>git reflog<br>  git reset –hard [commit id ]</p>\n</blockquote>\n<a id=\"more\"></a>\n<h4 id=\"撤销更改\"><a href=\"#撤销更改\" class=\"headerlink\" title=\"撤销更改\"></a>撤销更改</h4><p>未保存至暂存区或恢复到暂存区时的状态</p>\n<blockquote>\n<p>git checkout – [file]</p>\n</blockquote>\n<p>已保存至暂存区</p>\n<blockquote>\n<p>git reset HEAD [file] (取消暂存区存储)<br>  git checkout [file]</p>\n</blockquote>\n<h4 id=\"删除文件\"><a href=\"#删除文件\" class=\"headerlink\" title=\"删除文件\"></a>删除文件</h4><p>从版本库中删除文件</p>\n<blockquote>\n<p>git rm [file]<br>  git commit -m “remove file”</p>\n</blockquote>\n<p>找回文件</p>\n<blockquote>\n<p>git checkout – [file]</p>\n</blockquote>\n<h4 id=\"分支操作\"><a href=\"#分支操作\" class=\"headerlink\" title=\"分支操作\"></a>分支操作</h4><p>创建分支</p>\n<blockquote>\n<p>git checkout -b [branch name]<br>  或<br>  git branch [branch name]<br>  git checkout [branch name]</p>\n</blockquote>\n<p>查看分支</p>\n<blockquote>\n<p>git branch</p>\n</blockquote>\n<p>切换分支</p>\n<blockquote>\n<p>git checkout [branch name]</p>\n</blockquote>\n<p>合并分支</p>\n<blockquote>\n<p>git merge [branch name]</p>\n</blockquote>\n<p>删除分支</p>\n<blockquote>\n<p>git branch -d [branch name]</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"<h4 id=\"版本移动\"><a href=\"#版本移动\" class=\"headerlink\" title=\"版本移动\"></a>版本移动</h4><p>回退到上个版本</p>\n<blockquote>\n<p>git reset –hard HEAD^</p>\n</blockquote>\n<p>前进到之后版本（可以找到commit id）</p>\n<blockquote>\n<p>git reset –hard [commit id ]</p>\n</blockquote>\n<p>前进到之后版本（找不到commit id）</p>\n<blockquote>\n<p>git reflog<br>  git reset –hard [commit id ]</p>\n</blockquote>","more":"<h4 id=\"撤销更改\"><a href=\"#撤销更改\" class=\"headerlink\" title=\"撤销更改\"></a>撤销更改</h4><p>未保存至暂存区或恢复到暂存区时的状态</p>\n<blockquote>\n<p>git checkout – [file]</p>\n</blockquote>\n<p>已保存至暂存区</p>\n<blockquote>\n<p>git reset HEAD [file] (取消暂存区存储)<br>  git checkout [file]</p>\n</blockquote>\n<h4 id=\"删除文件\"><a href=\"#删除文件\" class=\"headerlink\" title=\"删除文件\"></a>删除文件</h4><p>从版本库中删除文件</p>\n<blockquote>\n<p>git rm [file]<br>  git commit -m “remove file”</p>\n</blockquote>\n<p>找回文件</p>\n<blockquote>\n<p>git checkout – [file]</p>\n</blockquote>\n<h4 id=\"分支操作\"><a href=\"#分支操作\" class=\"headerlink\" title=\"分支操作\"></a>分支操作</h4><p>创建分支</p>\n<blockquote>\n<p>git checkout -b [branch name]<br>  或<br>  git branch [branch name]<br>  git checkout [branch name]</p>\n</blockquote>\n<p>查看分支</p>\n<blockquote>\n<p>git branch</p>\n</blockquote>\n<p>切换分支</p>\n<blockquote>\n<p>git checkout [branch name]</p>\n</blockquote>\n<p>合并分支</p>\n<blockquote>\n<p>git merge [branch name]</p>\n</blockquote>\n<p>删除分支</p>\n<blockquote>\n<p>git branch -d [branch name]</p>\n</blockquote>"},{"title":"好用的Web包管理器-Bower","date":"2017-12-03T08:38:54.000Z","_content":"Bower是twitter推出的客户端包管理工具，用于命令行操作包的搜索、下载、更新、卸载(如jQuery、Bootstrap、JavaScript、HTML、CSS之类的网络资源)。Bower对包结构没有强制规范，可以很方便获取各种Web模块文件，但bower本身不存储模块文件和模块版本信息，模块发布者通过register方式将模块可访问的公开的git地址记录在bower的数据库中，而所有版本都是通过代码库的tag来决定的。\n\n<!-- more -->\n## 开始之前\n在安装[bower](https://bower.io/)之前，必须确认你已经安装了[Node.js](https://nodejs.org/en/)和[Git](https://git-scm.com/)。\n\n### 1.安装Bower\n使用npm，打开终端，键入：\n``` python\n    npm install -g bower   #全局安装bower\n```\n移步[这里](https://github.com/bower/bower/wiki/Troubleshooting)查看不同平台上安装的问题。\n\n### 2.使用Bower\n使用help命令查看帮助。\n``` bash\n    bower help\n    Usage:\n        bower <command> [<args>] [<options>]\n    Commands:\n        cache                   Manage bower cache\n        help                    Display help information about Bower\n        home                    Opens a package homepage into your favorite browser\n        info                    Info of a particular package\n        init                    Interactively create a bower.json file\n        install                 Install a package locally\n        link                    Symlink a package folder\n        list                    List local packages - and possible updates\n        login                   Authenticate with GitHub and store credentials\n        lookup                  Look up a package URL by name\n        prune                   Removes local extraneous packages\n        register                Register a package\n        search                  Search for a package by name\n        update                  Update a local package\n        uninstall               Remove a local package\n        unregister              Remove a package from the registry\n        version                 Bump a package version\n    Options:\n        -f, --force             Makes various commands more forceful\n        -j, --json              Output consumable JSON\n        -l, --loglevel          What level of logs to report\n        -o, --offline           Do not hit the network\n        -q, --quiet             Only output important information\n        -s, --silent            Do not output anything, besides errors\n        -V, --verbose           Makes output more verbose\n        --allow-root            Allows running commands as root\n        -v, --version           Output Bower version\n        --no-color              Disable colors\n    See 'bower help <command>' for more information on a specific command.\n```\n\n### 3.安装包到本地\n通过命令bower install安装软件包默认到bower_components/目录。\n``` bash\n    bower install <package>    #package为包名\n```\n想要下载的包可以是GitHub上的短链接（如jquery/jquery）、.git 、一个URL或者其它。\n\n``` bash\nbower install  # 通过 bower.json 文件安装\nbower install jquery   # 通过在github上注册的包名安装\nbower install desandro/masonry   # GitHub短链接\nbower install git://github.com/user/package.git   # Github上的 .git\nbower install http://example.com/script.js   # URL\n```\n\n安装选项\n``` bash\n-F, --force-latest: Force latest version on conflict\n-p, --production: Do not install project devDependencies\n-S, --save: Save installed packages into the project’s bower.json dependencies\n-D, --save-dev: Save installed packages into the project’s bower.json devDependencies\n-E, --save-exact: Configure installed packages with an exact version rather than semver\n```\n\n### 4.用bower.json文件来管理依赖\n发布项目的时候没有必要把所有依赖的库发布上去，只需在根目录生成一个bower.json文件即可，别人使用时在根目录执行bower install就可根据bower.json来安装依赖的包。\n在项目中执行\n``` bash\nbower init\n```\n会提示你输入一些基本信息，根据提示按回车或者空格即可，然后会生成一个bower.json文件，用来保存该项目的配置.\n如果想保存依赖信息(dependencies)到你的bower.json文件，安装包时，命令后面跟上--save即可。\n\n### 5.使用下载好的包\n对于已经下载下来的包，默认在当前目录的bower_components文件夹。你可以直接在项目里引用。例如：\n\n``` bash\n<link rel=\"stylesheet\" href=\"bower_components/bootstrap/dist/css/bootstrap.min.css\">\n<script type=\"text/javascript\" src=\"bower_components/jquery/dist/jquery.min.js\"></script>\n```\n\n### 6.更新包\n若下载的包升级了，只需执行update命令即可更新，例如：\n``` bash\nbower update jquery\n```\n这样就可以自动升级到最新版的jquery了。\n更新选项\n\n``` bash\n-F, --force-latest: Force latest version on conflict\n-p, --production: Do not install project devDependencies\n-S, --save: Update dependencies in bower.json\n-D, --save-dev: Update devDependencies in bower.json\n```\n\n### 7.搜索包\n``` bash\nbower search               #搜索所有包\nbower search <packageName> #搜索指定名称的包\n```\n或者可以在[这里](https://bower.io/search/)搜索喜欢的包.\n\n### 8.卸载包\n``` bash\nbower uninstall <name> [<name> ..] [<options>]\n```\n卸载选项\n``` bash\n-S, --save: Remove uninstalled packages from the project’s bower.json dependencies\n-D, --save-dev: Remove uninstalled packages from the project’s bower.json devDependencies\n```","source":"_posts/Bower.md","raw":"---\ntitle: 好用的Web包管理器-Bower\ndate: 2017-12-03 16:38:54\ntags:\n    - Bower\n---\nBower是twitter推出的客户端包管理工具，用于命令行操作包的搜索、下载、更新、卸载(如jQuery、Bootstrap、JavaScript、HTML、CSS之类的网络资源)。Bower对包结构没有强制规范，可以很方便获取各种Web模块文件，但bower本身不存储模块文件和模块版本信息，模块发布者通过register方式将模块可访问的公开的git地址记录在bower的数据库中，而所有版本都是通过代码库的tag来决定的。\n\n<!-- more -->\n## 开始之前\n在安装[bower](https://bower.io/)之前，必须确认你已经安装了[Node.js](https://nodejs.org/en/)和[Git](https://git-scm.com/)。\n\n### 1.安装Bower\n使用npm，打开终端，键入：\n``` python\n    npm install -g bower   #全局安装bower\n```\n移步[这里](https://github.com/bower/bower/wiki/Troubleshooting)查看不同平台上安装的问题。\n\n### 2.使用Bower\n使用help命令查看帮助。\n``` bash\n    bower help\n    Usage:\n        bower <command> [<args>] [<options>]\n    Commands:\n        cache                   Manage bower cache\n        help                    Display help information about Bower\n        home                    Opens a package homepage into your favorite browser\n        info                    Info of a particular package\n        init                    Interactively create a bower.json file\n        install                 Install a package locally\n        link                    Symlink a package folder\n        list                    List local packages - and possible updates\n        login                   Authenticate with GitHub and store credentials\n        lookup                  Look up a package URL by name\n        prune                   Removes local extraneous packages\n        register                Register a package\n        search                  Search for a package by name\n        update                  Update a local package\n        uninstall               Remove a local package\n        unregister              Remove a package from the registry\n        version                 Bump a package version\n    Options:\n        -f, --force             Makes various commands more forceful\n        -j, --json              Output consumable JSON\n        -l, --loglevel          What level of logs to report\n        -o, --offline           Do not hit the network\n        -q, --quiet             Only output important information\n        -s, --silent            Do not output anything, besides errors\n        -V, --verbose           Makes output more verbose\n        --allow-root            Allows running commands as root\n        -v, --version           Output Bower version\n        --no-color              Disable colors\n    See 'bower help <command>' for more information on a specific command.\n```\n\n### 3.安装包到本地\n通过命令bower install安装软件包默认到bower_components/目录。\n``` bash\n    bower install <package>    #package为包名\n```\n想要下载的包可以是GitHub上的短链接（如jquery/jquery）、.git 、一个URL或者其它。\n\n``` bash\nbower install  # 通过 bower.json 文件安装\nbower install jquery   # 通过在github上注册的包名安装\nbower install desandro/masonry   # GitHub短链接\nbower install git://github.com/user/package.git   # Github上的 .git\nbower install http://example.com/script.js   # URL\n```\n\n安装选项\n``` bash\n-F, --force-latest: Force latest version on conflict\n-p, --production: Do not install project devDependencies\n-S, --save: Save installed packages into the project’s bower.json dependencies\n-D, --save-dev: Save installed packages into the project’s bower.json devDependencies\n-E, --save-exact: Configure installed packages with an exact version rather than semver\n```\n\n### 4.用bower.json文件来管理依赖\n发布项目的时候没有必要把所有依赖的库发布上去，只需在根目录生成一个bower.json文件即可，别人使用时在根目录执行bower install就可根据bower.json来安装依赖的包。\n在项目中执行\n``` bash\nbower init\n```\n会提示你输入一些基本信息，根据提示按回车或者空格即可，然后会生成一个bower.json文件，用来保存该项目的配置.\n如果想保存依赖信息(dependencies)到你的bower.json文件，安装包时，命令后面跟上--save即可。\n\n### 5.使用下载好的包\n对于已经下载下来的包，默认在当前目录的bower_components文件夹。你可以直接在项目里引用。例如：\n\n``` bash\n<link rel=\"stylesheet\" href=\"bower_components/bootstrap/dist/css/bootstrap.min.css\">\n<script type=\"text/javascript\" src=\"bower_components/jquery/dist/jquery.min.js\"></script>\n```\n\n### 6.更新包\n若下载的包升级了，只需执行update命令即可更新，例如：\n``` bash\nbower update jquery\n```\n这样就可以自动升级到最新版的jquery了。\n更新选项\n\n``` bash\n-F, --force-latest: Force latest version on conflict\n-p, --production: Do not install project devDependencies\n-S, --save: Update dependencies in bower.json\n-D, --save-dev: Update devDependencies in bower.json\n```\n\n### 7.搜索包\n``` bash\nbower search               #搜索所有包\nbower search <packageName> #搜索指定名称的包\n```\n或者可以在[这里](https://bower.io/search/)搜索喜欢的包.\n\n### 8.卸载包\n``` bash\nbower uninstall <name> [<name> ..] [<options>]\n```\n卸载选项\n``` bash\n-S, --save: Remove uninstalled packages from the project’s bower.json dependencies\n-D, --save-dev: Remove uninstalled packages from the project’s bower.json devDependencies\n```","slug":"Bower","published":1,"updated":"2018-05-08T02:58:41.241Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjhbjw6q90002fx9m5pxe6tan","content":"<p>Bower是twitter推出的客户端包管理工具，用于命令行操作包的搜索、下载、更新、卸载(如jQuery、Bootstrap、JavaScript、HTML、CSS之类的网络资源)。Bower对包结构没有强制规范，可以很方便获取各种Web模块文件，但bower本身不存储模块文件和模块版本信息，模块发布者通过register方式将模块可访问的公开的git地址记录在bower的数据库中，而所有版本都是通过代码库的tag来决定的。</p>\n<a id=\"more\"></a>\n<h2 id=\"开始之前\"><a href=\"#开始之前\" class=\"headerlink\" title=\"开始之前\"></a>开始之前</h2><p>在安装<a href=\"https://bower.io/\" target=\"_blank\" rel=\"noopener\">bower</a>之前，必须确认你已经安装了<a href=\"https://nodejs.org/en/\" target=\"_blank\" rel=\"noopener\">Node.js</a>和<a href=\"https://git-scm.com/\" target=\"_blank\" rel=\"noopener\">Git</a>。</p>\n<h3 id=\"1-安装Bower\"><a href=\"#1-安装Bower\" class=\"headerlink\" title=\"1.安装Bower\"></a>1.安装Bower</h3><p>使用npm，打开终端，键入：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install -g bower   <span class=\"comment\">#全局安装bower</span></span><br></pre></td></tr></table></figure></p>\n<p>移步<a href=\"https://github.com/bower/bower/wiki/Troubleshooting\" target=\"_blank\" rel=\"noopener\">这里</a>查看不同平台上安装的问题。</p>\n<h3 id=\"2-使用Bower\"><a href=\"#2-使用Bower\" class=\"headerlink\" title=\"2.使用Bower\"></a>2.使用Bower</h3><p>使用help命令查看帮助。<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">bower <span class=\"built_in\">help</span></span><br><span class=\"line\">Usage:</span><br><span class=\"line\">    bower &lt;<span class=\"built_in\">command</span>&gt; [&lt;args&gt;] [&lt;options&gt;]</span><br><span class=\"line\">Commands:</span><br><span class=\"line\">    cache                   Manage bower cache</span><br><span class=\"line\">    <span class=\"built_in\">help</span>                    Display <span class=\"built_in\">help</span> information about Bower</span><br><span class=\"line\">    home                    Opens a package homepage into your favorite browser</span><br><span class=\"line\">    info                    Info of a particular package</span><br><span class=\"line\">    init                    Interactively create a bower.json file</span><br><span class=\"line\">    install                 Install a package locally</span><br><span class=\"line\">    link                    Symlink a package folder</span><br><span class=\"line\">    list                    List <span class=\"built_in\">local</span> packages - and possible updates</span><br><span class=\"line\">    login                   Authenticate with GitHub and store credentials</span><br><span class=\"line\">    lookup                  Look up a package URL by name</span><br><span class=\"line\">    prune                   Removes <span class=\"built_in\">local</span> extraneous packages</span><br><span class=\"line\">    register                Register a package</span><br><span class=\"line\">    search                  Search <span class=\"keyword\">for</span> a package by name</span><br><span class=\"line\">    update                  Update a <span class=\"built_in\">local</span> package</span><br><span class=\"line\">    uninstall               Remove a <span class=\"built_in\">local</span> package</span><br><span class=\"line\">    unregister              Remove a package from the registry</span><br><span class=\"line\">    version                 Bump a package version</span><br><span class=\"line\">Options:</span><br><span class=\"line\">    -f, --force             Makes various commands more forceful</span><br><span class=\"line\">    -j, --json              Output consumable JSON</span><br><span class=\"line\">    -l, --loglevel          What level of logs to report</span><br><span class=\"line\">    -o, --offline           Do not hit the network</span><br><span class=\"line\">    -q, --quiet             Only output important information</span><br><span class=\"line\">    -s, --silent            Do not output anything, besides errors</span><br><span class=\"line\">    -V, --verbose           Makes output more verbose</span><br><span class=\"line\">    --allow-root            Allows running commands as root</span><br><span class=\"line\">    -v, --version           Output Bower version</span><br><span class=\"line\">    --no-color              Disable colors</span><br><span class=\"line\">See <span class=\"string\">'bower help &lt;command&gt;'</span> <span class=\"keyword\">for</span> more information on a specific <span class=\"built_in\">command</span>.</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"3-安装包到本地\"><a href=\"#3-安装包到本地\" class=\"headerlink\" title=\"3.安装包到本地\"></a>3.安装包到本地</h3><p>通过命令bower install安装软件包默认到bower_components/目录。<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">bower install &lt;package&gt;    <span class=\"comment\">#package为包名</span></span><br></pre></td></tr></table></figure></p>\n<p>想要下载的包可以是GitHub上的短链接（如jquery/jquery）、.git 、一个URL或者其它。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">bower install  <span class=\"comment\"># 通过 bower.json 文件安装</span></span><br><span class=\"line\">bower install jquery   <span class=\"comment\"># 通过在github上注册的包名安装</span></span><br><span class=\"line\">bower install desandro/masonry   <span class=\"comment\"># GitHub短链接</span></span><br><span class=\"line\">bower install git://github.com/user/package.git   <span class=\"comment\"># Github上的 .git</span></span><br><span class=\"line\">bower install http://example.com/script.js   <span class=\"comment\"># URL</span></span><br></pre></td></tr></table></figure>\n<p>安装选项<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-F, --force-latest: Force latest version on conflict</span><br><span class=\"line\">-p, --production: Do not install project devDependencies</span><br><span class=\"line\">-S, --save: Save installed packages into the project’s bower.json dependencies</span><br><span class=\"line\">-D, --save-dev: Save installed packages into the project’s bower.json devDependencies</span><br><span class=\"line\">-E, --save-exact: Configure installed packages with an exact version rather than semver</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"4-用bower-json文件来管理依赖\"><a href=\"#4-用bower-json文件来管理依赖\" class=\"headerlink\" title=\"4.用bower.json文件来管理依赖\"></a>4.用bower.json文件来管理依赖</h3><p>发布项目的时候没有必要把所有依赖的库发布上去，只需在根目录生成一个bower.json文件即可，别人使用时在根目录执行bower install就可根据bower.json来安装依赖的包。<br>在项目中执行<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">bower init</span><br></pre></td></tr></table></figure></p>\n<p>会提示你输入一些基本信息，根据提示按回车或者空格即可，然后会生成一个bower.json文件，用来保存该项目的配置.<br>如果想保存依赖信息(dependencies)到你的bower.json文件，安装包时，命令后面跟上–save即可。</p>\n<h3 id=\"5-使用下载好的包\"><a href=\"#5-使用下载好的包\" class=\"headerlink\" title=\"5.使用下载好的包\"></a>5.使用下载好的包</h3><p>对于已经下载下来的包，默认在当前目录的bower_components文件夹。你可以直接在项目里引用。例如：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;link rel=<span class=\"string\">\"stylesheet\"</span> href=<span class=\"string\">\"bower_components/bootstrap/dist/css/bootstrap.min.css\"</span>&gt;</span><br><span class=\"line\">&lt;script <span class=\"built_in\">type</span>=<span class=\"string\">\"text/javascript\"</span> src=<span class=\"string\">\"bower_components/jquery/dist/jquery.min.js\"</span>&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure>\n<h3 id=\"6-更新包\"><a href=\"#6-更新包\" class=\"headerlink\" title=\"6.更新包\"></a>6.更新包</h3><p>若下载的包升级了，只需执行update命令即可更新，例如：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">bower update jquery</span><br></pre></td></tr></table></figure></p>\n<p>这样就可以自动升级到最新版的jquery了。<br>更新选项</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-F, --force-latest: Force latest version on conflict</span><br><span class=\"line\">-p, --production: Do not install project devDependencies</span><br><span class=\"line\">-S, --save: Update dependencies <span class=\"keyword\">in</span> bower.json</span><br><span class=\"line\">-D, --save-dev: Update devDependencies <span class=\"keyword\">in</span> bower.json</span><br></pre></td></tr></table></figure>\n<h3 id=\"7-搜索包\"><a href=\"#7-搜索包\" class=\"headerlink\" title=\"7.搜索包\"></a>7.搜索包</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">bower search               <span class=\"comment\">#搜索所有包</span></span><br><span class=\"line\">bower search &lt;packageName&gt; <span class=\"comment\">#搜索指定名称的包</span></span><br></pre></td></tr></table></figure>\n<p>或者可以在<a href=\"https://bower.io/search/\" target=\"_blank\" rel=\"noopener\">这里</a>搜索喜欢的包.</p>\n<h3 id=\"8-卸载包\"><a href=\"#8-卸载包\" class=\"headerlink\" title=\"8.卸载包\"></a>8.卸载包</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">bower uninstall &lt;name&gt; [&lt;name&gt; ..] [&lt;options&gt;]</span><br></pre></td></tr></table></figure>\n<p>卸载选项<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-S, --save: Remove uninstalled packages from the project’s bower.json dependencies</span><br><span class=\"line\">-D, --save-dev: Remove uninstalled packages from the project’s bower.json devDependencies</span><br></pre></td></tr></table></figure></p>\n","site":{"data":{}},"excerpt":"<p>Bower是twitter推出的客户端包管理工具，用于命令行操作包的搜索、下载、更新、卸载(如jQuery、Bootstrap、JavaScript、HTML、CSS之类的网络资源)。Bower对包结构没有强制规范，可以很方便获取各种Web模块文件，但bower本身不存储模块文件和模块版本信息，模块发布者通过register方式将模块可访问的公开的git地址记录在bower的数据库中，而所有版本都是通过代码库的tag来决定的。</p>","more":"<h2 id=\"开始之前\"><a href=\"#开始之前\" class=\"headerlink\" title=\"开始之前\"></a>开始之前</h2><p>在安装<a href=\"https://bower.io/\" target=\"_blank\" rel=\"noopener\">bower</a>之前，必须确认你已经安装了<a href=\"https://nodejs.org/en/\" target=\"_blank\" rel=\"noopener\">Node.js</a>和<a href=\"https://git-scm.com/\" target=\"_blank\" rel=\"noopener\">Git</a>。</p>\n<h3 id=\"1-安装Bower\"><a href=\"#1-安装Bower\" class=\"headerlink\" title=\"1.安装Bower\"></a>1.安装Bower</h3><p>使用npm，打开终端，键入：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install -g bower   <span class=\"comment\">#全局安装bower</span></span><br></pre></td></tr></table></figure></p>\n<p>移步<a href=\"https://github.com/bower/bower/wiki/Troubleshooting\" target=\"_blank\" rel=\"noopener\">这里</a>查看不同平台上安装的问题。</p>\n<h3 id=\"2-使用Bower\"><a href=\"#2-使用Bower\" class=\"headerlink\" title=\"2.使用Bower\"></a>2.使用Bower</h3><p>使用help命令查看帮助。<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">bower <span class=\"built_in\">help</span></span><br><span class=\"line\">Usage:</span><br><span class=\"line\">    bower &lt;<span class=\"built_in\">command</span>&gt; [&lt;args&gt;] [&lt;options&gt;]</span><br><span class=\"line\">Commands:</span><br><span class=\"line\">    cache                   Manage bower cache</span><br><span class=\"line\">    <span class=\"built_in\">help</span>                    Display <span class=\"built_in\">help</span> information about Bower</span><br><span class=\"line\">    home                    Opens a package homepage into your favorite browser</span><br><span class=\"line\">    info                    Info of a particular package</span><br><span class=\"line\">    init                    Interactively create a bower.json file</span><br><span class=\"line\">    install                 Install a package locally</span><br><span class=\"line\">    link                    Symlink a package folder</span><br><span class=\"line\">    list                    List <span class=\"built_in\">local</span> packages - and possible updates</span><br><span class=\"line\">    login                   Authenticate with GitHub and store credentials</span><br><span class=\"line\">    lookup                  Look up a package URL by name</span><br><span class=\"line\">    prune                   Removes <span class=\"built_in\">local</span> extraneous packages</span><br><span class=\"line\">    register                Register a package</span><br><span class=\"line\">    search                  Search <span class=\"keyword\">for</span> a package by name</span><br><span class=\"line\">    update                  Update a <span class=\"built_in\">local</span> package</span><br><span class=\"line\">    uninstall               Remove a <span class=\"built_in\">local</span> package</span><br><span class=\"line\">    unregister              Remove a package from the registry</span><br><span class=\"line\">    version                 Bump a package version</span><br><span class=\"line\">Options:</span><br><span class=\"line\">    -f, --force             Makes various commands more forceful</span><br><span class=\"line\">    -j, --json              Output consumable JSON</span><br><span class=\"line\">    -l, --loglevel          What level of logs to report</span><br><span class=\"line\">    -o, --offline           Do not hit the network</span><br><span class=\"line\">    -q, --quiet             Only output important information</span><br><span class=\"line\">    -s, --silent            Do not output anything, besides errors</span><br><span class=\"line\">    -V, --verbose           Makes output more verbose</span><br><span class=\"line\">    --allow-root            Allows running commands as root</span><br><span class=\"line\">    -v, --version           Output Bower version</span><br><span class=\"line\">    --no-color              Disable colors</span><br><span class=\"line\">See <span class=\"string\">'bower help &lt;command&gt;'</span> <span class=\"keyword\">for</span> more information on a specific <span class=\"built_in\">command</span>.</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"3-安装包到本地\"><a href=\"#3-安装包到本地\" class=\"headerlink\" title=\"3.安装包到本地\"></a>3.安装包到本地</h3><p>通过命令bower install安装软件包默认到bower_components/目录。<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">bower install &lt;package&gt;    <span class=\"comment\">#package为包名</span></span><br></pre></td></tr></table></figure></p>\n<p>想要下载的包可以是GitHub上的短链接（如jquery/jquery）、.git 、一个URL或者其它。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">bower install  <span class=\"comment\"># 通过 bower.json 文件安装</span></span><br><span class=\"line\">bower install jquery   <span class=\"comment\"># 通过在github上注册的包名安装</span></span><br><span class=\"line\">bower install desandro/masonry   <span class=\"comment\"># GitHub短链接</span></span><br><span class=\"line\">bower install git://github.com/user/package.git   <span class=\"comment\"># Github上的 .git</span></span><br><span class=\"line\">bower install http://example.com/script.js   <span class=\"comment\"># URL</span></span><br></pre></td></tr></table></figure>\n<p>安装选项<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-F, --force-latest: Force latest version on conflict</span><br><span class=\"line\">-p, --production: Do not install project devDependencies</span><br><span class=\"line\">-S, --save: Save installed packages into the project’s bower.json dependencies</span><br><span class=\"line\">-D, --save-dev: Save installed packages into the project’s bower.json devDependencies</span><br><span class=\"line\">-E, --save-exact: Configure installed packages with an exact version rather than semver</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"4-用bower-json文件来管理依赖\"><a href=\"#4-用bower-json文件来管理依赖\" class=\"headerlink\" title=\"4.用bower.json文件来管理依赖\"></a>4.用bower.json文件来管理依赖</h3><p>发布项目的时候没有必要把所有依赖的库发布上去，只需在根目录生成一个bower.json文件即可，别人使用时在根目录执行bower install就可根据bower.json来安装依赖的包。<br>在项目中执行<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">bower init</span><br></pre></td></tr></table></figure></p>\n<p>会提示你输入一些基本信息，根据提示按回车或者空格即可，然后会生成一个bower.json文件，用来保存该项目的配置.<br>如果想保存依赖信息(dependencies)到你的bower.json文件，安装包时，命令后面跟上–save即可。</p>\n<h3 id=\"5-使用下载好的包\"><a href=\"#5-使用下载好的包\" class=\"headerlink\" title=\"5.使用下载好的包\"></a>5.使用下载好的包</h3><p>对于已经下载下来的包，默认在当前目录的bower_components文件夹。你可以直接在项目里引用。例如：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;link rel=<span class=\"string\">\"stylesheet\"</span> href=<span class=\"string\">\"bower_components/bootstrap/dist/css/bootstrap.min.css\"</span>&gt;</span><br><span class=\"line\">&lt;script <span class=\"built_in\">type</span>=<span class=\"string\">\"text/javascript\"</span> src=<span class=\"string\">\"bower_components/jquery/dist/jquery.min.js\"</span>&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure>\n<h3 id=\"6-更新包\"><a href=\"#6-更新包\" class=\"headerlink\" title=\"6.更新包\"></a>6.更新包</h3><p>若下载的包升级了，只需执行update命令即可更新，例如：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">bower update jquery</span><br></pre></td></tr></table></figure></p>\n<p>这样就可以自动升级到最新版的jquery了。<br>更新选项</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-F, --force-latest: Force latest version on conflict</span><br><span class=\"line\">-p, --production: Do not install project devDependencies</span><br><span class=\"line\">-S, --save: Update dependencies <span class=\"keyword\">in</span> bower.json</span><br><span class=\"line\">-D, --save-dev: Update devDependencies <span class=\"keyword\">in</span> bower.json</span><br></pre></td></tr></table></figure>\n<h3 id=\"7-搜索包\"><a href=\"#7-搜索包\" class=\"headerlink\" title=\"7.搜索包\"></a>7.搜索包</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">bower search               <span class=\"comment\">#搜索所有包</span></span><br><span class=\"line\">bower search &lt;packageName&gt; <span class=\"comment\">#搜索指定名称的包</span></span><br></pre></td></tr></table></figure>\n<p>或者可以在<a href=\"https://bower.io/search/\" target=\"_blank\" rel=\"noopener\">这里</a>搜索喜欢的包.</p>\n<h3 id=\"8-卸载包\"><a href=\"#8-卸载包\" class=\"headerlink\" title=\"8.卸载包\"></a>8.卸载包</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">bower uninstall &lt;name&gt; [&lt;name&gt; ..] [&lt;options&gt;]</span><br></pre></td></tr></table></figure>\n<p>卸载选项<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-S, --save: Remove uninstalled packages from the project’s bower.json dependencies</span><br><span class=\"line\">-D, --save-dev: Remove uninstalled packages from the project’s bower.json devDependencies</span><br></pre></td></tr></table></figure></p>"},{"title":"javascript中Array中的indexOf方法","date":"2017-05-18T03:17:11.000Z","_content":"\n#### 前言\n想必`String`的`indexOf`方法大家都已经很熟悉，用来判断字符串中是否含有某个字符串片段，对于正则不熟悉的人可谓利器，这里不在赘述。但是`Array`的`indexOf`方法却很容易被大家忽略。\n<!--more-->\n#### 简述\n**`Array.prototype.indexOf()`**\n该indexOf()方法返回在数组中可以找到给定元素的第一个索引，如果不存在则返回-1。\n![](http://www.leqikeji.cn/blogImg/Array.indexof.png)\n\n#### 句法\n\tarr.indexOf（searchElement [，fromIndex]）\n##### 参数\n`searchElement`要在数组中找到的元素。\n`fromIndex` *可选的*\n开始搜索的索引。如果索引大于或等于数组的长度，则返回-1，这意味着数组将不会被搜索。如果提供的索引值是负数，则将其作为数组末尾的偏移量。注意：如果提供的索引是负数，则数组仍然是从前到后搜索。如果计算出的索引小于0，则将搜索整个数组。默认值：0（整个数组被搜索）。\n##### 返回值\n数组中元素的第一个索引; -1如果没有找到。\n\n##### 描述\n`indexOf()`与`searchElement`使用严格等式的数组的元素进行比较（与=== 三等于运算符使用的方法相同）即不会进行隐式类型转换。\n\n#### 栗子\n在数组中定位值。\n```javascript\nar array = [2, 9, 9];\narray.indexOf(2);     // 0\narray.indexOf(7);     // -1\narray.indexOf(9, 2);  // 2\narray.indexOf(2, -1); // -1\narray.indexOf(2, -3); // 0\n```\n****\n查找元素所有位置\n```javascript\nvar indices = [];\nvar array = ['a', 'b', 'a', 'c', 'a', 'd'];\nvar element = 'a';\nvar idx = array.indexOf(element);\nwhile (idx != -1) {\n  indices.push(idx);\n  idx = array.indexOf(element, idx + 1);\n}\nconsole.log(indices);\n// [0, 2, 4]\n```\n****\n查找数组中是否存在元素并更新数组\n```javascript\nfunction updateVegetablesCollection (veggies, veggie) {\n    if (veggies.indexOf(veggie) === -1) {\n        veggies.push(veggie);\n        console.log('New veggies collection is : ' + veggies);\n    } else if (veggies.indexOf(veggie) > -1) {\n        console.log(veggie + ' already exists in the veggies collection.');\n    }\n}\n\nvar veggies = ['potato', 'tomato', 'chillies', 'green-pepper'];\n\nupdateVegetablesCollection(veggies, 'spinach');\n// New veggies collection is : potato,tomato,chillies,green-pepper,spinach\nupdateVegetablesCollection(veggies, 'spinach');\n// spinach already exists in the veggies collection.\n```\n****\n\n#### 兼容性\n咱只说IE, 支持IE9以上","source":"_posts/js-Array-indexOf方法.md","raw":"---\ntitle: javascript中Array中的indexOf方法\ndate: 2017-05-18 11:17:11\ntags:\n  - indexOf\ncategories:\n  - 技术分享\n---\n\n#### 前言\n想必`String`的`indexOf`方法大家都已经很熟悉，用来判断字符串中是否含有某个字符串片段，对于正则不熟悉的人可谓利器，这里不在赘述。但是`Array`的`indexOf`方法却很容易被大家忽略。\n<!--more-->\n#### 简述\n**`Array.prototype.indexOf()`**\n该indexOf()方法返回在数组中可以找到给定元素的第一个索引，如果不存在则返回-1。\n![](http://www.leqikeji.cn/blogImg/Array.indexof.png)\n\n#### 句法\n\tarr.indexOf（searchElement [，fromIndex]）\n##### 参数\n`searchElement`要在数组中找到的元素。\n`fromIndex` *可选的*\n开始搜索的索引。如果索引大于或等于数组的长度，则返回-1，这意味着数组将不会被搜索。如果提供的索引值是负数，则将其作为数组末尾的偏移量。注意：如果提供的索引是负数，则数组仍然是从前到后搜索。如果计算出的索引小于0，则将搜索整个数组。默认值：0（整个数组被搜索）。\n##### 返回值\n数组中元素的第一个索引; -1如果没有找到。\n\n##### 描述\n`indexOf()`与`searchElement`使用严格等式的数组的元素进行比较（与=== 三等于运算符使用的方法相同）即不会进行隐式类型转换。\n\n#### 栗子\n在数组中定位值。\n```javascript\nar array = [2, 9, 9];\narray.indexOf(2);     // 0\narray.indexOf(7);     // -1\narray.indexOf(9, 2);  // 2\narray.indexOf(2, -1); // -1\narray.indexOf(2, -3); // 0\n```\n****\n查找元素所有位置\n```javascript\nvar indices = [];\nvar array = ['a', 'b', 'a', 'c', 'a', 'd'];\nvar element = 'a';\nvar idx = array.indexOf(element);\nwhile (idx != -1) {\n  indices.push(idx);\n  idx = array.indexOf(element, idx + 1);\n}\nconsole.log(indices);\n// [0, 2, 4]\n```\n****\n查找数组中是否存在元素并更新数组\n```javascript\nfunction updateVegetablesCollection (veggies, veggie) {\n    if (veggies.indexOf(veggie) === -1) {\n        veggies.push(veggie);\n        console.log('New veggies collection is : ' + veggies);\n    } else if (veggies.indexOf(veggie) > -1) {\n        console.log(veggie + ' already exists in the veggies collection.');\n    }\n}\n\nvar veggies = ['potato', 'tomato', 'chillies', 'green-pepper'];\n\nupdateVegetablesCollection(veggies, 'spinach');\n// New veggies collection is : potato,tomato,chillies,green-pepper,spinach\nupdateVegetablesCollection(veggies, 'spinach');\n// spinach already exists in the veggies collection.\n```\n****\n\n#### 兼容性\n咱只说IE, 支持IE9以上","slug":"js-Array-indexOf方法","published":1,"updated":"2019-12-25T03:33:30.376Z","_id":"cjhbjw6qe0006fx9mihfl79m9","comments":1,"layout":"post","photos":[],"link":"","content":"<h4 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h4><p>想必<code>String</code>的<code>indexOf</code>方法大家都已经很熟悉，用来判断字符串中是否含有某个字符串片段，对于正则不熟悉的人可谓利器，这里不在赘述。但是<code>Array</code>的<code>indexOf</code>方法却很容易被大家忽略。<br><a id=\"more\"></a></p>\n<h4 id=\"简述\"><a href=\"#简述\" class=\"headerlink\" title=\"简述\"></a>简述</h4><p><strong><code>Array.prototype.indexOf()</code></strong><br>该indexOf()方法返回在数组中可以找到给定元素的第一个索引，如果不存在则返回-1。<br><img src=\"http://www.leqikeji.cn/blogImg/Array.indexof.png\" alt=\"\"></p>\n<h4 id=\"句法\"><a href=\"#句法\" class=\"headerlink\" title=\"句法\"></a>句法</h4><pre><code>arr.indexOf（searchElement [，fromIndex]）\n</code></pre><h5 id=\"参数\"><a href=\"#参数\" class=\"headerlink\" title=\"参数\"></a>参数</h5><p><code>searchElement</code>要在数组中找到的元素。<br><code>fromIndex</code> <em>可选的</em><br>开始搜索的索引。如果索引大于或等于数组的长度，则返回-1，这意味着数组将不会被搜索。如果提供的索引值是负数，则将其作为数组末尾的偏移量。注意：如果提供的索引是负数，则数组仍然是从前到后搜索。如果计算出的索引小于0，则将搜索整个数组。默认值：0（整个数组被搜索）。</p>\n<h5 id=\"返回值\"><a href=\"#返回值\" class=\"headerlink\" title=\"返回值\"></a>返回值</h5><p>数组中元素的第一个索引; -1如果没有找到。</p>\n<h5 id=\"描述\"><a href=\"#描述\" class=\"headerlink\" title=\"描述\"></a>描述</h5><p><code>indexOf()</code>与<code>searchElement</code>使用严格等式的数组的元素进行比较（与=== 三等于运算符使用的方法相同）即不会进行隐式类型转换。</p>\n<h4 id=\"栗子\"><a href=\"#栗子\" class=\"headerlink\" title=\"栗子\"></a>栗子</h4><p>在数组中定位值。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ar array = [<span class=\"number\">2</span>, <span class=\"number\">9</span>, <span class=\"number\">9</span>];</span><br><span class=\"line\">array.indexOf(<span class=\"number\">2</span>);     <span class=\"comment\">// 0</span></span><br><span class=\"line\">array.indexOf(<span class=\"number\">7</span>);     <span class=\"comment\">// -1</span></span><br><span class=\"line\">array.indexOf(<span class=\"number\">9</span>, <span class=\"number\">2</span>);  <span class=\"comment\">// 2</span></span><br><span class=\"line\">array.indexOf(<span class=\"number\">2</span>, <span class=\"number\">-1</span>); <span class=\"comment\">// -1</span></span><br><span class=\"line\">array.indexOf(<span class=\"number\">2</span>, <span class=\"number\">-3</span>); <span class=\"comment\">// 0</span></span><br></pre></td></tr></table></figure></p>\n<hr>\n<p>查找元素所有位置<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> indices = [];</span><br><span class=\"line\"><span class=\"keyword\">var</span> array = [<span class=\"string\">'a'</span>, <span class=\"string\">'b'</span>, <span class=\"string\">'a'</span>, <span class=\"string\">'c'</span>, <span class=\"string\">'a'</span>, <span class=\"string\">'d'</span>];</span><br><span class=\"line\"><span class=\"keyword\">var</span> element = <span class=\"string\">'a'</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> idx = array.indexOf(element);</span><br><span class=\"line\"><span class=\"keyword\">while</span> (idx != <span class=\"number\">-1</span>) &#123;</span><br><span class=\"line\">  indices.push(idx);</span><br><span class=\"line\">  idx = array.indexOf(element, idx + <span class=\"number\">1</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(indices);</span><br><span class=\"line\"><span class=\"comment\">// [0, 2, 4]</span></span><br></pre></td></tr></table></figure></p>\n<hr>\n<p>查找数组中是否存在元素并更新数组<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">updateVegetablesCollection</span> (<span class=\"params\">veggies, veggie</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (veggies.indexOf(veggie) === <span class=\"number\">-1</span>) &#123;</span><br><span class=\"line\">        veggies.push(veggie);</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">'New veggies collection is : '</span> + veggies);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (veggies.indexOf(veggie) &gt; <span class=\"number\">-1</span>) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(veggie + <span class=\"string\">' already exists in the veggies collection.'</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> veggies = [<span class=\"string\">'potato'</span>, <span class=\"string\">'tomato'</span>, <span class=\"string\">'chillies'</span>, <span class=\"string\">'green-pepper'</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">updateVegetablesCollection(veggies, <span class=\"string\">'spinach'</span>);</span><br><span class=\"line\"><span class=\"comment\">// New veggies collection is : potato,tomato,chillies,green-pepper,spinach</span></span><br><span class=\"line\">updateVegetablesCollection(veggies, <span class=\"string\">'spinach'</span>);</span><br><span class=\"line\"><span class=\"comment\">// spinach already exists in the veggies collection.</span></span><br></pre></td></tr></table></figure></p>\n<hr>\n<h4 id=\"兼容性\"><a href=\"#兼容性\" class=\"headerlink\" title=\"兼容性\"></a>兼容性</h4><p>咱只说IE, 支持IE9以上</p>\n","site":{"data":{}},"excerpt":"<h4 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h4><p>想必<code>String</code>的<code>indexOf</code>方法大家都已经很熟悉，用来判断字符串中是否含有某个字符串片段，对于正则不熟悉的人可谓利器，这里不在赘述。但是<code>Array</code>的<code>indexOf</code>方法却很容易被大家忽略。<br>","more":"</p>\n<h4 id=\"简述\"><a href=\"#简述\" class=\"headerlink\" title=\"简述\"></a>简述</h4><p><strong><code>Array.prototype.indexOf()</code></strong><br>该indexOf()方法返回在数组中可以找到给定元素的第一个索引，如果不存在则返回-1。<br><img src=\"http://www.leqikeji.cn/blogImg/Array.indexof.png\" alt=\"\"></p>\n<h4 id=\"句法\"><a href=\"#句法\" class=\"headerlink\" title=\"句法\"></a>句法</h4><pre><code>arr.indexOf（searchElement [，fromIndex]）\n</code></pre><h5 id=\"参数\"><a href=\"#参数\" class=\"headerlink\" title=\"参数\"></a>参数</h5><p><code>searchElement</code>要在数组中找到的元素。<br><code>fromIndex</code> <em>可选的</em><br>开始搜索的索引。如果索引大于或等于数组的长度，则返回-1，这意味着数组将不会被搜索。如果提供的索引值是负数，则将其作为数组末尾的偏移量。注意：如果提供的索引是负数，则数组仍然是从前到后搜索。如果计算出的索引小于0，则将搜索整个数组。默认值：0（整个数组被搜索）。</p>\n<h5 id=\"返回值\"><a href=\"#返回值\" class=\"headerlink\" title=\"返回值\"></a>返回值</h5><p>数组中元素的第一个索引; -1如果没有找到。</p>\n<h5 id=\"描述\"><a href=\"#描述\" class=\"headerlink\" title=\"描述\"></a>描述</h5><p><code>indexOf()</code>与<code>searchElement</code>使用严格等式的数组的元素进行比较（与=== 三等于运算符使用的方法相同）即不会进行隐式类型转换。</p>\n<h4 id=\"栗子\"><a href=\"#栗子\" class=\"headerlink\" title=\"栗子\"></a>栗子</h4><p>在数组中定位值。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ar array = [<span class=\"number\">2</span>, <span class=\"number\">9</span>, <span class=\"number\">9</span>];</span><br><span class=\"line\">array.indexOf(<span class=\"number\">2</span>);     <span class=\"comment\">// 0</span></span><br><span class=\"line\">array.indexOf(<span class=\"number\">7</span>);     <span class=\"comment\">// -1</span></span><br><span class=\"line\">array.indexOf(<span class=\"number\">9</span>, <span class=\"number\">2</span>);  <span class=\"comment\">// 2</span></span><br><span class=\"line\">array.indexOf(<span class=\"number\">2</span>, <span class=\"number\">-1</span>); <span class=\"comment\">// -1</span></span><br><span class=\"line\">array.indexOf(<span class=\"number\">2</span>, <span class=\"number\">-3</span>); <span class=\"comment\">// 0</span></span><br></pre></td></tr></table></figure></p>\n<hr>\n<p>查找元素所有位置<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> indices = [];</span><br><span class=\"line\"><span class=\"keyword\">var</span> array = [<span class=\"string\">'a'</span>, <span class=\"string\">'b'</span>, <span class=\"string\">'a'</span>, <span class=\"string\">'c'</span>, <span class=\"string\">'a'</span>, <span class=\"string\">'d'</span>];</span><br><span class=\"line\"><span class=\"keyword\">var</span> element = <span class=\"string\">'a'</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> idx = array.indexOf(element);</span><br><span class=\"line\"><span class=\"keyword\">while</span> (idx != <span class=\"number\">-1</span>) &#123;</span><br><span class=\"line\">  indices.push(idx);</span><br><span class=\"line\">  idx = array.indexOf(element, idx + <span class=\"number\">1</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(indices);</span><br><span class=\"line\"><span class=\"comment\">// [0, 2, 4]</span></span><br></pre></td></tr></table></figure></p>\n<hr>\n<p>查找数组中是否存在元素并更新数组<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">updateVegetablesCollection</span> (<span class=\"params\">veggies, veggie</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (veggies.indexOf(veggie) === <span class=\"number\">-1</span>) &#123;</span><br><span class=\"line\">        veggies.push(veggie);</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">'New veggies collection is : '</span> + veggies);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (veggies.indexOf(veggie) &gt; <span class=\"number\">-1</span>) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(veggie + <span class=\"string\">' already exists in the veggies collection.'</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> veggies = [<span class=\"string\">'potato'</span>, <span class=\"string\">'tomato'</span>, <span class=\"string\">'chillies'</span>, <span class=\"string\">'green-pepper'</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">updateVegetablesCollection(veggies, <span class=\"string\">'spinach'</span>);</span><br><span class=\"line\"><span class=\"comment\">// New veggies collection is : potato,tomato,chillies,green-pepper,spinach</span></span><br><span class=\"line\">updateVegetablesCollection(veggies, <span class=\"string\">'spinach'</span>);</span><br><span class=\"line\"><span class=\"comment\">// spinach already exists in the veggies collection.</span></span><br></pre></td></tr></table></figure></p>\n<hr>\n<h4 id=\"兼容性\"><a href=\"#兼容性\" class=\"headerlink\" title=\"兼容性\"></a>兼容性</h4><p>咱只说IE, 支持IE9以上</p>"},{"title":"请你实现一个深克隆","date":"2018-04-07T08:13:25.000Z","_content":"\n#### 前言\n&emsp;&emsp;实现一个深克隆是面试中常见的问题的,可是绝大多数面试者的答案都是不完整的,甚至是错误的,这个时候面试官会不断追问,看看你到底理解不理解深克隆的原理,很多情况下一些一知半解的面试者就原形毕漏了.\n我们就来看一下如何实现一个深克隆,当然面试中没有让你完整实现的时候,但是你一定要搞清楚其中的坑在哪里,才可以轻松应对面试官的追问.\n\n在要实现一个深克隆之前我们需要了解一下javascript中的基础类型.\n\n[javascript基础类型 ](/blog/2018/05/06/js-dataType/)\n\n> JavaScript原始类型:Undefined、Null、Boolean、Number、String、Symbol\n\n> JavaScript引用类型:Object\n\n<!-- more -->\n***\n#### 1.浅克隆\n&emsp;&emsp;`浅克隆`之所以被称为`浅克隆`，是因为对象只会被克隆最外部的一层,至于更深层的对象,则依然是通过引用指向同一块堆内存.\n\n```javascript\n// 浅克隆函数\nfunction shallowClone(o) {\n  const obj = {};\n  for ( let i in o) {\n    obj[i] = o[i];\n  }\n  return obj;\n}\n// 被克隆对象\nconst oldObj = {\n  a: 1,\n  b: [ 'e', 'f', 'g' ],\n  c: { h: { i: 2 } }\n};\n\nconst newObj = shallowClone(oldObj);\nconsole.log(newObj.c.h, oldObj.c.h); // { i: 2 } { i: 2 }\nconsole.log(oldObj.c.h === newObj.c.h); // true\n```\n我们可以看到,很明显虽然`oldObj.c.h`被克隆了,但是它还与`oldObj.c.h`相等,这表明他们依然指向同一段堆内存,这就造成了如果对`newObj.c.h`进行修改,也会影响`oldObj.c.h`,这就不是一版好的克隆.\n\n```javascript\nnewObj.c.h.i = 'change';\nconsole.log(newObj.c.h, oldObj.c.h); // { i: 'change' } { i: 'change' }\n```\n我们改变了`newObj.c.h.i`的值,`oldObj.c.h.i`也被改变了,这就是浅克隆的问题所在.\n\n当然有一个新的`apiObject.assign()`也可以实现浅复制,但是效果跟上面没有差别,所以我们不再细说了.\n\n#### 2.深克隆\n##### 2.1 JSON.parse方法\n&emsp;&emsp;前几年微博上流传着一个传说中最便捷实现深克隆的方法, JSON对象parse方法可以将JSON字符串反序列化成JS对象，stringify方法可以将JS对象序列化成JSON字符串,这两个方法结合起来就能产生一个便捷的深克隆.\n\n\tconst newObj = JSON.parse(JSON.stringify(oldObj));\n\n我们依然用上一节的例子进行测试\n\n```javascript\nconst oldObj = {\n  a: 1,\n  b: [ 'e', 'f', 'g' ],\n  c: { h: { i: 2 } }\n};\n\nconst newObj = JSON.parse(JSON.stringify(oldObj));\nconsole.log(newObj.c.h, oldObj.c.h); // { i: 2 } { i: 2 }\nconsole.log(oldObj.c.h === newObj.c.h); // false\nnewObj.c.h.i = 'change';\nconsole.log(newObj.c.h, oldObj.c.h); // { i: 'change' } { i: 2 }\n```\n果然,这是一个实现深克隆的好方法,但是这个解决办法是不是太过简单了.\n\n确实,这个方法虽然可以解决绝大部分是使用场景,但是却有很多坑.\n\n> 1.他无法实现对函数 、RegExp等特殊对象的克隆\n\n> 2.会抛弃对象的constructor,所有的构造函数会指向Object\n\n> 3.对象有循环引用,会报错\n\n主要的坑就是以上几点,我们一一测试下.\n```javascript\n// 构造函数\nfunction person(pname) {\n  this.name = pname;\n}\n\nconst Messi = new person('Messi');\n\n// 函数\nfunction say() {\n  console.log('hi');\n};\n\nconst oldObj = {\n  a: say,\n  b: new Array(1),\n  c: new RegExp('ab+c', 'i'),\n  d: Messi\n};\n\nconst newObj = JSON.parse(JSON.stringify(oldObj));\n\n// 无法复制函数\nconsole.log(newObj.a, oldObj.a); // undefined [Function: say]\n// 稀疏数组复制错误\nconsole.log(newObj.b[0], oldObj.b[0]); // null undefined\n// 无法复制正则对象\nconsole.log(newObj.c, oldObj.c); // {} /ab+c/i\n// 构造函数指向错误\nconsole.log(newObj.d.constructor, oldObj.d.constructor); // [Function: Object] [Function: person]\n```\n我们可以看到在对函数、正则对象、稀疏数组等对象克隆时会发生意外，构造函数指向也会发生错误。\n```javascript\nconst oldObj = {};\n\noldObj.a = oldObj;\n\nconst newObj = JSON.parse(JSON.stringify(oldObj));\nconsole.log(newObj.a, oldObj.a); // TypeError: Converting circular structure to JSON\n```\n对象的循环引用会抛出错误.\n\n##### 2.2 构造一个深克隆函数\n\n我们知道要想实现一个靠谱的深克隆方法,上一节提到的**序列/反序列**是不可能了,而通常教程里提到的方法也是不靠谱的,他们存在的问题跟上一届序列反序列操作中凸显的问题是一致的.\n```javascript\nfunction isArray(arr){\n\treturn Object.prototype.toString.call(arr) == '[object Array]'\n}\n//深度克隆\nfunction deepClone(obj){\n\tif(typeof obj !== 'object' && typeof obj !== 'function'){\n\t\treturn obj; //原始类型直接返回\n\t}\n\tvar o = isArray(obj) ? [] : {};\n\tfor(i in obj){\n\t\tif(obj.hasOwnProperty(i)){\n\t\t\to[i] = typeof[i] === 'object' ? deepClone(obj[i]) : obj[i];\n\t\t}\n\t}\n\treturn o;\n}\n```\n\n(这个方法也会出现上一节提到的问题)\n\n由于要面对不同的对象(正则、数组、Date等)要采用不同的处理方式，我们需要实现一个对象类型判断函数。\n\n```javascript\nconst isType = (obj, type) => {\n  if (typeof obj !== 'object') return false;\n  const typeString = Object.prototype.toString.call(obj);\n  let flag;\n  switch (type) {\n    case 'Array':\n      flag = typeString === '[object Array]';\n      break;\n    case 'Date':\n      flag = typeString === '[object Date]';\n      break;\n    case 'RegExp':\n      flag = typeString === '[object RegExp]';\n      break;\n    default:\n      flag = false;\n  }\n  return flag;\n};\n```\n这样我们就可以对特殊对象进行类型判断了,从而采用针对性的克隆策略.\n```javascript\nconst arr = Array.of(3, 4, 5, 2);\n\nconsole.log(isType(arr, 'Array')); // true\n```\n对于正则对象,我们在处理之前要先补充一点新知识.\n\n我们需要通过[正则的扩展](http://es6.ruanyifeng.com/#docs/regex#flags-%E5%B1%9E%E6%80%A7)了解到`flags`属性等等,因此我们需要实现一个提取`flags`的函数.\n```javascript\nconst getRegExp = re => {\n  var flags = '';\n  if (re.global) flags += 'g';\n  if (re.ignoreCase) flags += 'i';\n  if (re.multiline) flags += 'm';\n  return flags;\n};\n```\n做好了这些准备工作,我们就可以进行深克隆的实现了.\n```javascript\n/**\n* deep clone\n* @param  {[type]} parent object 需要进行克隆的对象\n* @return {[type]}        深克隆后的对象\n*/\nconst clone = parent => {\n  // 维护两个储存循环引用的数组\n  const parents = [];\n  const children = [];\n\n  const _clone = parent => {\n    if (parent === null) return null;\n    if (typeof parent !== 'object') return parent;\n\n    let child, proto;\n\n    if (isType(parent, 'Array')) {\n      // 对数组做特殊处理\n      child = [];\n    } else if (isType(parent, 'RegExp')) {\n      // 对正则对象做特殊处理\n      child = new RegExp(parent.source, getRegExp(parent));\n      if (parent.lastIndex) child.lastIndex = parent.lastIndex;\n    } else if (isType(parent, 'Date')) {\n      // 对Date对象做特殊处理\n      child = new Date(parent.getTime());\n    } else {\n      // 处理对象原型\n      proto = Object.getPrototypeOf(parent);\n      // 利用Object.create切断原型链\n      child = Object.create(proto);\n    }\n\n    // 处理循环引用\n    const index = parents.indexOf(parent);\n\n    if (index != -1) {\n      // 如果父数组存在本对象,说明之前已经被引用过,直接返回此对象\n      return children[index];\n    }\n    parents.push(parent);\n    children.push(child);\n\n    for (let i in parent) {\n      // 递归\n      child[i] = _clone(parent[i]);\n    }\n\n    return child;\n  };\n  return _clone(parent);\n};\n```\n\n我们做一下测试\n```javascript\nfunction person(pname) {\n  this.name = pname;\n}\n\nconst Messi = new person('Messi');\n\nfunction say() {\n  console.log('hi');\n}\n\nconst oldObj = {\n  a: say,\n  c: new RegExp('ab+c', 'i'),\n  d: Messi,\n};\n\noldObj.b = oldObj;\n\n\nconst newObj = clone(oldObj);\nconsole.log(newObj.a, oldObj.a); // [Function: say] [Function: say]\nconsole.log(newObj.b, oldObj.b); // { a: [Function: say], c: /ab+c/i, d: person { name: 'Messi' }, b: [Circular] } { a: [Function: say], c: /ab+c/i, d: person { name: 'Messi' }, b: [Circular] }\nconsole.log(newObj.c, oldObj.c); // /ab+c/i /ab+c/i\nconsole.log(newObj.d.constructor, oldObj.d.constructor); // [Function: person] [Function: person]\n```\n当然,我们这个深克隆还不算完美,例如`Buffer`对象、`Promise`、`Set`、`Map`可能都需要我们做特殊处理，另外对于确保没有循环引用的对象，我们可以省去对循环引用的特殊处理，因为这很消耗时间，不过一个基本的深克隆函数我们已经实现了。\n\n***\n#### 总结\n实现一个完整的深克隆是由许多坑要踩的,`npm`上一些库的实现也不够完整,在生产环境中最好用`lodash`的深克隆实现.\n在面试过程中,我们上面提到的众多坑是面试官很可能追问你的,要知道坑在哪里,能答出来才是你的加分项,在面试过程中必须要有一两个闪光点,如果只知道序列/反序列这种投机取巧的方法,在追问下不仅拿不到分,很可能造成只懂个皮毛的印象,毕竟,面试面得就是你知识的深度.","source":"_posts/js-clone.md","raw":"---\ntitle: 请你实现一个深克隆\ndate: 2018-04-07 16:13:25\ntags:\n    - javascript深克隆\ncategories:\n    - 面试题\n---\n\n#### 前言\n&emsp;&emsp;实现一个深克隆是面试中常见的问题的,可是绝大多数面试者的答案都是不完整的,甚至是错误的,这个时候面试官会不断追问,看看你到底理解不理解深克隆的原理,很多情况下一些一知半解的面试者就原形毕漏了.\n我们就来看一下如何实现一个深克隆,当然面试中没有让你完整实现的时候,但是你一定要搞清楚其中的坑在哪里,才可以轻松应对面试官的追问.\n\n在要实现一个深克隆之前我们需要了解一下javascript中的基础类型.\n\n[javascript基础类型 ](/blog/2018/05/06/js-dataType/)\n\n> JavaScript原始类型:Undefined、Null、Boolean、Number、String、Symbol\n\n> JavaScript引用类型:Object\n\n<!-- more -->\n***\n#### 1.浅克隆\n&emsp;&emsp;`浅克隆`之所以被称为`浅克隆`，是因为对象只会被克隆最外部的一层,至于更深层的对象,则依然是通过引用指向同一块堆内存.\n\n```javascript\n// 浅克隆函数\nfunction shallowClone(o) {\n  const obj = {};\n  for ( let i in o) {\n    obj[i] = o[i];\n  }\n  return obj;\n}\n// 被克隆对象\nconst oldObj = {\n  a: 1,\n  b: [ 'e', 'f', 'g' ],\n  c: { h: { i: 2 } }\n};\n\nconst newObj = shallowClone(oldObj);\nconsole.log(newObj.c.h, oldObj.c.h); // { i: 2 } { i: 2 }\nconsole.log(oldObj.c.h === newObj.c.h); // true\n```\n我们可以看到,很明显虽然`oldObj.c.h`被克隆了,但是它还与`oldObj.c.h`相等,这表明他们依然指向同一段堆内存,这就造成了如果对`newObj.c.h`进行修改,也会影响`oldObj.c.h`,这就不是一版好的克隆.\n\n```javascript\nnewObj.c.h.i = 'change';\nconsole.log(newObj.c.h, oldObj.c.h); // { i: 'change' } { i: 'change' }\n```\n我们改变了`newObj.c.h.i`的值,`oldObj.c.h.i`也被改变了,这就是浅克隆的问题所在.\n\n当然有一个新的`apiObject.assign()`也可以实现浅复制,但是效果跟上面没有差别,所以我们不再细说了.\n\n#### 2.深克隆\n##### 2.1 JSON.parse方法\n&emsp;&emsp;前几年微博上流传着一个传说中最便捷实现深克隆的方法, JSON对象parse方法可以将JSON字符串反序列化成JS对象，stringify方法可以将JS对象序列化成JSON字符串,这两个方法结合起来就能产生一个便捷的深克隆.\n\n\tconst newObj = JSON.parse(JSON.stringify(oldObj));\n\n我们依然用上一节的例子进行测试\n\n```javascript\nconst oldObj = {\n  a: 1,\n  b: [ 'e', 'f', 'g' ],\n  c: { h: { i: 2 } }\n};\n\nconst newObj = JSON.parse(JSON.stringify(oldObj));\nconsole.log(newObj.c.h, oldObj.c.h); // { i: 2 } { i: 2 }\nconsole.log(oldObj.c.h === newObj.c.h); // false\nnewObj.c.h.i = 'change';\nconsole.log(newObj.c.h, oldObj.c.h); // { i: 'change' } { i: 2 }\n```\n果然,这是一个实现深克隆的好方法,但是这个解决办法是不是太过简单了.\n\n确实,这个方法虽然可以解决绝大部分是使用场景,但是却有很多坑.\n\n> 1.他无法实现对函数 、RegExp等特殊对象的克隆\n\n> 2.会抛弃对象的constructor,所有的构造函数会指向Object\n\n> 3.对象有循环引用,会报错\n\n主要的坑就是以上几点,我们一一测试下.\n```javascript\n// 构造函数\nfunction person(pname) {\n  this.name = pname;\n}\n\nconst Messi = new person('Messi');\n\n// 函数\nfunction say() {\n  console.log('hi');\n};\n\nconst oldObj = {\n  a: say,\n  b: new Array(1),\n  c: new RegExp('ab+c', 'i'),\n  d: Messi\n};\n\nconst newObj = JSON.parse(JSON.stringify(oldObj));\n\n// 无法复制函数\nconsole.log(newObj.a, oldObj.a); // undefined [Function: say]\n// 稀疏数组复制错误\nconsole.log(newObj.b[0], oldObj.b[0]); // null undefined\n// 无法复制正则对象\nconsole.log(newObj.c, oldObj.c); // {} /ab+c/i\n// 构造函数指向错误\nconsole.log(newObj.d.constructor, oldObj.d.constructor); // [Function: Object] [Function: person]\n```\n我们可以看到在对函数、正则对象、稀疏数组等对象克隆时会发生意外，构造函数指向也会发生错误。\n```javascript\nconst oldObj = {};\n\noldObj.a = oldObj;\n\nconst newObj = JSON.parse(JSON.stringify(oldObj));\nconsole.log(newObj.a, oldObj.a); // TypeError: Converting circular structure to JSON\n```\n对象的循环引用会抛出错误.\n\n##### 2.2 构造一个深克隆函数\n\n我们知道要想实现一个靠谱的深克隆方法,上一节提到的**序列/反序列**是不可能了,而通常教程里提到的方法也是不靠谱的,他们存在的问题跟上一届序列反序列操作中凸显的问题是一致的.\n```javascript\nfunction isArray(arr){\n\treturn Object.prototype.toString.call(arr) == '[object Array]'\n}\n//深度克隆\nfunction deepClone(obj){\n\tif(typeof obj !== 'object' && typeof obj !== 'function'){\n\t\treturn obj; //原始类型直接返回\n\t}\n\tvar o = isArray(obj) ? [] : {};\n\tfor(i in obj){\n\t\tif(obj.hasOwnProperty(i)){\n\t\t\to[i] = typeof[i] === 'object' ? deepClone(obj[i]) : obj[i];\n\t\t}\n\t}\n\treturn o;\n}\n```\n\n(这个方法也会出现上一节提到的问题)\n\n由于要面对不同的对象(正则、数组、Date等)要采用不同的处理方式，我们需要实现一个对象类型判断函数。\n\n```javascript\nconst isType = (obj, type) => {\n  if (typeof obj !== 'object') return false;\n  const typeString = Object.prototype.toString.call(obj);\n  let flag;\n  switch (type) {\n    case 'Array':\n      flag = typeString === '[object Array]';\n      break;\n    case 'Date':\n      flag = typeString === '[object Date]';\n      break;\n    case 'RegExp':\n      flag = typeString === '[object RegExp]';\n      break;\n    default:\n      flag = false;\n  }\n  return flag;\n};\n```\n这样我们就可以对特殊对象进行类型判断了,从而采用针对性的克隆策略.\n```javascript\nconst arr = Array.of(3, 4, 5, 2);\n\nconsole.log(isType(arr, 'Array')); // true\n```\n对于正则对象,我们在处理之前要先补充一点新知识.\n\n我们需要通过[正则的扩展](http://es6.ruanyifeng.com/#docs/regex#flags-%E5%B1%9E%E6%80%A7)了解到`flags`属性等等,因此我们需要实现一个提取`flags`的函数.\n```javascript\nconst getRegExp = re => {\n  var flags = '';\n  if (re.global) flags += 'g';\n  if (re.ignoreCase) flags += 'i';\n  if (re.multiline) flags += 'm';\n  return flags;\n};\n```\n做好了这些准备工作,我们就可以进行深克隆的实现了.\n```javascript\n/**\n* deep clone\n* @param  {[type]} parent object 需要进行克隆的对象\n* @return {[type]}        深克隆后的对象\n*/\nconst clone = parent => {\n  // 维护两个储存循环引用的数组\n  const parents = [];\n  const children = [];\n\n  const _clone = parent => {\n    if (parent === null) return null;\n    if (typeof parent !== 'object') return parent;\n\n    let child, proto;\n\n    if (isType(parent, 'Array')) {\n      // 对数组做特殊处理\n      child = [];\n    } else if (isType(parent, 'RegExp')) {\n      // 对正则对象做特殊处理\n      child = new RegExp(parent.source, getRegExp(parent));\n      if (parent.lastIndex) child.lastIndex = parent.lastIndex;\n    } else if (isType(parent, 'Date')) {\n      // 对Date对象做特殊处理\n      child = new Date(parent.getTime());\n    } else {\n      // 处理对象原型\n      proto = Object.getPrototypeOf(parent);\n      // 利用Object.create切断原型链\n      child = Object.create(proto);\n    }\n\n    // 处理循环引用\n    const index = parents.indexOf(parent);\n\n    if (index != -1) {\n      // 如果父数组存在本对象,说明之前已经被引用过,直接返回此对象\n      return children[index];\n    }\n    parents.push(parent);\n    children.push(child);\n\n    for (let i in parent) {\n      // 递归\n      child[i] = _clone(parent[i]);\n    }\n\n    return child;\n  };\n  return _clone(parent);\n};\n```\n\n我们做一下测试\n```javascript\nfunction person(pname) {\n  this.name = pname;\n}\n\nconst Messi = new person('Messi');\n\nfunction say() {\n  console.log('hi');\n}\n\nconst oldObj = {\n  a: say,\n  c: new RegExp('ab+c', 'i'),\n  d: Messi,\n};\n\noldObj.b = oldObj;\n\n\nconst newObj = clone(oldObj);\nconsole.log(newObj.a, oldObj.a); // [Function: say] [Function: say]\nconsole.log(newObj.b, oldObj.b); // { a: [Function: say], c: /ab+c/i, d: person { name: 'Messi' }, b: [Circular] } { a: [Function: say], c: /ab+c/i, d: person { name: 'Messi' }, b: [Circular] }\nconsole.log(newObj.c, oldObj.c); // /ab+c/i /ab+c/i\nconsole.log(newObj.d.constructor, oldObj.d.constructor); // [Function: person] [Function: person]\n```\n当然,我们这个深克隆还不算完美,例如`Buffer`对象、`Promise`、`Set`、`Map`可能都需要我们做特殊处理，另外对于确保没有循环引用的对象，我们可以省去对循环引用的特殊处理，因为这很消耗时间，不过一个基本的深克隆函数我们已经实现了。\n\n***\n#### 总结\n实现一个完整的深克隆是由许多坑要踩的,`npm`上一些库的实现也不够完整,在生产环境中最好用`lodash`的深克隆实现.\n在面试过程中,我们上面提到的众多坑是面试官很可能追问你的,要知道坑在哪里,能答出来才是你的加分项,在面试过程中必须要有一两个闪光点,如果只知道序列/反序列这种投机取巧的方法,在追问下不仅拿不到分,很可能造成只懂个皮毛的印象,毕竟,面试面得就是你知识的深度.","slug":"js-clone","published":1,"updated":"2018-05-08T02:59:03.155Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjhbjw6qg0007fx9mdumumgxz","content":"<h4 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h4><p>&emsp;&emsp;实现一个深克隆是面试中常见的问题的,可是绝大多数面试者的答案都是不完整的,甚至是错误的,这个时候面试官会不断追问,看看你到底理解不理解深克隆的原理,很多情况下一些一知半解的面试者就原形毕漏了.<br>我们就来看一下如何实现一个深克隆,当然面试中没有让你完整实现的时候,但是你一定要搞清楚其中的坑在哪里,才可以轻松应对面试官的追问.</p>\n<p>在要实现一个深克隆之前我们需要了解一下javascript中的基础类型.</p>\n<p><a href=\"/blog/2018/05/06/js-dataType/\">javascript基础类型 </a></p>\n<blockquote>\n<p>JavaScript原始类型:Undefined、Null、Boolean、Number、String、Symbol</p>\n</blockquote>\n<blockquote>\n<p>JavaScript引用类型:Object</p>\n</blockquote>\n<a id=\"more\"></a>\n<hr>\n<h4 id=\"1-浅克隆\"><a href=\"#1-浅克隆\" class=\"headerlink\" title=\"1.浅克隆\"></a>1.浅克隆</h4><p>&emsp;&emsp;<code>浅克隆</code>之所以被称为<code>浅克隆</code>，是因为对象只会被克隆最外部的一层,至于更深层的对象,则依然是通过引用指向同一块堆内存.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 浅克隆函数</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">shallowClone</span>(<span class=\"params\">o</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> obj = &#123;&#125;;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> ( <span class=\"keyword\">let</span> i <span class=\"keyword\">in</span> o) &#123;</span><br><span class=\"line\">    obj[i] = o[i];</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> obj;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 被克隆对象</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> oldObj = &#123;</span><br><span class=\"line\">  a: <span class=\"number\">1</span>,</span><br><span class=\"line\">  b: [ <span class=\"string\">'e'</span>, <span class=\"string\">'f'</span>, <span class=\"string\">'g'</span> ],</span><br><span class=\"line\">  c: &#123; <span class=\"attr\">h</span>: &#123; <span class=\"attr\">i</span>: <span class=\"number\">2</span> &#125; &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> newObj = shallowClone(oldObj);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(newObj.c.h, oldObj.c.h); <span class=\"comment\">// &#123; i: 2 &#125; &#123; i: 2 &#125;</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(oldObj.c.h === newObj.c.h); <span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure>\n<p>我们可以看到,很明显虽然<code>oldObj.c.h</code>被克隆了,但是它还与<code>oldObj.c.h</code>相等,这表明他们依然指向同一段堆内存,这就造成了如果对<code>newObj.c.h</code>进行修改,也会影响<code>oldObj.c.h</code>,这就不是一版好的克隆.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">newObj.c.h.i = <span class=\"string\">'change'</span>;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(newObj.c.h, oldObj.c.h); <span class=\"comment\">// &#123; i: 'change' &#125; &#123; i: 'change' &#125;</span></span><br></pre></td></tr></table></figure>\n<p>我们改变了<code>newObj.c.h.i</code>的值,<code>oldObj.c.h.i</code>也被改变了,这就是浅克隆的问题所在.</p>\n<p>当然有一个新的<code>apiObject.assign()</code>也可以实现浅复制,但是效果跟上面没有差别,所以我们不再细说了.</p>\n<h4 id=\"2-深克隆\"><a href=\"#2-深克隆\" class=\"headerlink\" title=\"2.深克隆\"></a>2.深克隆</h4><h5 id=\"2-1-JSON-parse方法\"><a href=\"#2-1-JSON-parse方法\" class=\"headerlink\" title=\"2.1 JSON.parse方法\"></a>2.1 JSON.parse方法</h5><p>&emsp;&emsp;前几年微博上流传着一个传说中最便捷实现深克隆的方法, JSON对象parse方法可以将JSON字符串反序列化成JS对象，stringify方法可以将JS对象序列化成JSON字符串,这两个方法结合起来就能产生一个便捷的深克隆.</p>\n<pre><code>const newObj = JSON.parse(JSON.stringify(oldObj));\n</code></pre><p>我们依然用上一节的例子进行测试</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> oldObj = &#123;</span><br><span class=\"line\">  a: <span class=\"number\">1</span>,</span><br><span class=\"line\">  b: [ <span class=\"string\">'e'</span>, <span class=\"string\">'f'</span>, <span class=\"string\">'g'</span> ],</span><br><span class=\"line\">  c: &#123; <span class=\"attr\">h</span>: &#123; <span class=\"attr\">i</span>: <span class=\"number\">2</span> &#125; &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> newObj = <span class=\"built_in\">JSON</span>.parse(<span class=\"built_in\">JSON</span>.stringify(oldObj));</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(newObj.c.h, oldObj.c.h); <span class=\"comment\">// &#123; i: 2 &#125; &#123; i: 2 &#125;</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(oldObj.c.h === newObj.c.h); <span class=\"comment\">// false</span></span><br><span class=\"line\">newObj.c.h.i = <span class=\"string\">'change'</span>;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(newObj.c.h, oldObj.c.h); <span class=\"comment\">// &#123; i: 'change' &#125; &#123; i: 2 &#125;</span></span><br></pre></td></tr></table></figure>\n<p>果然,这是一个实现深克隆的好方法,但是这个解决办法是不是太过简单了.</p>\n<p>确实,这个方法虽然可以解决绝大部分是使用场景,但是却有很多坑.</p>\n<blockquote>\n<p>1.他无法实现对函数 、RegExp等特殊对象的克隆</p>\n</blockquote>\n<blockquote>\n<p>2.会抛弃对象的constructor,所有的构造函数会指向Object</p>\n</blockquote>\n<blockquote>\n<p>3.对象有循环引用,会报错</p>\n</blockquote>\n<p>主要的坑就是以上几点,我们一一测试下.<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 构造函数</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">person</span>(<span class=\"params\">pname</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.name = pname;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> Messi = <span class=\"keyword\">new</span> person(<span class=\"string\">'Messi'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 函数</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">say</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'hi'</span>);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> oldObj = &#123;</span><br><span class=\"line\">  a: say,</span><br><span class=\"line\">  b: <span class=\"keyword\">new</span> <span class=\"built_in\">Array</span>(<span class=\"number\">1</span>),</span><br><span class=\"line\">  c: <span class=\"keyword\">new</span> <span class=\"built_in\">RegExp</span>(<span class=\"string\">'ab+c'</span>, <span class=\"string\">'i'</span>),</span><br><span class=\"line\">  d: Messi</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> newObj = <span class=\"built_in\">JSON</span>.parse(<span class=\"built_in\">JSON</span>.stringify(oldObj));</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 无法复制函数</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(newObj.a, oldObj.a); <span class=\"comment\">// undefined [Function: say]</span></span><br><span class=\"line\"><span class=\"comment\">// 稀疏数组复制错误</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(newObj.b[<span class=\"number\">0</span>], oldObj.b[<span class=\"number\">0</span>]); <span class=\"comment\">// null undefined</span></span><br><span class=\"line\"><span class=\"comment\">// 无法复制正则对象</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(newObj.c, oldObj.c); <span class=\"comment\">// &#123;&#125; /ab+c/i</span></span><br><span class=\"line\"><span class=\"comment\">// 构造函数指向错误</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(newObj.d.constructor, oldObj.d.constructor); <span class=\"comment\">// [Function: Object] [Function: person]</span></span><br></pre></td></tr></table></figure></p>\n<p>我们可以看到在对函数、正则对象、稀疏数组等对象克隆时会发生意外，构造函数指向也会发生错误。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> oldObj = &#123;&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">oldObj.a = oldObj;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> newObj = <span class=\"built_in\">JSON</span>.parse(<span class=\"built_in\">JSON</span>.stringify(oldObj));</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(newObj.a, oldObj.a); <span class=\"comment\">// TypeError: Converting circular structure to JSON</span></span><br></pre></td></tr></table></figure></p>\n<p>对象的循环引用会抛出错误.</p>\n<h5 id=\"2-2-构造一个深克隆函数\"><a href=\"#2-2-构造一个深克隆函数\" class=\"headerlink\" title=\"2.2 构造一个深克隆函数\"></a>2.2 构造一个深克隆函数</h5><p>我们知道要想实现一个靠谱的深克隆方法,上一节提到的<strong>序列/反序列</strong>是不可能了,而通常教程里提到的方法也是不靠谱的,他们存在的问题跟上一届序列反序列操作中凸显的问题是一致的.<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">isArray</span>(<span class=\"params\">arr</span>)</span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"built_in\">Object</span>.prototype.toString.call(arr) == <span class=\"string\">'[object Array]'</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//深度克隆</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">deepClone</span>(<span class=\"params\">obj</span>)</span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(<span class=\"keyword\">typeof</span> obj !== <span class=\"string\">'object'</span> &amp;&amp; <span class=\"keyword\">typeof</span> obj !== <span class=\"string\">'function'</span>)&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> obj; <span class=\"comment\">//原始类型直接返回</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">var</span> o = isArray(obj) ? [] : &#123;&#125;;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(i <span class=\"keyword\">in</span> obj)&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(obj.hasOwnProperty(i))&#123;</span><br><span class=\"line\">\t\t\to[i] = <span class=\"keyword\">typeof</span>[i] === <span class=\"string\">'object'</span> ? deepClone(obj[i]) : obj[i];</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> o;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>(这个方法也会出现上一节提到的问题)</p>\n<p>由于要面对不同的对象(正则、数组、Date等)要采用不同的处理方式，我们需要实现一个对象类型判断函数。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> isType = <span class=\"function\">(<span class=\"params\">obj, type</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> obj !== <span class=\"string\">'object'</span>) <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> typeString = <span class=\"built_in\">Object</span>.prototype.toString.call(obj);</span><br><span class=\"line\">  <span class=\"keyword\">let</span> flag;</span><br><span class=\"line\">  <span class=\"keyword\">switch</span> (type) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> <span class=\"string\">'Array'</span>:</span><br><span class=\"line\">      flag = typeString === <span class=\"string\">'[object Array]'</span>;</span><br><span class=\"line\">      <span class=\"keyword\">break</span>;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> <span class=\"string\">'Date'</span>:</span><br><span class=\"line\">      flag = typeString === <span class=\"string\">'[object Date]'</span>;</span><br><span class=\"line\">      <span class=\"keyword\">break</span>;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> <span class=\"string\">'RegExp'</span>:</span><br><span class=\"line\">      flag = typeString === <span class=\"string\">'[object RegExp]'</span>;</span><br><span class=\"line\">      <span class=\"keyword\">break</span>;</span><br><span class=\"line\">    <span class=\"keyword\">default</span>:</span><br><span class=\"line\">      flag = <span class=\"literal\">false</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> flag;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>这样我们就可以对特殊对象进行类型判断了,从而采用针对性的克隆策略.<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> arr = <span class=\"built_in\">Array</span>.of(<span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>, <span class=\"number\">2</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(isType(arr, <span class=\"string\">'Array'</span>)); <span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure></p>\n<p>对于正则对象,我们在处理之前要先补充一点新知识.</p>\n<p>我们需要通过<a href=\"http://es6.ruanyifeng.com/#docs/regex#flags-%E5%B1%9E%E6%80%A7\" target=\"_blank\" rel=\"noopener\">正则的扩展</a>了解到<code>flags</code>属性等等,因此我们需要实现一个提取<code>flags</code>的函数.<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> getRegExp = <span class=\"function\"><span class=\"params\">re</span> =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> flags = <span class=\"string\">''</span>;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (re.global) flags += <span class=\"string\">'g'</span>;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (re.ignoreCase) flags += <span class=\"string\">'i'</span>;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (re.multiline) flags += <span class=\"string\">'m'</span>;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> flags;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<p>做好了这些准备工作,我们就可以进行深克隆的实现了.<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">* deep clone</span></span><br><span class=\"line\"><span class=\"comment\">* @param  &#123;[type]&#125; parent object 需要进行克隆的对象</span></span><br><span class=\"line\"><span class=\"comment\">* @return &#123;[type]&#125;        深克隆后的对象</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> clone = <span class=\"function\"><span class=\"params\">parent</span> =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 维护两个储存循环引用的数组</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> parents = [];</span><br><span class=\"line\">  <span class=\"keyword\">const</span> children = [];</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">const</span> _clone = <span class=\"function\"><span class=\"params\">parent</span> =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (parent === <span class=\"literal\">null</span>) <span class=\"keyword\">return</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> parent !== <span class=\"string\">'object'</span>) <span class=\"keyword\">return</span> parent;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">let</span> child, proto;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (isType(parent, <span class=\"string\">'Array'</span>)) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 对数组做特殊处理</span></span><br><span class=\"line\">      child = [];</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (isType(parent, <span class=\"string\">'RegExp'</span>)) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 对正则对象做特殊处理</span></span><br><span class=\"line\">      child = <span class=\"keyword\">new</span> <span class=\"built_in\">RegExp</span>(parent.source, getRegExp(parent));</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (parent.lastIndex) child.lastIndex = parent.lastIndex;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (isType(parent, <span class=\"string\">'Date'</span>)) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 对Date对象做特殊处理</span></span><br><span class=\"line\">      child = <span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>(parent.getTime());</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 处理对象原型</span></span><br><span class=\"line\">      proto = <span class=\"built_in\">Object</span>.getPrototypeOf(parent);</span><br><span class=\"line\">      <span class=\"comment\">// 利用Object.create切断原型链</span></span><br><span class=\"line\">      child = <span class=\"built_in\">Object</span>.create(proto);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 处理循环引用</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> index = parents.indexOf(parent);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (index != <span class=\"number\">-1</span>) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 如果父数组存在本对象,说明之前已经被引用过,直接返回此对象</span></span><br><span class=\"line\">      <span class=\"keyword\">return</span> children[index];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    parents.push(parent);</span><br><span class=\"line\">    children.push(child);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i <span class=\"keyword\">in</span> parent) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 递归</span></span><br><span class=\"line\">      child[i] = _clone(parent[i]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> child;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> _clone(parent);</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<p>我们做一下测试<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">person</span>(<span class=\"params\">pname</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.name = pname;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> Messi = <span class=\"keyword\">new</span> person(<span class=\"string\">'Messi'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">say</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'hi'</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> oldObj = &#123;</span><br><span class=\"line\">  a: say,</span><br><span class=\"line\">  c: <span class=\"keyword\">new</span> <span class=\"built_in\">RegExp</span>(<span class=\"string\">'ab+c'</span>, <span class=\"string\">'i'</span>),</span><br><span class=\"line\">  d: Messi,</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">oldObj.b = oldObj;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> newObj = clone(oldObj);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(newObj.a, oldObj.a); <span class=\"comment\">// [Function: say] [Function: say]</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(newObj.b, oldObj.b); <span class=\"comment\">// &#123; a: [Function: say], c: /ab+c/i, d: person &#123; name: 'Messi' &#125;, b: [Circular] &#125; &#123; a: [Function: say], c: /ab+c/i, d: person &#123; name: 'Messi' &#125;, b: [Circular] &#125;</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(newObj.c, oldObj.c); <span class=\"comment\">// /ab+c/i /ab+c/i</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(newObj.d.constructor, oldObj.d.constructor); <span class=\"comment\">// [Function: person] [Function: person]</span></span><br></pre></td></tr></table></figure></p>\n<p>当然,我们这个深克隆还不算完美,例如<code>Buffer</code>对象、<code>Promise</code>、<code>Set</code>、<code>Map</code>可能都需要我们做特殊处理，另外对于确保没有循环引用的对象，我们可以省去对循环引用的特殊处理，因为这很消耗时间，不过一个基本的深克隆函数我们已经实现了。</p>\n<hr>\n<h4 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h4><p>实现一个完整的深克隆是由许多坑要踩的,<code>npm</code>上一些库的实现也不够完整,在生产环境中最好用<code>lodash</code>的深克隆实现.<br>在面试过程中,我们上面提到的众多坑是面试官很可能追问你的,要知道坑在哪里,能答出来才是你的加分项,在面试过程中必须要有一两个闪光点,如果只知道序列/反序列这种投机取巧的方法,在追问下不仅拿不到分,很可能造成只懂个皮毛的印象,毕竟,面试面得就是你知识的深度.</p>\n","site":{"data":{}},"excerpt":"<h4 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h4><p>&emsp;&emsp;实现一个深克隆是面试中常见的问题的,可是绝大多数面试者的答案都是不完整的,甚至是错误的,这个时候面试官会不断追问,看看你到底理解不理解深克隆的原理,很多情况下一些一知半解的面试者就原形毕漏了.<br>我们就来看一下如何实现一个深克隆,当然面试中没有让你完整实现的时候,但是你一定要搞清楚其中的坑在哪里,才可以轻松应对面试官的追问.</p>\n<p>在要实现一个深克隆之前我们需要了解一下javascript中的基础类型.</p>\n<p><a href=\"/blog/2018/05/06/js-dataType/\">javascript基础类型 </a></p>\n<blockquote>\n<p>JavaScript原始类型:Undefined、Null、Boolean、Number、String、Symbol</p>\n</blockquote>\n<blockquote>\n<p>JavaScript引用类型:Object</p>\n</blockquote>","more":"<hr>\n<h4 id=\"1-浅克隆\"><a href=\"#1-浅克隆\" class=\"headerlink\" title=\"1.浅克隆\"></a>1.浅克隆</h4><p>&emsp;&emsp;<code>浅克隆</code>之所以被称为<code>浅克隆</code>，是因为对象只会被克隆最外部的一层,至于更深层的对象,则依然是通过引用指向同一块堆内存.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 浅克隆函数</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">shallowClone</span>(<span class=\"params\">o</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> obj = &#123;&#125;;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> ( <span class=\"keyword\">let</span> i <span class=\"keyword\">in</span> o) &#123;</span><br><span class=\"line\">    obj[i] = o[i];</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> obj;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 被克隆对象</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> oldObj = &#123;</span><br><span class=\"line\">  a: <span class=\"number\">1</span>,</span><br><span class=\"line\">  b: [ <span class=\"string\">'e'</span>, <span class=\"string\">'f'</span>, <span class=\"string\">'g'</span> ],</span><br><span class=\"line\">  c: &#123; <span class=\"attr\">h</span>: &#123; <span class=\"attr\">i</span>: <span class=\"number\">2</span> &#125; &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> newObj = shallowClone(oldObj);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(newObj.c.h, oldObj.c.h); <span class=\"comment\">// &#123; i: 2 &#125; &#123; i: 2 &#125;</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(oldObj.c.h === newObj.c.h); <span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure>\n<p>我们可以看到,很明显虽然<code>oldObj.c.h</code>被克隆了,但是它还与<code>oldObj.c.h</code>相等,这表明他们依然指向同一段堆内存,这就造成了如果对<code>newObj.c.h</code>进行修改,也会影响<code>oldObj.c.h</code>,这就不是一版好的克隆.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">newObj.c.h.i = <span class=\"string\">'change'</span>;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(newObj.c.h, oldObj.c.h); <span class=\"comment\">// &#123; i: 'change' &#125; &#123; i: 'change' &#125;</span></span><br></pre></td></tr></table></figure>\n<p>我们改变了<code>newObj.c.h.i</code>的值,<code>oldObj.c.h.i</code>也被改变了,这就是浅克隆的问题所在.</p>\n<p>当然有一个新的<code>apiObject.assign()</code>也可以实现浅复制,但是效果跟上面没有差别,所以我们不再细说了.</p>\n<h4 id=\"2-深克隆\"><a href=\"#2-深克隆\" class=\"headerlink\" title=\"2.深克隆\"></a>2.深克隆</h4><h5 id=\"2-1-JSON-parse方法\"><a href=\"#2-1-JSON-parse方法\" class=\"headerlink\" title=\"2.1 JSON.parse方法\"></a>2.1 JSON.parse方法</h5><p>&emsp;&emsp;前几年微博上流传着一个传说中最便捷实现深克隆的方法, JSON对象parse方法可以将JSON字符串反序列化成JS对象，stringify方法可以将JS对象序列化成JSON字符串,这两个方法结合起来就能产生一个便捷的深克隆.</p>\n<pre><code>const newObj = JSON.parse(JSON.stringify(oldObj));\n</code></pre><p>我们依然用上一节的例子进行测试</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> oldObj = &#123;</span><br><span class=\"line\">  a: <span class=\"number\">1</span>,</span><br><span class=\"line\">  b: [ <span class=\"string\">'e'</span>, <span class=\"string\">'f'</span>, <span class=\"string\">'g'</span> ],</span><br><span class=\"line\">  c: &#123; <span class=\"attr\">h</span>: &#123; <span class=\"attr\">i</span>: <span class=\"number\">2</span> &#125; &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> newObj = <span class=\"built_in\">JSON</span>.parse(<span class=\"built_in\">JSON</span>.stringify(oldObj));</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(newObj.c.h, oldObj.c.h); <span class=\"comment\">// &#123; i: 2 &#125; &#123; i: 2 &#125;</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(oldObj.c.h === newObj.c.h); <span class=\"comment\">// false</span></span><br><span class=\"line\">newObj.c.h.i = <span class=\"string\">'change'</span>;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(newObj.c.h, oldObj.c.h); <span class=\"comment\">// &#123; i: 'change' &#125; &#123; i: 2 &#125;</span></span><br></pre></td></tr></table></figure>\n<p>果然,这是一个实现深克隆的好方法,但是这个解决办法是不是太过简单了.</p>\n<p>确实,这个方法虽然可以解决绝大部分是使用场景,但是却有很多坑.</p>\n<blockquote>\n<p>1.他无法实现对函数 、RegExp等特殊对象的克隆</p>\n</blockquote>\n<blockquote>\n<p>2.会抛弃对象的constructor,所有的构造函数会指向Object</p>\n</blockquote>\n<blockquote>\n<p>3.对象有循环引用,会报错</p>\n</blockquote>\n<p>主要的坑就是以上几点,我们一一测试下.<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 构造函数</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">person</span>(<span class=\"params\">pname</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.name = pname;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> Messi = <span class=\"keyword\">new</span> person(<span class=\"string\">'Messi'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 函数</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">say</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'hi'</span>);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> oldObj = &#123;</span><br><span class=\"line\">  a: say,</span><br><span class=\"line\">  b: <span class=\"keyword\">new</span> <span class=\"built_in\">Array</span>(<span class=\"number\">1</span>),</span><br><span class=\"line\">  c: <span class=\"keyword\">new</span> <span class=\"built_in\">RegExp</span>(<span class=\"string\">'ab+c'</span>, <span class=\"string\">'i'</span>),</span><br><span class=\"line\">  d: Messi</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> newObj = <span class=\"built_in\">JSON</span>.parse(<span class=\"built_in\">JSON</span>.stringify(oldObj));</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 无法复制函数</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(newObj.a, oldObj.a); <span class=\"comment\">// undefined [Function: say]</span></span><br><span class=\"line\"><span class=\"comment\">// 稀疏数组复制错误</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(newObj.b[<span class=\"number\">0</span>], oldObj.b[<span class=\"number\">0</span>]); <span class=\"comment\">// null undefined</span></span><br><span class=\"line\"><span class=\"comment\">// 无法复制正则对象</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(newObj.c, oldObj.c); <span class=\"comment\">// &#123;&#125; /ab+c/i</span></span><br><span class=\"line\"><span class=\"comment\">// 构造函数指向错误</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(newObj.d.constructor, oldObj.d.constructor); <span class=\"comment\">// [Function: Object] [Function: person]</span></span><br></pre></td></tr></table></figure></p>\n<p>我们可以看到在对函数、正则对象、稀疏数组等对象克隆时会发生意外，构造函数指向也会发生错误。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> oldObj = &#123;&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">oldObj.a = oldObj;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> newObj = <span class=\"built_in\">JSON</span>.parse(<span class=\"built_in\">JSON</span>.stringify(oldObj));</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(newObj.a, oldObj.a); <span class=\"comment\">// TypeError: Converting circular structure to JSON</span></span><br></pre></td></tr></table></figure></p>\n<p>对象的循环引用会抛出错误.</p>\n<h5 id=\"2-2-构造一个深克隆函数\"><a href=\"#2-2-构造一个深克隆函数\" class=\"headerlink\" title=\"2.2 构造一个深克隆函数\"></a>2.2 构造一个深克隆函数</h5><p>我们知道要想实现一个靠谱的深克隆方法,上一节提到的<strong>序列/反序列</strong>是不可能了,而通常教程里提到的方法也是不靠谱的,他们存在的问题跟上一届序列反序列操作中凸显的问题是一致的.<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">isArray</span>(<span class=\"params\">arr</span>)</span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"built_in\">Object</span>.prototype.toString.call(arr) == <span class=\"string\">'[object Array]'</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//深度克隆</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">deepClone</span>(<span class=\"params\">obj</span>)</span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(<span class=\"keyword\">typeof</span> obj !== <span class=\"string\">'object'</span> &amp;&amp; <span class=\"keyword\">typeof</span> obj !== <span class=\"string\">'function'</span>)&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> obj; <span class=\"comment\">//原始类型直接返回</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">var</span> o = isArray(obj) ? [] : &#123;&#125;;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(i <span class=\"keyword\">in</span> obj)&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(obj.hasOwnProperty(i))&#123;</span><br><span class=\"line\">\t\t\to[i] = <span class=\"keyword\">typeof</span>[i] === <span class=\"string\">'object'</span> ? deepClone(obj[i]) : obj[i];</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> o;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>(这个方法也会出现上一节提到的问题)</p>\n<p>由于要面对不同的对象(正则、数组、Date等)要采用不同的处理方式，我们需要实现一个对象类型判断函数。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> isType = <span class=\"function\">(<span class=\"params\">obj, type</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> obj !== <span class=\"string\">'object'</span>) <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> typeString = <span class=\"built_in\">Object</span>.prototype.toString.call(obj);</span><br><span class=\"line\">  <span class=\"keyword\">let</span> flag;</span><br><span class=\"line\">  <span class=\"keyword\">switch</span> (type) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> <span class=\"string\">'Array'</span>:</span><br><span class=\"line\">      flag = typeString === <span class=\"string\">'[object Array]'</span>;</span><br><span class=\"line\">      <span class=\"keyword\">break</span>;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> <span class=\"string\">'Date'</span>:</span><br><span class=\"line\">      flag = typeString === <span class=\"string\">'[object Date]'</span>;</span><br><span class=\"line\">      <span class=\"keyword\">break</span>;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> <span class=\"string\">'RegExp'</span>:</span><br><span class=\"line\">      flag = typeString === <span class=\"string\">'[object RegExp]'</span>;</span><br><span class=\"line\">      <span class=\"keyword\">break</span>;</span><br><span class=\"line\">    <span class=\"keyword\">default</span>:</span><br><span class=\"line\">      flag = <span class=\"literal\">false</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> flag;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>这样我们就可以对特殊对象进行类型判断了,从而采用针对性的克隆策略.<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> arr = <span class=\"built_in\">Array</span>.of(<span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>, <span class=\"number\">2</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(isType(arr, <span class=\"string\">'Array'</span>)); <span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure></p>\n<p>对于正则对象,我们在处理之前要先补充一点新知识.</p>\n<p>我们需要通过<a href=\"http://es6.ruanyifeng.com/#docs/regex#flags-%E5%B1%9E%E6%80%A7\" target=\"_blank\" rel=\"noopener\">正则的扩展</a>了解到<code>flags</code>属性等等,因此我们需要实现一个提取<code>flags</code>的函数.<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> getRegExp = <span class=\"function\"><span class=\"params\">re</span> =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> flags = <span class=\"string\">''</span>;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (re.global) flags += <span class=\"string\">'g'</span>;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (re.ignoreCase) flags += <span class=\"string\">'i'</span>;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (re.multiline) flags += <span class=\"string\">'m'</span>;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> flags;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<p>做好了这些准备工作,我们就可以进行深克隆的实现了.<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">* deep clone</span></span><br><span class=\"line\"><span class=\"comment\">* @param  &#123;[type]&#125; parent object 需要进行克隆的对象</span></span><br><span class=\"line\"><span class=\"comment\">* @return &#123;[type]&#125;        深克隆后的对象</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> clone = <span class=\"function\"><span class=\"params\">parent</span> =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 维护两个储存循环引用的数组</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> parents = [];</span><br><span class=\"line\">  <span class=\"keyword\">const</span> children = [];</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">const</span> _clone = <span class=\"function\"><span class=\"params\">parent</span> =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (parent === <span class=\"literal\">null</span>) <span class=\"keyword\">return</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> parent !== <span class=\"string\">'object'</span>) <span class=\"keyword\">return</span> parent;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">let</span> child, proto;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (isType(parent, <span class=\"string\">'Array'</span>)) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 对数组做特殊处理</span></span><br><span class=\"line\">      child = [];</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (isType(parent, <span class=\"string\">'RegExp'</span>)) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 对正则对象做特殊处理</span></span><br><span class=\"line\">      child = <span class=\"keyword\">new</span> <span class=\"built_in\">RegExp</span>(parent.source, getRegExp(parent));</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (parent.lastIndex) child.lastIndex = parent.lastIndex;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (isType(parent, <span class=\"string\">'Date'</span>)) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 对Date对象做特殊处理</span></span><br><span class=\"line\">      child = <span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>(parent.getTime());</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 处理对象原型</span></span><br><span class=\"line\">      proto = <span class=\"built_in\">Object</span>.getPrototypeOf(parent);</span><br><span class=\"line\">      <span class=\"comment\">// 利用Object.create切断原型链</span></span><br><span class=\"line\">      child = <span class=\"built_in\">Object</span>.create(proto);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 处理循环引用</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> index = parents.indexOf(parent);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (index != <span class=\"number\">-1</span>) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 如果父数组存在本对象,说明之前已经被引用过,直接返回此对象</span></span><br><span class=\"line\">      <span class=\"keyword\">return</span> children[index];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    parents.push(parent);</span><br><span class=\"line\">    children.push(child);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i <span class=\"keyword\">in</span> parent) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 递归</span></span><br><span class=\"line\">      child[i] = _clone(parent[i]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> child;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> _clone(parent);</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<p>我们做一下测试<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">person</span>(<span class=\"params\">pname</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.name = pname;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> Messi = <span class=\"keyword\">new</span> person(<span class=\"string\">'Messi'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">say</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'hi'</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> oldObj = &#123;</span><br><span class=\"line\">  a: say,</span><br><span class=\"line\">  c: <span class=\"keyword\">new</span> <span class=\"built_in\">RegExp</span>(<span class=\"string\">'ab+c'</span>, <span class=\"string\">'i'</span>),</span><br><span class=\"line\">  d: Messi,</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">oldObj.b = oldObj;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> newObj = clone(oldObj);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(newObj.a, oldObj.a); <span class=\"comment\">// [Function: say] [Function: say]</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(newObj.b, oldObj.b); <span class=\"comment\">// &#123; a: [Function: say], c: /ab+c/i, d: person &#123; name: 'Messi' &#125;, b: [Circular] &#125; &#123; a: [Function: say], c: /ab+c/i, d: person &#123; name: 'Messi' &#125;, b: [Circular] &#125;</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(newObj.c, oldObj.c); <span class=\"comment\">// /ab+c/i /ab+c/i</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(newObj.d.constructor, oldObj.d.constructor); <span class=\"comment\">// [Function: person] [Function: person]</span></span><br></pre></td></tr></table></figure></p>\n<p>当然,我们这个深克隆还不算完美,例如<code>Buffer</code>对象、<code>Promise</code>、<code>Set</code>、<code>Map</code>可能都需要我们做特殊处理，另外对于确保没有循环引用的对象，我们可以省去对循环引用的特殊处理，因为这很消耗时间，不过一个基本的深克隆函数我们已经实现了。</p>\n<hr>\n<h4 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h4><p>实现一个完整的深克隆是由许多坑要踩的,<code>npm</code>上一些库的实现也不够完整,在生产环境中最好用<code>lodash</code>的深克隆实现.<br>在面试过程中,我们上面提到的众多坑是面试官很可能追问你的,要知道坑在哪里,能答出来才是你的加分项,在面试过程中必须要有一两个闪光点,如果只知道序列/反序列这种投机取巧的方法,在追问下不仅拿不到分,很可能造成只懂个皮毛的印象,毕竟,面试面得就是你知识的深度.</p>"},{"title":"js原生拖拽","id":"694","date":"2017-08-16T05:58:37.000Z","_content":"\n#### 原理\n\n1.  鼠标按下：状态=1；记录鼠标的X和Y坐标；记录元素的X和Y偏移值\n2.  鼠标在元素上移动：若状态=0，什么也不做；若状态为1，元素的新X的偏移量 = X2-X1+X(鼠标按下时的元素偏移)，新Y偏移量 = Y2-Y1+Y\n3.  鼠标放开，状态=0\n\n#### 在线预览\n\n<p data-height=\"265\" data-theme-id=\"0\" data-slug-hash=\"oLVgvp\" data-default-tab=\"js,result\" data-user=\"abcdGJJ\" data-embed-version=\"2\" data-pen-title=\"oLVgvp\" class=\"codepen\">See the Pen <a href=\"https://codepen.io/abcdGJJ/pen/oLVgvp/\">oLVgvp</a> by abcdGJJ (<a href=\"https://codepen.io/abcdGJJ\">@abcdGJJ</a>) on <a href=\"https://codepen.io\">CodePen</a>.</p>\n<script async src=\"https://production-assets.codepen.io/assets/embed/ei.js\"></script>\n\n<!-- more -->\n\n#### 代码\n\n```javascript\n    var state = false;\n    var obj, objLeft, objTop, posX, posY,wrap;\n    window.onload = function() {\n        obj = document.getElementById('drop');\n        wrap = document.getElementById('wrap');\n        obj.onmousedown = down;\n        obj.onmousemove = move;\n        obj.onmouseup = up;\n    }\n    function down(e) {\n        obj.style.cursor = \"move\";\n        state = true;\n        objLeft = obj.offsetLeft;//obj左上角距离父节点左边距偏移像素值\n        objTop = obj.offsetTop;\n        posX = parseInt(getPostion(e).x);//鼠标位置\n        posY = parseInt(getPostion(e).y);\n    }\n    function move(e) {\n        if(state == true) {\n            var x = parseInt(getPostion(e).x - posX + objLeft);\n            var y = parseInt(getPostion(e).y - posY +objTop);\n            var w = parseInt(wrap.clientWidth - obj.offsetWidth);\n            var h = parseInt(wrap.clientHeight - obj.offsetHeight);\n            // console.log(x,y);\n            if(x < 0) {\n                x = 0;\n            } else if(x > w) {\n                x = w;\n            }\n            if(y < 0) {\n                y = 0;\n            } else if(y > h) {\n                y = h;\n            }\n            obj.style.left = x + 'px';\n            obj.style.top = y +'px';\n        }\n    }\n    function up() {\n        state = false;\n    }\n    function getPostion(e) {\n        var xpos, ypos;\n        e = e || window.event;//浏览器兼容\n        if(e.pageX) {\n            xpos = e.pageX;\n            ypos = e.pageY;\n        } else {\n            xpos = e.clientX + document.body.scrollLeft - document.body.clientLeft;\n            ypos = e.clientY + document.body.scrollTop - document.body.clientTop;\n        }\n        return {\n            x: xpos,\n            y: ypos\n        }\n    }\n```\n\n#### 面向对象版本版本：\n\n```javascript\nfunction Drag(config) {\n  this.target = document.getElementById(config.id) this.state = false\n  if (config.parentElementId) {\n    this.targetParent = document.getElementById(config.parentElementId)\n    this.maxLeft = parseInt(this.targetParent.clientWidth - this.target.clientWidth)\n    this.maxTop = parseInt(this.targetParent.clientHeight - this.target.clientHeight)\n  } else {\n    this.maxLeft = parseInt(document.documentElement.clientWidth - this.target.clientWidth) \n    this.maxTop = parseInt(document.documentElement.clientHeight - this.target.clientHeight)\n  }\n}\nDrag.prototype = {\n  constructor: Drag,\n  start: function() {\n    this.target.onmousedown = function(e) {\n      this.down(e)\n    }.bind(this)\n    //或\n    // var _this = this\n    // this.target.onmousedown = function(e) {\n    //     _this.down(e)\n    // }\n    this.target.onmousemove = function(e) {\n      this.move(e)\n    }.bind(this) this.target.onmouseup = function(e) {\n      this.up(e)\n    }.bind(this)\n  },\n  getPostion: function(e) {\n    var posX, posY e = e || window.event\n    if (e.pageX) {\n      posX = e.pageX posY = e.pageY\n    } else {\n      posX = e.clientX + document.body.scrollLeft - document.body.clientLeft\n      posY = e.clientY + document.body.scrollTop - document.body.clientTop\n    }\n    return {\n      x: posX,\n      y: posY\n    }\n  },\n  down: function(e) {\n    this.target.style.cursor = \"move\"\n    this.state = true\n    this.left = this.target.offsetLeft\n    this.top = this.target.offsetTop\n    this.posX = parseInt(this.getPostion(e).x)\n    this.posY = parseInt(this.getPostion(e).y)\n  },\n  move: function(e) {\n    if (this.state === true) {\n      var x = parseInt(this.getPostion(e).x - this.posX + this.left)\n      var y = parseInt(this.getPostion(e).y - this.posY + this.top) \n      if (x < 0) {\n        x = 0\n      } else if (x > this.maxLeft) {\n        x = this.maxLeft\n      }\n      if (y < 0) {\n        y = 0\n      } else if (y > this.maxTop) {\n        y = this.maxTop\n      }\n      this.target.style.left = x + 'px'this.target.style.top = y + 'px'\n    }\n  },\n  up: function(e) {\n    this.state = false\n    // this.target.onmousedown = null\n    // this.target.onmousemove = null\n  }\n}\n```","source":"_posts/js-drag.md","raw":"---\ntitle: js原生拖拽\nid: 694\ncategories:\n  - 技术分享\ndate: 2017-08-16 13:58:37\ntags:\n---\n\n#### 原理\n\n1.  鼠标按下：状态=1；记录鼠标的X和Y坐标；记录元素的X和Y偏移值\n2.  鼠标在元素上移动：若状态=0，什么也不做；若状态为1，元素的新X的偏移量 = X2-X1+X(鼠标按下时的元素偏移)，新Y偏移量 = Y2-Y1+Y\n3.  鼠标放开，状态=0\n\n#### 在线预览\n\n<p data-height=\"265\" data-theme-id=\"0\" data-slug-hash=\"oLVgvp\" data-default-tab=\"js,result\" data-user=\"abcdGJJ\" data-embed-version=\"2\" data-pen-title=\"oLVgvp\" class=\"codepen\">See the Pen <a href=\"https://codepen.io/abcdGJJ/pen/oLVgvp/\">oLVgvp</a> by abcdGJJ (<a href=\"https://codepen.io/abcdGJJ\">@abcdGJJ</a>) on <a href=\"https://codepen.io\">CodePen</a>.</p>\n<script async src=\"https://production-assets.codepen.io/assets/embed/ei.js\"></script>\n\n<!-- more -->\n\n#### 代码\n\n```javascript\n    var state = false;\n    var obj, objLeft, objTop, posX, posY,wrap;\n    window.onload = function() {\n        obj = document.getElementById('drop');\n        wrap = document.getElementById('wrap');\n        obj.onmousedown = down;\n        obj.onmousemove = move;\n        obj.onmouseup = up;\n    }\n    function down(e) {\n        obj.style.cursor = \"move\";\n        state = true;\n        objLeft = obj.offsetLeft;//obj左上角距离父节点左边距偏移像素值\n        objTop = obj.offsetTop;\n        posX = parseInt(getPostion(e).x);//鼠标位置\n        posY = parseInt(getPostion(e).y);\n    }\n    function move(e) {\n        if(state == true) {\n            var x = parseInt(getPostion(e).x - posX + objLeft);\n            var y = parseInt(getPostion(e).y - posY +objTop);\n            var w = parseInt(wrap.clientWidth - obj.offsetWidth);\n            var h = parseInt(wrap.clientHeight - obj.offsetHeight);\n            // console.log(x,y);\n            if(x < 0) {\n                x = 0;\n            } else if(x > w) {\n                x = w;\n            }\n            if(y < 0) {\n                y = 0;\n            } else if(y > h) {\n                y = h;\n            }\n            obj.style.left = x + 'px';\n            obj.style.top = y +'px';\n        }\n    }\n    function up() {\n        state = false;\n    }\n    function getPostion(e) {\n        var xpos, ypos;\n        e = e || window.event;//浏览器兼容\n        if(e.pageX) {\n            xpos = e.pageX;\n            ypos = e.pageY;\n        } else {\n            xpos = e.clientX + document.body.scrollLeft - document.body.clientLeft;\n            ypos = e.clientY + document.body.scrollTop - document.body.clientTop;\n        }\n        return {\n            x: xpos,\n            y: ypos\n        }\n    }\n```\n\n#### 面向对象版本版本：\n\n```javascript\nfunction Drag(config) {\n  this.target = document.getElementById(config.id) this.state = false\n  if (config.parentElementId) {\n    this.targetParent = document.getElementById(config.parentElementId)\n    this.maxLeft = parseInt(this.targetParent.clientWidth - this.target.clientWidth)\n    this.maxTop = parseInt(this.targetParent.clientHeight - this.target.clientHeight)\n  } else {\n    this.maxLeft = parseInt(document.documentElement.clientWidth - this.target.clientWidth) \n    this.maxTop = parseInt(document.documentElement.clientHeight - this.target.clientHeight)\n  }\n}\nDrag.prototype = {\n  constructor: Drag,\n  start: function() {\n    this.target.onmousedown = function(e) {\n      this.down(e)\n    }.bind(this)\n    //或\n    // var _this = this\n    // this.target.onmousedown = function(e) {\n    //     _this.down(e)\n    // }\n    this.target.onmousemove = function(e) {\n      this.move(e)\n    }.bind(this) this.target.onmouseup = function(e) {\n      this.up(e)\n    }.bind(this)\n  },\n  getPostion: function(e) {\n    var posX, posY e = e || window.event\n    if (e.pageX) {\n      posX = e.pageX posY = e.pageY\n    } else {\n      posX = e.clientX + document.body.scrollLeft - document.body.clientLeft\n      posY = e.clientY + document.body.scrollTop - document.body.clientTop\n    }\n    return {\n      x: posX,\n      y: posY\n    }\n  },\n  down: function(e) {\n    this.target.style.cursor = \"move\"\n    this.state = true\n    this.left = this.target.offsetLeft\n    this.top = this.target.offsetTop\n    this.posX = parseInt(this.getPostion(e).x)\n    this.posY = parseInt(this.getPostion(e).y)\n  },\n  move: function(e) {\n    if (this.state === true) {\n      var x = parseInt(this.getPostion(e).x - this.posX + this.left)\n      var y = parseInt(this.getPostion(e).y - this.posY + this.top) \n      if (x < 0) {\n        x = 0\n      } else if (x > this.maxLeft) {\n        x = this.maxLeft\n      }\n      if (y < 0) {\n        y = 0\n      } else if (y > this.maxTop) {\n        y = this.maxTop\n      }\n      this.target.style.left = x + 'px'this.target.style.top = y + 'px'\n    }\n  },\n  up: function(e) {\n    this.state = false\n    // this.target.onmousedown = null\n    // this.target.onmousemove = null\n  }\n}\n```","slug":"js-drag","published":1,"updated":"2018-05-03T11:23:18.843Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjhbjw6qh0008fx9mlz73630w","content":"<h4 id=\"原理\"><a href=\"#原理\" class=\"headerlink\" title=\"原理\"></a>原理</h4><ol>\n<li>鼠标按下：状态=1；记录鼠标的X和Y坐标；记录元素的X和Y偏移值</li>\n<li>鼠标在元素上移动：若状态=0，什么也不做；若状态为1，元素的新X的偏移量 = X2-X1+X(鼠标按下时的元素偏移)，新Y偏移量 = Y2-Y1+Y</li>\n<li>鼠标放开，状态=0</li>\n</ol>\n<h4 id=\"在线预览\"><a href=\"#在线预览\" class=\"headerlink\" title=\"在线预览\"></a>在线预览</h4><p></p><p data-height=\"265\" data-theme-id=\"0\" data-slug-hash=\"oLVgvp\" data-default-tab=\"js,result\" data-user=\"abcdGJJ\" data-embed-version=\"2\" data-pen-title=\"oLVgvp\" class=\"codepen\">See the Pen <a href=\"https://codepen.io/abcdGJJ/pen/oLVgvp/\" target=\"_blank\" rel=\"noopener\">oLVgvp</a> by abcdGJJ (<a href=\"https://codepen.io/abcdGJJ\" target=\"_blank\" rel=\"noopener\">@abcdGJJ</a>) on <a href=\"https://codepen.io\" target=\"_blank\" rel=\"noopener\">CodePen</a>.</p><p></p>\n<script async src=\"https://production-assets.codepen.io/assets/embed/ei.js\"></script>\n\n<a id=\"more\"></a>\n<h4 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> state = <span class=\"literal\">false</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> obj, objLeft, objTop, posX, posY,wrap;</span><br><span class=\"line\"><span class=\"built_in\">window</span>.onload = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    obj = <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">'drop'</span>);</span><br><span class=\"line\">    wrap = <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">'wrap'</span>);</span><br><span class=\"line\">    obj.onmousedown = down;</span><br><span class=\"line\">    obj.onmousemove = move;</span><br><span class=\"line\">    obj.onmouseup = up;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">down</span>(<span class=\"params\">e</span>) </span>&#123;</span><br><span class=\"line\">    obj.style.cursor = <span class=\"string\">\"move\"</span>;</span><br><span class=\"line\">    state = <span class=\"literal\">true</span>;</span><br><span class=\"line\">    objLeft = obj.offsetLeft;<span class=\"comment\">//obj左上角距离父节点左边距偏移像素值</span></span><br><span class=\"line\">    objTop = obj.offsetTop;</span><br><span class=\"line\">    posX = <span class=\"built_in\">parseInt</span>(getPostion(e).x);<span class=\"comment\">//鼠标位置</span></span><br><span class=\"line\">    posY = <span class=\"built_in\">parseInt</span>(getPostion(e).y);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">move</span>(<span class=\"params\">e</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(state == <span class=\"literal\">true</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> x = <span class=\"built_in\">parseInt</span>(getPostion(e).x - posX + objLeft);</span><br><span class=\"line\">        <span class=\"keyword\">var</span> y = <span class=\"built_in\">parseInt</span>(getPostion(e).y - posY +objTop);</span><br><span class=\"line\">        <span class=\"keyword\">var</span> w = <span class=\"built_in\">parseInt</span>(wrap.clientWidth - obj.offsetWidth);</span><br><span class=\"line\">        <span class=\"keyword\">var</span> h = <span class=\"built_in\">parseInt</span>(wrap.clientHeight - obj.offsetHeight);</span><br><span class=\"line\">        <span class=\"comment\">// console.log(x,y);</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(x &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            x = <span class=\"number\">0</span>;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(x &gt; w) &#123;</span><br><span class=\"line\">            x = w;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(y &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            y = <span class=\"number\">0</span>;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(y &gt; h) &#123;</span><br><span class=\"line\">            y = h;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        obj.style.left = x + <span class=\"string\">'px'</span>;</span><br><span class=\"line\">        obj.style.top = y +<span class=\"string\">'px'</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">up</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    state = <span class=\"literal\">false</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getPostion</span>(<span class=\"params\">e</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> xpos, ypos;</span><br><span class=\"line\">    e = e || <span class=\"built_in\">window</span>.event;<span class=\"comment\">//浏览器兼容</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(e.pageX) &#123;</span><br><span class=\"line\">        xpos = e.pageX;</span><br><span class=\"line\">        ypos = e.pageY;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        xpos = e.clientX + <span class=\"built_in\">document</span>.body.scrollLeft - <span class=\"built_in\">document</span>.body.clientLeft;</span><br><span class=\"line\">        ypos = e.clientY + <span class=\"built_in\">document</span>.body.scrollTop - <span class=\"built_in\">document</span>.body.clientTop;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">        x: xpos,</span><br><span class=\"line\">        y: ypos</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"面向对象版本版本：\"><a href=\"#面向对象版本版本：\" class=\"headerlink\" title=\"面向对象版本版本：\"></a>面向对象版本版本：</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Drag</span>(<span class=\"params\">config</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.target = <span class=\"built_in\">document</span>.getElementById(config.id) <span class=\"keyword\">this</span>.state = <span class=\"literal\">false</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (config.parentElementId) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.targetParent = <span class=\"built_in\">document</span>.getElementById(config.parentElementId)</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.maxLeft = <span class=\"built_in\">parseInt</span>(<span class=\"keyword\">this</span>.targetParent.clientWidth - <span class=\"keyword\">this</span>.target.clientWidth)</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.maxTop = <span class=\"built_in\">parseInt</span>(<span class=\"keyword\">this</span>.targetParent.clientHeight - <span class=\"keyword\">this</span>.target.clientHeight)</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.maxLeft = <span class=\"built_in\">parseInt</span>(<span class=\"built_in\">document</span>.documentElement.clientWidth - <span class=\"keyword\">this</span>.target.clientWidth) </span><br><span class=\"line\">    <span class=\"keyword\">this</span>.maxTop = <span class=\"built_in\">parseInt</span>(<span class=\"built_in\">document</span>.documentElement.clientHeight - <span class=\"keyword\">this</span>.target.clientHeight)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">Drag.prototype = &#123;</span><br><span class=\"line\">  <span class=\"keyword\">constructor</span>: Drag,</span><br><span class=\"line\">  start: function() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.target.onmousedown = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">e</span>) </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">this</span>.down(e)</span><br><span class=\"line\">    &#125;.bind(<span class=\"keyword\">this</span>)</span><br><span class=\"line\">    <span class=\"comment\">//或</span></span><br><span class=\"line\">    <span class=\"comment\">// var _this = this</span></span><br><span class=\"line\">    <span class=\"comment\">// this.target.onmousedown = function(e) &#123;</span></span><br><span class=\"line\">    <span class=\"comment\">//     _this.down(e)</span></span><br><span class=\"line\">    <span class=\"comment\">// &#125;</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.target.onmousemove = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">e</span>) </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">this</span>.move(e)</span><br><span class=\"line\">    &#125;.bind(<span class=\"keyword\">this</span>) <span class=\"keyword\">this</span>.target.onmouseup = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">e</span>) </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">this</span>.up(e)</span><br><span class=\"line\">    &#125;.bind(<span class=\"keyword\">this</span>)</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  getPostion: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">e</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> posX, posY e = e || <span class=\"built_in\">window</span>.event</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (e.pageX) &#123;</span><br><span class=\"line\">      posX = e.pageX posY = e.pageY</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      posX = e.clientX + <span class=\"built_in\">document</span>.body.scrollLeft - <span class=\"built_in\">document</span>.body.clientLeft</span><br><span class=\"line\">      posY = e.clientY + <span class=\"built_in\">document</span>.body.scrollTop - <span class=\"built_in\">document</span>.body.clientTop</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">      x: posX,</span><br><span class=\"line\">      y: posY</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  down: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">e</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.target.style.cursor = <span class=\"string\">\"move\"</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.state = <span class=\"literal\">true</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.left = <span class=\"keyword\">this</span>.target.offsetLeft</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.top = <span class=\"keyword\">this</span>.target.offsetTop</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.posX = <span class=\"built_in\">parseInt</span>(<span class=\"keyword\">this</span>.getPostion(e).x)</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.posY = <span class=\"built_in\">parseInt</span>(<span class=\"keyword\">this</span>.getPostion(e).y)</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  move: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">e</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.state === <span class=\"literal\">true</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">var</span> x = <span class=\"built_in\">parseInt</span>(<span class=\"keyword\">this</span>.getPostion(e).x - <span class=\"keyword\">this</span>.posX + <span class=\"keyword\">this</span>.left)</span><br><span class=\"line\">      <span class=\"keyword\">var</span> y = <span class=\"built_in\">parseInt</span>(<span class=\"keyword\">this</span>.getPostion(e).y - <span class=\"keyword\">this</span>.posY + <span class=\"keyword\">this</span>.top) </span><br><span class=\"line\">      <span class=\"keyword\">if</span> (x &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        x = <span class=\"number\">0</span></span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (x &gt; <span class=\"keyword\">this</span>.maxLeft) &#123;</span><br><span class=\"line\">        x = <span class=\"keyword\">this</span>.maxLeft</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (y &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        y = <span class=\"number\">0</span></span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (y &gt; <span class=\"keyword\">this</span>.maxTop) &#123;</span><br><span class=\"line\">        y = <span class=\"keyword\">this</span>.maxTop</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"keyword\">this</span>.target.style.left = x + <span class=\"string\">'px'</span><span class=\"keyword\">this</span>.target.style.top = y + <span class=\"string\">'px'</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  up: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">e</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.state = <span class=\"literal\">false</span></span><br><span class=\"line\">    <span class=\"comment\">// this.target.onmousedown = null</span></span><br><span class=\"line\">    <span class=\"comment\">// this.target.onmousemove = null</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"<h4 id=\"原理\"><a href=\"#原理\" class=\"headerlink\" title=\"原理\"></a>原理</h4><ol>\n<li>鼠标按下：状态=1；记录鼠标的X和Y坐标；记录元素的X和Y偏移值</li>\n<li>鼠标在元素上移动：若状态=0，什么也不做；若状态为1，元素的新X的偏移量 = X2-X1+X(鼠标按下时的元素偏移)，新Y偏移量 = Y2-Y1+Y</li>\n<li>鼠标放开，状态=0</li>\n</ol>\n<h4 id=\"在线预览\"><a href=\"#在线预览\" class=\"headerlink\" title=\"在线预览\"></a>在线预览</h4><p></p><p data-height=\"265\" data-theme-id=\"0\" data-slug-hash=\"oLVgvp\" data-default-tab=\"js,result\" data-user=\"abcdGJJ\" data-embed-version=\"2\" data-pen-title=\"oLVgvp\" class=\"codepen\">See the Pen <a href=\"https://codepen.io/abcdGJJ/pen/oLVgvp/\" target=\"_blank\" rel=\"noopener\">oLVgvp</a> by abcdGJJ (<a href=\"https://codepen.io/abcdGJJ\" target=\"_blank\" rel=\"noopener\">@abcdGJJ</a>) on <a href=\"https://codepen.io\" target=\"_blank\" rel=\"noopener\">CodePen</a>.</p><p></p>\n<script async src=\"https://production-assets.codepen.io/assets/embed/ei.js\"></script>","more":"<h4 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> state = <span class=\"literal\">false</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> obj, objLeft, objTop, posX, posY,wrap;</span><br><span class=\"line\"><span class=\"built_in\">window</span>.onload = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    obj = <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">'drop'</span>);</span><br><span class=\"line\">    wrap = <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">'wrap'</span>);</span><br><span class=\"line\">    obj.onmousedown = down;</span><br><span class=\"line\">    obj.onmousemove = move;</span><br><span class=\"line\">    obj.onmouseup = up;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">down</span>(<span class=\"params\">e</span>) </span>&#123;</span><br><span class=\"line\">    obj.style.cursor = <span class=\"string\">\"move\"</span>;</span><br><span class=\"line\">    state = <span class=\"literal\">true</span>;</span><br><span class=\"line\">    objLeft = obj.offsetLeft;<span class=\"comment\">//obj左上角距离父节点左边距偏移像素值</span></span><br><span class=\"line\">    objTop = obj.offsetTop;</span><br><span class=\"line\">    posX = <span class=\"built_in\">parseInt</span>(getPostion(e).x);<span class=\"comment\">//鼠标位置</span></span><br><span class=\"line\">    posY = <span class=\"built_in\">parseInt</span>(getPostion(e).y);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">move</span>(<span class=\"params\">e</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(state == <span class=\"literal\">true</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> x = <span class=\"built_in\">parseInt</span>(getPostion(e).x - posX + objLeft);</span><br><span class=\"line\">        <span class=\"keyword\">var</span> y = <span class=\"built_in\">parseInt</span>(getPostion(e).y - posY +objTop);</span><br><span class=\"line\">        <span class=\"keyword\">var</span> w = <span class=\"built_in\">parseInt</span>(wrap.clientWidth - obj.offsetWidth);</span><br><span class=\"line\">        <span class=\"keyword\">var</span> h = <span class=\"built_in\">parseInt</span>(wrap.clientHeight - obj.offsetHeight);</span><br><span class=\"line\">        <span class=\"comment\">// console.log(x,y);</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(x &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            x = <span class=\"number\">0</span>;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(x &gt; w) &#123;</span><br><span class=\"line\">            x = w;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(y &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            y = <span class=\"number\">0</span>;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(y &gt; h) &#123;</span><br><span class=\"line\">            y = h;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        obj.style.left = x + <span class=\"string\">'px'</span>;</span><br><span class=\"line\">        obj.style.top = y +<span class=\"string\">'px'</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">up</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    state = <span class=\"literal\">false</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getPostion</span>(<span class=\"params\">e</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> xpos, ypos;</span><br><span class=\"line\">    e = e || <span class=\"built_in\">window</span>.event;<span class=\"comment\">//浏览器兼容</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(e.pageX) &#123;</span><br><span class=\"line\">        xpos = e.pageX;</span><br><span class=\"line\">        ypos = e.pageY;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        xpos = e.clientX + <span class=\"built_in\">document</span>.body.scrollLeft - <span class=\"built_in\">document</span>.body.clientLeft;</span><br><span class=\"line\">        ypos = e.clientY + <span class=\"built_in\">document</span>.body.scrollTop - <span class=\"built_in\">document</span>.body.clientTop;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">        x: xpos,</span><br><span class=\"line\">        y: ypos</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"面向对象版本版本：\"><a href=\"#面向对象版本版本：\" class=\"headerlink\" title=\"面向对象版本版本：\"></a>面向对象版本版本：</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Drag</span>(<span class=\"params\">config</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.target = <span class=\"built_in\">document</span>.getElementById(config.id) <span class=\"keyword\">this</span>.state = <span class=\"literal\">false</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (config.parentElementId) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.targetParent = <span class=\"built_in\">document</span>.getElementById(config.parentElementId)</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.maxLeft = <span class=\"built_in\">parseInt</span>(<span class=\"keyword\">this</span>.targetParent.clientWidth - <span class=\"keyword\">this</span>.target.clientWidth)</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.maxTop = <span class=\"built_in\">parseInt</span>(<span class=\"keyword\">this</span>.targetParent.clientHeight - <span class=\"keyword\">this</span>.target.clientHeight)</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.maxLeft = <span class=\"built_in\">parseInt</span>(<span class=\"built_in\">document</span>.documentElement.clientWidth - <span class=\"keyword\">this</span>.target.clientWidth) </span><br><span class=\"line\">    <span class=\"keyword\">this</span>.maxTop = <span class=\"built_in\">parseInt</span>(<span class=\"built_in\">document</span>.documentElement.clientHeight - <span class=\"keyword\">this</span>.target.clientHeight)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">Drag.prototype = &#123;</span><br><span class=\"line\">  <span class=\"keyword\">constructor</span>: Drag,</span><br><span class=\"line\">  start: function() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.target.onmousedown = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">e</span>) </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">this</span>.down(e)</span><br><span class=\"line\">    &#125;.bind(<span class=\"keyword\">this</span>)</span><br><span class=\"line\">    <span class=\"comment\">//或</span></span><br><span class=\"line\">    <span class=\"comment\">// var _this = this</span></span><br><span class=\"line\">    <span class=\"comment\">// this.target.onmousedown = function(e) &#123;</span></span><br><span class=\"line\">    <span class=\"comment\">//     _this.down(e)</span></span><br><span class=\"line\">    <span class=\"comment\">// &#125;</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.target.onmousemove = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">e</span>) </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">this</span>.move(e)</span><br><span class=\"line\">    &#125;.bind(<span class=\"keyword\">this</span>) <span class=\"keyword\">this</span>.target.onmouseup = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">e</span>) </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">this</span>.up(e)</span><br><span class=\"line\">    &#125;.bind(<span class=\"keyword\">this</span>)</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  getPostion: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">e</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> posX, posY e = e || <span class=\"built_in\">window</span>.event</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (e.pageX) &#123;</span><br><span class=\"line\">      posX = e.pageX posY = e.pageY</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      posX = e.clientX + <span class=\"built_in\">document</span>.body.scrollLeft - <span class=\"built_in\">document</span>.body.clientLeft</span><br><span class=\"line\">      posY = e.clientY + <span class=\"built_in\">document</span>.body.scrollTop - <span class=\"built_in\">document</span>.body.clientTop</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">      x: posX,</span><br><span class=\"line\">      y: posY</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  down: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">e</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.target.style.cursor = <span class=\"string\">\"move\"</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.state = <span class=\"literal\">true</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.left = <span class=\"keyword\">this</span>.target.offsetLeft</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.top = <span class=\"keyword\">this</span>.target.offsetTop</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.posX = <span class=\"built_in\">parseInt</span>(<span class=\"keyword\">this</span>.getPostion(e).x)</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.posY = <span class=\"built_in\">parseInt</span>(<span class=\"keyword\">this</span>.getPostion(e).y)</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  move: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">e</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.state === <span class=\"literal\">true</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">var</span> x = <span class=\"built_in\">parseInt</span>(<span class=\"keyword\">this</span>.getPostion(e).x - <span class=\"keyword\">this</span>.posX + <span class=\"keyword\">this</span>.left)</span><br><span class=\"line\">      <span class=\"keyword\">var</span> y = <span class=\"built_in\">parseInt</span>(<span class=\"keyword\">this</span>.getPostion(e).y - <span class=\"keyword\">this</span>.posY + <span class=\"keyword\">this</span>.top) </span><br><span class=\"line\">      <span class=\"keyword\">if</span> (x &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        x = <span class=\"number\">0</span></span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (x &gt; <span class=\"keyword\">this</span>.maxLeft) &#123;</span><br><span class=\"line\">        x = <span class=\"keyword\">this</span>.maxLeft</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (y &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        y = <span class=\"number\">0</span></span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (y &gt; <span class=\"keyword\">this</span>.maxTop) &#123;</span><br><span class=\"line\">        y = <span class=\"keyword\">this</span>.maxTop</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"keyword\">this</span>.target.style.left = x + <span class=\"string\">'px'</span><span class=\"keyword\">this</span>.target.style.top = y + <span class=\"string\">'px'</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  up: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">e</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.state = <span class=\"literal\">false</span></span><br><span class=\"line\">    <span class=\"comment\">// this.target.onmousedown = null</span></span><br><span class=\"line\">    <span class=\"comment\">// this.target.onmousemove = null</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>"},{"title":"前端路由的实现","date":"2018-05-05T08:57:51.000Z","_content":"\n#### 前言\n&emsp;&emsp;前端路由是现代SPA应用必备的功能,每个现代前端框架都有对应的实现,例如vue-router、react-router。\n\n我们不想探究vue-router或者react-router们的实现，因为不管是哪种路由无外乎用兼容性更好的hash实现或者是H5 History实现，与框架几个只需要做相应的封装即可。\n\n>  提前声明: 我们没有对传入的参数进行及时判断而规避错误,也没有考虑兼容性问题,仅仅对核心方法进行了实现.\n\n<!-- more -->\n***\n#### 1.hash路由\nhash路由一个明显的标志是带有`#`,我们主要是通过监听url中的hash变化来进行路由跳转。\n\nhash的优势就是兼容性更好,在老版IE中都有运行,问题在于url中一直存在`#`不够美观,而且hash路由更像是Hack而非标准,相信随着发展更加标准化的History API会逐步蚕食掉hash路由的市场。\n##### 1.1 初始化class\n我们用`Class`关键字初始化一个路由.\n```javascript\nclass Routers {\n  constructor() {\n    // 以键值对的形式储存路由\n    this.routes = {};\n    // 当前路由的URL\n    this.currentUrl = '';\n  }\n}\n```\n##### 1.2 实现路由hash储存与执行\n在初始化完毕后我们需要思考两个问题:\n\n1. 将路由的hash以及对应的callback函数储存\n2. 触发路由hash变化后,执行对应的callback函数\n\n```javascript\nclass Routers {\n  constructor() {\n    this.routes = {};\n    this.currentUrl = '';\n  }\n  // 将path路径与对应的callback函数储存\n  route(path, callback) {\n    this.routes[path] = callback || function() {};\n  }\n  // 刷新\n  refresh() {\n    // 获取当前URL中的hash路径\n    this.currentUrl = location.hash.slice(1) || '/';\n    // 执行当前hash路径的callback函数\n    this.routes[this.currentUrl]();\n  }\n}\n```\n##### 1.3 监听对应事件\n那么我们只需要在实例化Class的时候监听上面的事件即可.\n```javascript\nclass Routers {\n  constructor() {\n    this.routes = {};\n    this.currentUrl = '';\n    this.refresh = this.refresh.bind(this);\n    window.addEventListener('load', this.refresh, false);\n    window.addEventListener('hashchange', this.refresh, false);\n  }\n\n  route(path, callback) {\n    this.routes[path] = callback || function() {};\n  }\n\n  refresh() {\n    this.currentUrl = location.hash.slice(1) || '/';\n    this.routes[this.currentUrl]();\n  }\n}\n```\n\n#### 2.增加回退功能\n上一节我们只实现了简单的路由功能,没有我们常用的回退与前进功能,所以我们需要进行改造。\n##### 2.1 实现后退功能\n我们在需要创建一个数组`history`来储存过往的hash路由例如`/blue`,并且创建一个指针`currentIndex`来随着后退和前进功能移动来指向不同的hash路由。\n```javascript\nclass Routers {\n  constructor() {\n    // 储存hash与callback键值对\n    this.routes = {};\n    // 当前hash\n    this.currentUrl = '';\n    // 记录出现过的hash\n    this.history = [];\n    // 作为指针,默认指向this.history的末尾,根据后退前进指向history中不同的hash\n    this.currentIndex = this.history.length - 1;\n    this.refresh = this.refresh.bind(this);\n    this.backOff = this.backOff.bind(this);\n    window.addEventListener('load', this.refresh, false);\n    window.addEventListener('hashchange', this.refresh, false);\n  }\n\n  route(path, callback) {\n    this.routes[path] = callback || function() {};\n  }\n\n  refresh() {\n    this.currentUrl = location.hash.slice(1) || '/';\n    // 将当前hash路由推入数组储存\n    this.history.push(this.currentUrl);\n    // 指针向前移动\n    this.currentIndex++;\n    this.routes[this.currentUrl]();\n  }\n  // 后退功能\n  backOff() {\n    // 如果指针小于0的话就不存在对应hash路由了,因此锁定指针为0即可\n    this.currentIndex <= 0\n      ? (this.currentIndex = 0)\n      : (this.currentIndex = this.currentIndex - 1);\n    // 随着后退,location.hash也应该随之变化\n    location.hash = `#${this.history[this.currentIndex]}`;\n    // 执行指针目前指向hash路由对应的callback\n    this.routes[this.history[this.currentIndex]]();\n  }\n}\n```\n我们看起来实现的不错,可是出现了Bug,在后退的时候我们往往需要点击两下。\n\n问题在于,我们每次在后退都会执行相应的`callback`,这会触发`refresh()`执行,因此每次我们后退,`history`中都会被`push`新的路由`hash`,`currentIndex`也会向前移动,这显然不是我们想要的。\n\n```javascript\nrefresh() {\n    this.currentUrl = location.hash.slice(1) || '/';\n    // 将当前hash路由推入数组储存\n    this.history.push(this.currentUrl);\n    // 指针向前移动\n    this.currentIndex++;\n    this.routes[this.currentUrl]();\n  }\n```\n##### 2.2 完整实现hash Router\n我们必须做一个判断,如果是后退的话,我们只需要执行回调函数,不需要添加数组和移动指针。\n```javascript\nclass Routers {\n  constructor() {\n    // 储存hash与callback键值对\n    this.routes = {};\n    // 当前hash\n    this.currentUrl = '';\n    // 记录出现过的hash\n    this.history = [];\n    // 作为指针,默认指向this.history的末尾,根据后退前进指向history中不同的hash\n    this.currentIndex = this.history.length - 1;\n    this.refresh = this.refresh.bind(this);\n    this.backOff = this.backOff.bind(this);\n    // 默认不是后退操作\n    this.isBack = false;\n    window.addEventListener('load', this.refresh, false);\n    window.addEventListener('hashchange', this.refresh, false);\n  }\n\n  route(path, callback) {\n    this.routes[path] = callback || function() {};\n  }\n\n  refresh() {\n    this.currentUrl = location.hash.slice(1) || '/';\n    if (!this.isBack) {\n      // 如果不是后退操作,且当前指针小于数组总长度,直接截取指针之前的部分储存下来\n      // 此操作来避免当点击后退按钮之后,再进行正常跳转,指针会停留在原地,而数组添加新hash路由\n      // 避免再次造成指针的不匹配,我们直接截取指针之前的数组\n      // 此操作同时与浏览器自带后退功能的行为保持一致\n      if (this.currentIndex < this.history.length - 1)\n        this.history = this.history.slice(0, this.currentIndex + 1);\n      this.history.push(this.currentUrl);\n      this.currentIndex++;\n    }\n    this.routes[this.currentUrl]();\n    console.log('指针:', this.currentIndex, 'history:', this.history);\n    this.isBack = false;\n  }\n  // 后退功能\n  backOff() {\n    // 后退操作设置为true\n    this.isBack = true;\n    this.currentIndex <= 0\n      ? (this.currentIndex = 0)\n      : (this.currentIndex = this.currentIndex - 1);\n    location.hash = `#${this.history[this.currentIndex]}`;\n    this.routes[this.history[this.currentIndex]]();\n  }\n}\n```\n前进的部分就不实现了,思路我们已经讲得比较清楚了,可以看出来,hash路由这种方式确实有点繁琐,所以HTML5标准提供了History API供我们使用。\n#### 3. HTML5新路由方案\n##### 3.1 History API\n我们只简单看一下history常用的三个API.\n```javascript\nwindow.history.back();       // 后退\nwindow.history.forward();    // 前进\nwindow.history.go(-3);       // 后退三个页面\n```\n`history.pushState`用于在浏览历史中添加历史记录,但是并不触发跳转,此方法接受三个参数，依次为：\n> `state`:一个与指定网址相关的状态对象，`popstate`事件触发时，该对象会传入回调函数。如果不需要这个对象，此处可以填`null`。\n> `title`：新页面的标题，但是所有浏览器目前都忽略这个值，因此这里可以填null。\n> `url`：新的网址，必须与当前页面处在同一个域。浏览器的地址栏将显示这个网址。\n\n`history.replaceState`方法的参数与`pushState`方法一模一样，区别是它修改浏览历史中当前纪录,而非添加记录,同样不触发跳转。\n\n`popstate`事件,每当同一个文档的浏览历史（即`history`对象）出现变化时，就会触发`popstate`事件。\n\n需要注意的是，仅仅调用`pushState`方法或`replaceState`方法 ，并不会触发该事件，只有用户点击浏览器倒退按钮和前进按钮，或者使用 `JavaScript` 调用`back`、`forward`、`go`方法时才会触发。\n\n另外，该事件只针对同一个文档，如果浏览历史的切换，导致加载不同的文档，该事件也不会触发。\n\n##### 3.2 新标准下路由的实现\n上一节我们介绍了新标准的History API,相比于我们在Hash 路由实现的那些操作,很显然新标准让我们的实现更加方便和可读。\n\n所以一个mini路由实现起来其实很简单\n```javascript\nclass Routers {\n  constructor() {\n    this.routes = {};\n    // 在初始化时监听popstate事件\n    this._bindPopState();\n  }\n  // 初始化路由\n  init(path) {\n    history.replaceState({path: path}, null, path);\n    this.routes[path] && this.routes[path]();\n  }\n  // 将路径和对应回调函数加入hashMap储存\n  route(path, callback) {\n    this.routes[path] = callback || function() {};\n  }\n\n  // 触发路由对应回调\n  go(path) {\n    history.pushState({path: path}, null, path);\n    this.routes[path] && this.routes[path]();\n  }\n  // 监听popstate事件\n  _bindPopState() {\n    window.addEventListener('popstate', e => {\n      const path = e.state && e.state.path;\n      this.routes[path] && this.routes[path]();\n    });\n  }\n}\n```\n点击查看H5路由 [H5 Router](https://codepen.io/experor-xxy/pen/RyjXEX)\n\n小结\n我们大致探究了前端路由的两种实现方法,在没有兼容性要求的情况下显然符合标准的History API实现的路由是更好的选择。\n\n想更深入了解前端路由实现可以阅读[vue-router](https://github.com/vuejs/vue-router/blob/dev/src/index.js)代码，除去开发模式代码、注释和类型检测代码，核心代码并不多，适合阅读。","source":"_posts/js-实现路由.md","raw":"---\ntitle: 前端路由的实现\ndate: 2018-05-05 16:57:51\ntags:\n    - route\ncategories:\n    - 面试题\n    - vue\n---\n\n#### 前言\n&emsp;&emsp;前端路由是现代SPA应用必备的功能,每个现代前端框架都有对应的实现,例如vue-router、react-router。\n\n我们不想探究vue-router或者react-router们的实现，因为不管是哪种路由无外乎用兼容性更好的hash实现或者是H5 History实现，与框架几个只需要做相应的封装即可。\n\n>  提前声明: 我们没有对传入的参数进行及时判断而规避错误,也没有考虑兼容性问题,仅仅对核心方法进行了实现.\n\n<!-- more -->\n***\n#### 1.hash路由\nhash路由一个明显的标志是带有`#`,我们主要是通过监听url中的hash变化来进行路由跳转。\n\nhash的优势就是兼容性更好,在老版IE中都有运行,问题在于url中一直存在`#`不够美观,而且hash路由更像是Hack而非标准,相信随着发展更加标准化的History API会逐步蚕食掉hash路由的市场。\n##### 1.1 初始化class\n我们用`Class`关键字初始化一个路由.\n```javascript\nclass Routers {\n  constructor() {\n    // 以键值对的形式储存路由\n    this.routes = {};\n    // 当前路由的URL\n    this.currentUrl = '';\n  }\n}\n```\n##### 1.2 实现路由hash储存与执行\n在初始化完毕后我们需要思考两个问题:\n\n1. 将路由的hash以及对应的callback函数储存\n2. 触发路由hash变化后,执行对应的callback函数\n\n```javascript\nclass Routers {\n  constructor() {\n    this.routes = {};\n    this.currentUrl = '';\n  }\n  // 将path路径与对应的callback函数储存\n  route(path, callback) {\n    this.routes[path] = callback || function() {};\n  }\n  // 刷新\n  refresh() {\n    // 获取当前URL中的hash路径\n    this.currentUrl = location.hash.slice(1) || '/';\n    // 执行当前hash路径的callback函数\n    this.routes[this.currentUrl]();\n  }\n}\n```\n##### 1.3 监听对应事件\n那么我们只需要在实例化Class的时候监听上面的事件即可.\n```javascript\nclass Routers {\n  constructor() {\n    this.routes = {};\n    this.currentUrl = '';\n    this.refresh = this.refresh.bind(this);\n    window.addEventListener('load', this.refresh, false);\n    window.addEventListener('hashchange', this.refresh, false);\n  }\n\n  route(path, callback) {\n    this.routes[path] = callback || function() {};\n  }\n\n  refresh() {\n    this.currentUrl = location.hash.slice(1) || '/';\n    this.routes[this.currentUrl]();\n  }\n}\n```\n\n#### 2.增加回退功能\n上一节我们只实现了简单的路由功能,没有我们常用的回退与前进功能,所以我们需要进行改造。\n##### 2.1 实现后退功能\n我们在需要创建一个数组`history`来储存过往的hash路由例如`/blue`,并且创建一个指针`currentIndex`来随着后退和前进功能移动来指向不同的hash路由。\n```javascript\nclass Routers {\n  constructor() {\n    // 储存hash与callback键值对\n    this.routes = {};\n    // 当前hash\n    this.currentUrl = '';\n    // 记录出现过的hash\n    this.history = [];\n    // 作为指针,默认指向this.history的末尾,根据后退前进指向history中不同的hash\n    this.currentIndex = this.history.length - 1;\n    this.refresh = this.refresh.bind(this);\n    this.backOff = this.backOff.bind(this);\n    window.addEventListener('load', this.refresh, false);\n    window.addEventListener('hashchange', this.refresh, false);\n  }\n\n  route(path, callback) {\n    this.routes[path] = callback || function() {};\n  }\n\n  refresh() {\n    this.currentUrl = location.hash.slice(1) || '/';\n    // 将当前hash路由推入数组储存\n    this.history.push(this.currentUrl);\n    // 指针向前移动\n    this.currentIndex++;\n    this.routes[this.currentUrl]();\n  }\n  // 后退功能\n  backOff() {\n    // 如果指针小于0的话就不存在对应hash路由了,因此锁定指针为0即可\n    this.currentIndex <= 0\n      ? (this.currentIndex = 0)\n      : (this.currentIndex = this.currentIndex - 1);\n    // 随着后退,location.hash也应该随之变化\n    location.hash = `#${this.history[this.currentIndex]}`;\n    // 执行指针目前指向hash路由对应的callback\n    this.routes[this.history[this.currentIndex]]();\n  }\n}\n```\n我们看起来实现的不错,可是出现了Bug,在后退的时候我们往往需要点击两下。\n\n问题在于,我们每次在后退都会执行相应的`callback`,这会触发`refresh()`执行,因此每次我们后退,`history`中都会被`push`新的路由`hash`,`currentIndex`也会向前移动,这显然不是我们想要的。\n\n```javascript\nrefresh() {\n    this.currentUrl = location.hash.slice(1) || '/';\n    // 将当前hash路由推入数组储存\n    this.history.push(this.currentUrl);\n    // 指针向前移动\n    this.currentIndex++;\n    this.routes[this.currentUrl]();\n  }\n```\n##### 2.2 完整实现hash Router\n我们必须做一个判断,如果是后退的话,我们只需要执行回调函数,不需要添加数组和移动指针。\n```javascript\nclass Routers {\n  constructor() {\n    // 储存hash与callback键值对\n    this.routes = {};\n    // 当前hash\n    this.currentUrl = '';\n    // 记录出现过的hash\n    this.history = [];\n    // 作为指针,默认指向this.history的末尾,根据后退前进指向history中不同的hash\n    this.currentIndex = this.history.length - 1;\n    this.refresh = this.refresh.bind(this);\n    this.backOff = this.backOff.bind(this);\n    // 默认不是后退操作\n    this.isBack = false;\n    window.addEventListener('load', this.refresh, false);\n    window.addEventListener('hashchange', this.refresh, false);\n  }\n\n  route(path, callback) {\n    this.routes[path] = callback || function() {};\n  }\n\n  refresh() {\n    this.currentUrl = location.hash.slice(1) || '/';\n    if (!this.isBack) {\n      // 如果不是后退操作,且当前指针小于数组总长度,直接截取指针之前的部分储存下来\n      // 此操作来避免当点击后退按钮之后,再进行正常跳转,指针会停留在原地,而数组添加新hash路由\n      // 避免再次造成指针的不匹配,我们直接截取指针之前的数组\n      // 此操作同时与浏览器自带后退功能的行为保持一致\n      if (this.currentIndex < this.history.length - 1)\n        this.history = this.history.slice(0, this.currentIndex + 1);\n      this.history.push(this.currentUrl);\n      this.currentIndex++;\n    }\n    this.routes[this.currentUrl]();\n    console.log('指针:', this.currentIndex, 'history:', this.history);\n    this.isBack = false;\n  }\n  // 后退功能\n  backOff() {\n    // 后退操作设置为true\n    this.isBack = true;\n    this.currentIndex <= 0\n      ? (this.currentIndex = 0)\n      : (this.currentIndex = this.currentIndex - 1);\n    location.hash = `#${this.history[this.currentIndex]}`;\n    this.routes[this.history[this.currentIndex]]();\n  }\n}\n```\n前进的部分就不实现了,思路我们已经讲得比较清楚了,可以看出来,hash路由这种方式确实有点繁琐,所以HTML5标准提供了History API供我们使用。\n#### 3. HTML5新路由方案\n##### 3.1 History API\n我们只简单看一下history常用的三个API.\n```javascript\nwindow.history.back();       // 后退\nwindow.history.forward();    // 前进\nwindow.history.go(-3);       // 后退三个页面\n```\n`history.pushState`用于在浏览历史中添加历史记录,但是并不触发跳转,此方法接受三个参数，依次为：\n> `state`:一个与指定网址相关的状态对象，`popstate`事件触发时，该对象会传入回调函数。如果不需要这个对象，此处可以填`null`。\n> `title`：新页面的标题，但是所有浏览器目前都忽略这个值，因此这里可以填null。\n> `url`：新的网址，必须与当前页面处在同一个域。浏览器的地址栏将显示这个网址。\n\n`history.replaceState`方法的参数与`pushState`方法一模一样，区别是它修改浏览历史中当前纪录,而非添加记录,同样不触发跳转。\n\n`popstate`事件,每当同一个文档的浏览历史（即`history`对象）出现变化时，就会触发`popstate`事件。\n\n需要注意的是，仅仅调用`pushState`方法或`replaceState`方法 ，并不会触发该事件，只有用户点击浏览器倒退按钮和前进按钮，或者使用 `JavaScript` 调用`back`、`forward`、`go`方法时才会触发。\n\n另外，该事件只针对同一个文档，如果浏览历史的切换，导致加载不同的文档，该事件也不会触发。\n\n##### 3.2 新标准下路由的实现\n上一节我们介绍了新标准的History API,相比于我们在Hash 路由实现的那些操作,很显然新标准让我们的实现更加方便和可读。\n\n所以一个mini路由实现起来其实很简单\n```javascript\nclass Routers {\n  constructor() {\n    this.routes = {};\n    // 在初始化时监听popstate事件\n    this._bindPopState();\n  }\n  // 初始化路由\n  init(path) {\n    history.replaceState({path: path}, null, path);\n    this.routes[path] && this.routes[path]();\n  }\n  // 将路径和对应回调函数加入hashMap储存\n  route(path, callback) {\n    this.routes[path] = callback || function() {};\n  }\n\n  // 触发路由对应回调\n  go(path) {\n    history.pushState({path: path}, null, path);\n    this.routes[path] && this.routes[path]();\n  }\n  // 监听popstate事件\n  _bindPopState() {\n    window.addEventListener('popstate', e => {\n      const path = e.state && e.state.path;\n      this.routes[path] && this.routes[path]();\n    });\n  }\n}\n```\n点击查看H5路由 [H5 Router](https://codepen.io/experor-xxy/pen/RyjXEX)\n\n小结\n我们大致探究了前端路由的两种实现方法,在没有兼容性要求的情况下显然符合标准的History API实现的路由是更好的选择。\n\n想更深入了解前端路由实现可以阅读[vue-router](https://github.com/vuejs/vue-router/blob/dev/src/index.js)代码，除去开发模式代码、注释和类型检测代码，核心代码并不多，适合阅读。","slug":"js-实现路由","published":1,"updated":"2018-05-08T02:59:28.786Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjhbjw6qk000cfx9m5jybcra7","content":"<h4 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h4><p>&emsp;&emsp;前端路由是现代SPA应用必备的功能,每个现代前端框架都有对应的实现,例如vue-router、react-router。</p>\n<p>我们不想探究vue-router或者react-router们的实现，因为不管是哪种路由无外乎用兼容性更好的hash实现或者是H5 History实现，与框架几个只需要做相应的封装即可。</p>\n<blockquote>\n<p> 提前声明: 我们没有对传入的参数进行及时判断而规避错误,也没有考虑兼容性问题,仅仅对核心方法进行了实现.</p>\n</blockquote>\n<a id=\"more\"></a>\n<hr>\n<h4 id=\"1-hash路由\"><a href=\"#1-hash路由\" class=\"headerlink\" title=\"1.hash路由\"></a>1.hash路由</h4><p>hash路由一个明显的标志是带有<code>#</code>,我们主要是通过监听url中的hash变化来进行路由跳转。</p>\n<p>hash的优势就是兼容性更好,在老版IE中都有运行,问题在于url中一直存在<code>#</code>不够美观,而且hash路由更像是Hack而非标准,相信随着发展更加标准化的History API会逐步蚕食掉hash路由的市场。</p>\n<h5 id=\"1-1-初始化class\"><a href=\"#1-1-初始化class\" class=\"headerlink\" title=\"1.1 初始化class\"></a>1.1 初始化class</h5><p>我们用<code>Class</code>关键字初始化一个路由.<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Routers</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">constructor</span>() &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 以键值对的形式储存路由</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.routes = &#123;&#125;;</span><br><span class=\"line\">    <span class=\"comment\">// 当前路由的URL</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.currentUrl = <span class=\"string\">''</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h5 id=\"1-2-实现路由hash储存与执行\"><a href=\"#1-2-实现路由hash储存与执行\" class=\"headerlink\" title=\"1.2 实现路由hash储存与执行\"></a>1.2 实现路由hash储存与执行</h5><p>在初始化完毕后我们需要思考两个问题:</p>\n<ol>\n<li>将路由的hash以及对应的callback函数储存</li>\n<li>触发路由hash变化后,执行对应的callback函数</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Routers</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">constructor</span>() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.routes = &#123;&#125;;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.currentUrl = <span class=\"string\">''</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 将path路径与对应的callback函数储存</span></span><br><span class=\"line\">  route(path, callback) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.routes[path] = callback || <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;&#125;;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 刷新</span></span><br><span class=\"line\">  refresh() &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 获取当前URL中的hash路径</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.currentUrl = location.hash.slice(<span class=\"number\">1</span>) || <span class=\"string\">'/'</span>;</span><br><span class=\"line\">    <span class=\"comment\">// 执行当前hash路径的callback函数</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.routes[<span class=\"keyword\">this</span>.currentUrl]();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h5 id=\"1-3-监听对应事件\"><a href=\"#1-3-监听对应事件\" class=\"headerlink\" title=\"1.3 监听对应事件\"></a>1.3 监听对应事件</h5><p>那么我们只需要在实例化Class的时候监听上面的事件即可.<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Routers</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">constructor</span>() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.routes = &#123;&#125;;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.currentUrl = <span class=\"string\">''</span>;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.refresh = <span class=\"keyword\">this</span>.refresh.bind(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">    <span class=\"built_in\">window</span>.addEventListener(<span class=\"string\">'load'</span>, <span class=\"keyword\">this</span>.refresh, <span class=\"literal\">false</span>);</span><br><span class=\"line\">    <span class=\"built_in\">window</span>.addEventListener(<span class=\"string\">'hashchange'</span>, <span class=\"keyword\">this</span>.refresh, <span class=\"literal\">false</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  route(path, callback) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.routes[path] = callback || <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;&#125;;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  refresh() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.currentUrl = location.hash.slice(<span class=\"number\">1</span>) || <span class=\"string\">'/'</span>;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.routes[<span class=\"keyword\">this</span>.currentUrl]();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"2-增加回退功能\"><a href=\"#2-增加回退功能\" class=\"headerlink\" title=\"2.增加回退功能\"></a>2.增加回退功能</h4><p>上一节我们只实现了简单的路由功能,没有我们常用的回退与前进功能,所以我们需要进行改造。</p>\n<h5 id=\"2-1-实现后退功能\"><a href=\"#2-1-实现后退功能\" class=\"headerlink\" title=\"2.1 实现后退功能\"></a>2.1 实现后退功能</h5><p>我们在需要创建一个数组<code>history</code>来储存过往的hash路由例如<code>/blue</code>,并且创建一个指针<code>currentIndex</code>来随着后退和前进功能移动来指向不同的hash路由。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Routers</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">constructor</span>() &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 储存hash与callback键值对</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.routes = &#123;&#125;;</span><br><span class=\"line\">    <span class=\"comment\">// 当前hash</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.currentUrl = <span class=\"string\">''</span>;</span><br><span class=\"line\">    <span class=\"comment\">// 记录出现过的hash</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.history = [];</span><br><span class=\"line\">    <span class=\"comment\">// 作为指针,默认指向this.history的末尾,根据后退前进指向history中不同的hash</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.currentIndex = <span class=\"keyword\">this</span>.history.length - <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.refresh = <span class=\"keyword\">this</span>.refresh.bind(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.backOff = <span class=\"keyword\">this</span>.backOff.bind(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">    <span class=\"built_in\">window</span>.addEventListener(<span class=\"string\">'load'</span>, <span class=\"keyword\">this</span>.refresh, <span class=\"literal\">false</span>);</span><br><span class=\"line\">    <span class=\"built_in\">window</span>.addEventListener(<span class=\"string\">'hashchange'</span>, <span class=\"keyword\">this</span>.refresh, <span class=\"literal\">false</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  route(path, callback) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.routes[path] = callback || <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;&#125;;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  refresh() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.currentUrl = location.hash.slice(<span class=\"number\">1</span>) || <span class=\"string\">'/'</span>;</span><br><span class=\"line\">    <span class=\"comment\">// 将当前hash路由推入数组储存</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.history.push(<span class=\"keyword\">this</span>.currentUrl);</span><br><span class=\"line\">    <span class=\"comment\">// 指针向前移动</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.currentIndex++;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.routes[<span class=\"keyword\">this</span>.currentUrl]();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 后退功能</span></span><br><span class=\"line\">  backOff() &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 如果指针小于0的话就不存在对应hash路由了,因此锁定指针为0即可</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.currentIndex &lt;= <span class=\"number\">0</span></span><br><span class=\"line\">      ? (<span class=\"keyword\">this</span>.currentIndex = <span class=\"number\">0</span>)</span><br><span class=\"line\">      : (<span class=\"keyword\">this</span>.currentIndex = <span class=\"keyword\">this</span>.currentIndex - <span class=\"number\">1</span>);</span><br><span class=\"line\">    <span class=\"comment\">// 随着后退,location.hash也应该随之变化</span></span><br><span class=\"line\">    location.hash = <span class=\"string\">`#<span class=\"subst\">$&#123;<span class=\"keyword\">this</span>.history[<span class=\"keyword\">this</span>.currentIndex]&#125;</span>`</span>;</span><br><span class=\"line\">    <span class=\"comment\">// 执行指针目前指向hash路由对应的callback</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.routes[<span class=\"keyword\">this</span>.history[<span class=\"keyword\">this</span>.currentIndex]]();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>我们看起来实现的不错,可是出现了Bug,在后退的时候我们往往需要点击两下。</p>\n<p>问题在于,我们每次在后退都会执行相应的<code>callback</code>,这会触发<code>refresh()</code>执行,因此每次我们后退,<code>history</code>中都会被<code>push</code>新的路由<code>hash</code>,<code>currentIndex</code>也会向前移动,这显然不是我们想要的。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">refresh() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.currentUrl = location.hash.slice(<span class=\"number\">1</span>) || <span class=\"string\">'/'</span>;</span><br><span class=\"line\">    <span class=\"comment\">// 将当前hash路由推入数组储存</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.history.push(<span class=\"keyword\">this</span>.currentUrl);</span><br><span class=\"line\">    <span class=\"comment\">// 指针向前移动</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.currentIndex++;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.routes[<span class=\"keyword\">this</span>.currentUrl]();</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n<h5 id=\"2-2-完整实现hash-Router\"><a href=\"#2-2-完整实现hash-Router\" class=\"headerlink\" title=\"2.2 完整实现hash Router\"></a>2.2 完整实现hash Router</h5><p>我们必须做一个判断,如果是后退的话,我们只需要执行回调函数,不需要添加数组和移动指针。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Routers</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">constructor</span>() &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 储存hash与callback键值对</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.routes = &#123;&#125;;</span><br><span class=\"line\">    <span class=\"comment\">// 当前hash</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.currentUrl = <span class=\"string\">''</span>;</span><br><span class=\"line\">    <span class=\"comment\">// 记录出现过的hash</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.history = [];</span><br><span class=\"line\">    <span class=\"comment\">// 作为指针,默认指向this.history的末尾,根据后退前进指向history中不同的hash</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.currentIndex = <span class=\"keyword\">this</span>.history.length - <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.refresh = <span class=\"keyword\">this</span>.refresh.bind(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.backOff = <span class=\"keyword\">this</span>.backOff.bind(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">    <span class=\"comment\">// 默认不是后退操作</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.isBack = <span class=\"literal\">false</span>;</span><br><span class=\"line\">    <span class=\"built_in\">window</span>.addEventListener(<span class=\"string\">'load'</span>, <span class=\"keyword\">this</span>.refresh, <span class=\"literal\">false</span>);</span><br><span class=\"line\">    <span class=\"built_in\">window</span>.addEventListener(<span class=\"string\">'hashchange'</span>, <span class=\"keyword\">this</span>.refresh, <span class=\"literal\">false</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  route(path, callback) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.routes[path] = callback || <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;&#125;;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  refresh() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.currentUrl = location.hash.slice(<span class=\"number\">1</span>) || <span class=\"string\">'/'</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!<span class=\"keyword\">this</span>.isBack) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 如果不是后退操作,且当前指针小于数组总长度,直接截取指针之前的部分储存下来</span></span><br><span class=\"line\">      <span class=\"comment\">// 此操作来避免当点击后退按钮之后,再进行正常跳转,指针会停留在原地,而数组添加新hash路由</span></span><br><span class=\"line\">      <span class=\"comment\">// 避免再次造成指针的不匹配,我们直接截取指针之前的数组</span></span><br><span class=\"line\">      <span class=\"comment\">// 此操作同时与浏览器自带后退功能的行为保持一致</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.currentIndex &lt; <span class=\"keyword\">this</span>.history.length - <span class=\"number\">1</span>)</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.history = <span class=\"keyword\">this</span>.history.slice(<span class=\"number\">0</span>, <span class=\"keyword\">this</span>.currentIndex + <span class=\"number\">1</span>);</span><br><span class=\"line\">      <span class=\"keyword\">this</span>.history.push(<span class=\"keyword\">this</span>.currentUrl);</span><br><span class=\"line\">      <span class=\"keyword\">this</span>.currentIndex++;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.routes[<span class=\"keyword\">this</span>.currentUrl]();</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'指针:'</span>, <span class=\"keyword\">this</span>.currentIndex, <span class=\"string\">'history:'</span>, <span class=\"keyword\">this</span>.history);</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.isBack = <span class=\"literal\">false</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 后退功能</span></span><br><span class=\"line\">  backOff() &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 后退操作设置为true</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.isBack = <span class=\"literal\">true</span>;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.currentIndex &lt;= <span class=\"number\">0</span></span><br><span class=\"line\">      ? (<span class=\"keyword\">this</span>.currentIndex = <span class=\"number\">0</span>)</span><br><span class=\"line\">      : (<span class=\"keyword\">this</span>.currentIndex = <span class=\"keyword\">this</span>.currentIndex - <span class=\"number\">1</span>);</span><br><span class=\"line\">    location.hash = <span class=\"string\">`#<span class=\"subst\">$&#123;<span class=\"keyword\">this</span>.history[<span class=\"keyword\">this</span>.currentIndex]&#125;</span>`</span>;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.routes[<span class=\"keyword\">this</span>.history[<span class=\"keyword\">this</span>.currentIndex]]();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>前进的部分就不实现了,思路我们已经讲得比较清楚了,可以看出来,hash路由这种方式确实有点繁琐,所以HTML5标准提供了History API供我们使用。</p>\n<h4 id=\"3-HTML5新路由方案\"><a href=\"#3-HTML5新路由方案\" class=\"headerlink\" title=\"3. HTML5新路由方案\"></a>3. HTML5新路由方案</h4><h5 id=\"3-1-History-API\"><a href=\"#3-1-History-API\" class=\"headerlink\" title=\"3.1 History API\"></a>3.1 History API</h5><p>我们只简单看一下history常用的三个API.<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">window</span>.history.back();       <span class=\"comment\">// 后退</span></span><br><span class=\"line\"><span class=\"built_in\">window</span>.history.forward();    <span class=\"comment\">// 前进</span></span><br><span class=\"line\"><span class=\"built_in\">window</span>.history.go(<span class=\"number\">-3</span>);       <span class=\"comment\">// 后退三个页面</span></span><br></pre></td></tr></table></figure></p>\n<p><code>history.pushState</code>用于在浏览历史中添加历史记录,但是并不触发跳转,此方法接受三个参数，依次为：</p>\n<blockquote>\n<p><code>state</code>:一个与指定网址相关的状态对象，<code>popstate</code>事件触发时，该对象会传入回调函数。如果不需要这个对象，此处可以填<code>null</code>。<br><code>title</code>：新页面的标题，但是所有浏览器目前都忽略这个值，因此这里可以填null。<br><code>url</code>：新的网址，必须与当前页面处在同一个域。浏览器的地址栏将显示这个网址。</p>\n</blockquote>\n<p><code>history.replaceState</code>方法的参数与<code>pushState</code>方法一模一样，区别是它修改浏览历史中当前纪录,而非添加记录,同样不触发跳转。</p>\n<p><code>popstate</code>事件,每当同一个文档的浏览历史（即<code>history</code>对象）出现变化时，就会触发<code>popstate</code>事件。</p>\n<p>需要注意的是，仅仅调用<code>pushState</code>方法或<code>replaceState</code>方法 ，并不会触发该事件，只有用户点击浏览器倒退按钮和前进按钮，或者使用 <code>JavaScript</code> 调用<code>back</code>、<code>forward</code>、<code>go</code>方法时才会触发。</p>\n<p>另外，该事件只针对同一个文档，如果浏览历史的切换，导致加载不同的文档，该事件也不会触发。</p>\n<h5 id=\"3-2-新标准下路由的实现\"><a href=\"#3-2-新标准下路由的实现\" class=\"headerlink\" title=\"3.2 新标准下路由的实现\"></a>3.2 新标准下路由的实现</h5><p>上一节我们介绍了新标准的History API,相比于我们在Hash 路由实现的那些操作,很显然新标准让我们的实现更加方便和可读。</p>\n<p>所以一个mini路由实现起来其实很简单<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Routers</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">constructor</span>() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.routes = &#123;&#125;;</span><br><span class=\"line\">    <span class=\"comment\">// 在初始化时监听popstate事件</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>._bindPopState();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 初始化路由</span></span><br><span class=\"line\">  init(path) &#123;</span><br><span class=\"line\">    history.replaceState(&#123;<span class=\"attr\">path</span>: path&#125;, <span class=\"literal\">null</span>, path);</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.routes[path] &amp;&amp; <span class=\"keyword\">this</span>.routes[path]();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 将路径和对应回调函数加入hashMap储存</span></span><br><span class=\"line\">  route(path, callback) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.routes[path] = callback || <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;&#125;;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 触发路由对应回调</span></span><br><span class=\"line\">  go(path) &#123;</span><br><span class=\"line\">    history.pushState(&#123;<span class=\"attr\">path</span>: path&#125;, <span class=\"literal\">null</span>, path);</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.routes[path] &amp;&amp; <span class=\"keyword\">this</span>.routes[path]();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 监听popstate事件</span></span><br><span class=\"line\">  _bindPopState() &#123;</span><br><span class=\"line\">    <span class=\"built_in\">window</span>.addEventListener(<span class=\"string\">'popstate'</span>, e =&gt; &#123;</span><br><span class=\"line\">      <span class=\"keyword\">const</span> path = e.state &amp;&amp; e.state.path;</span><br><span class=\"line\">      <span class=\"keyword\">this</span>.routes[path] &amp;&amp; <span class=\"keyword\">this</span>.routes[path]();</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>点击查看H5路由 <a href=\"https://codepen.io/experor-xxy/pen/RyjXEX\" target=\"_blank\" rel=\"noopener\">H5 Router</a></p>\n<p>小结<br>我们大致探究了前端路由的两种实现方法,在没有兼容性要求的情况下显然符合标准的History API实现的路由是更好的选择。</p>\n<p>想更深入了解前端路由实现可以阅读<a href=\"https://github.com/vuejs/vue-router/blob/dev/src/index.js\" target=\"_blank\" rel=\"noopener\">vue-router</a>代码，除去开发模式代码、注释和类型检测代码，核心代码并不多，适合阅读。</p>\n","site":{"data":{}},"excerpt":"<h4 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h4><p>&emsp;&emsp;前端路由是现代SPA应用必备的功能,每个现代前端框架都有对应的实现,例如vue-router、react-router。</p>\n<p>我们不想探究vue-router或者react-router们的实现，因为不管是哪种路由无外乎用兼容性更好的hash实现或者是H5 History实现，与框架几个只需要做相应的封装即可。</p>\n<blockquote>\n<p> 提前声明: 我们没有对传入的参数进行及时判断而规避错误,也没有考虑兼容性问题,仅仅对核心方法进行了实现.</p>\n</blockquote>","more":"<hr>\n<h4 id=\"1-hash路由\"><a href=\"#1-hash路由\" class=\"headerlink\" title=\"1.hash路由\"></a>1.hash路由</h4><p>hash路由一个明显的标志是带有<code>#</code>,我们主要是通过监听url中的hash变化来进行路由跳转。</p>\n<p>hash的优势就是兼容性更好,在老版IE中都有运行,问题在于url中一直存在<code>#</code>不够美观,而且hash路由更像是Hack而非标准,相信随着发展更加标准化的History API会逐步蚕食掉hash路由的市场。</p>\n<h5 id=\"1-1-初始化class\"><a href=\"#1-1-初始化class\" class=\"headerlink\" title=\"1.1 初始化class\"></a>1.1 初始化class</h5><p>我们用<code>Class</code>关键字初始化一个路由.<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Routers</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">constructor</span>() &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 以键值对的形式储存路由</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.routes = &#123;&#125;;</span><br><span class=\"line\">    <span class=\"comment\">// 当前路由的URL</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.currentUrl = <span class=\"string\">''</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h5 id=\"1-2-实现路由hash储存与执行\"><a href=\"#1-2-实现路由hash储存与执行\" class=\"headerlink\" title=\"1.2 实现路由hash储存与执行\"></a>1.2 实现路由hash储存与执行</h5><p>在初始化完毕后我们需要思考两个问题:</p>\n<ol>\n<li>将路由的hash以及对应的callback函数储存</li>\n<li>触发路由hash变化后,执行对应的callback函数</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Routers</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">constructor</span>() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.routes = &#123;&#125;;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.currentUrl = <span class=\"string\">''</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 将path路径与对应的callback函数储存</span></span><br><span class=\"line\">  route(path, callback) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.routes[path] = callback || <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;&#125;;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 刷新</span></span><br><span class=\"line\">  refresh() &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 获取当前URL中的hash路径</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.currentUrl = location.hash.slice(<span class=\"number\">1</span>) || <span class=\"string\">'/'</span>;</span><br><span class=\"line\">    <span class=\"comment\">// 执行当前hash路径的callback函数</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.routes[<span class=\"keyword\">this</span>.currentUrl]();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h5 id=\"1-3-监听对应事件\"><a href=\"#1-3-监听对应事件\" class=\"headerlink\" title=\"1.3 监听对应事件\"></a>1.3 监听对应事件</h5><p>那么我们只需要在实例化Class的时候监听上面的事件即可.<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Routers</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">constructor</span>() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.routes = &#123;&#125;;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.currentUrl = <span class=\"string\">''</span>;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.refresh = <span class=\"keyword\">this</span>.refresh.bind(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">    <span class=\"built_in\">window</span>.addEventListener(<span class=\"string\">'load'</span>, <span class=\"keyword\">this</span>.refresh, <span class=\"literal\">false</span>);</span><br><span class=\"line\">    <span class=\"built_in\">window</span>.addEventListener(<span class=\"string\">'hashchange'</span>, <span class=\"keyword\">this</span>.refresh, <span class=\"literal\">false</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  route(path, callback) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.routes[path] = callback || <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;&#125;;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  refresh() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.currentUrl = location.hash.slice(<span class=\"number\">1</span>) || <span class=\"string\">'/'</span>;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.routes[<span class=\"keyword\">this</span>.currentUrl]();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"2-增加回退功能\"><a href=\"#2-增加回退功能\" class=\"headerlink\" title=\"2.增加回退功能\"></a>2.增加回退功能</h4><p>上一节我们只实现了简单的路由功能,没有我们常用的回退与前进功能,所以我们需要进行改造。</p>\n<h5 id=\"2-1-实现后退功能\"><a href=\"#2-1-实现后退功能\" class=\"headerlink\" title=\"2.1 实现后退功能\"></a>2.1 实现后退功能</h5><p>我们在需要创建一个数组<code>history</code>来储存过往的hash路由例如<code>/blue</code>,并且创建一个指针<code>currentIndex</code>来随着后退和前进功能移动来指向不同的hash路由。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Routers</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">constructor</span>() &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 储存hash与callback键值对</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.routes = &#123;&#125;;</span><br><span class=\"line\">    <span class=\"comment\">// 当前hash</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.currentUrl = <span class=\"string\">''</span>;</span><br><span class=\"line\">    <span class=\"comment\">// 记录出现过的hash</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.history = [];</span><br><span class=\"line\">    <span class=\"comment\">// 作为指针,默认指向this.history的末尾,根据后退前进指向history中不同的hash</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.currentIndex = <span class=\"keyword\">this</span>.history.length - <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.refresh = <span class=\"keyword\">this</span>.refresh.bind(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.backOff = <span class=\"keyword\">this</span>.backOff.bind(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">    <span class=\"built_in\">window</span>.addEventListener(<span class=\"string\">'load'</span>, <span class=\"keyword\">this</span>.refresh, <span class=\"literal\">false</span>);</span><br><span class=\"line\">    <span class=\"built_in\">window</span>.addEventListener(<span class=\"string\">'hashchange'</span>, <span class=\"keyword\">this</span>.refresh, <span class=\"literal\">false</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  route(path, callback) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.routes[path] = callback || <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;&#125;;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  refresh() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.currentUrl = location.hash.slice(<span class=\"number\">1</span>) || <span class=\"string\">'/'</span>;</span><br><span class=\"line\">    <span class=\"comment\">// 将当前hash路由推入数组储存</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.history.push(<span class=\"keyword\">this</span>.currentUrl);</span><br><span class=\"line\">    <span class=\"comment\">// 指针向前移动</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.currentIndex++;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.routes[<span class=\"keyword\">this</span>.currentUrl]();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 后退功能</span></span><br><span class=\"line\">  backOff() &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 如果指针小于0的话就不存在对应hash路由了,因此锁定指针为0即可</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.currentIndex &lt;= <span class=\"number\">0</span></span><br><span class=\"line\">      ? (<span class=\"keyword\">this</span>.currentIndex = <span class=\"number\">0</span>)</span><br><span class=\"line\">      : (<span class=\"keyword\">this</span>.currentIndex = <span class=\"keyword\">this</span>.currentIndex - <span class=\"number\">1</span>);</span><br><span class=\"line\">    <span class=\"comment\">// 随着后退,location.hash也应该随之变化</span></span><br><span class=\"line\">    location.hash = <span class=\"string\">`#<span class=\"subst\">$&#123;<span class=\"keyword\">this</span>.history[<span class=\"keyword\">this</span>.currentIndex]&#125;</span>`</span>;</span><br><span class=\"line\">    <span class=\"comment\">// 执行指针目前指向hash路由对应的callback</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.routes[<span class=\"keyword\">this</span>.history[<span class=\"keyword\">this</span>.currentIndex]]();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>我们看起来实现的不错,可是出现了Bug,在后退的时候我们往往需要点击两下。</p>\n<p>问题在于,我们每次在后退都会执行相应的<code>callback</code>,这会触发<code>refresh()</code>执行,因此每次我们后退,<code>history</code>中都会被<code>push</code>新的路由<code>hash</code>,<code>currentIndex</code>也会向前移动,这显然不是我们想要的。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">refresh() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.currentUrl = location.hash.slice(<span class=\"number\">1</span>) || <span class=\"string\">'/'</span>;</span><br><span class=\"line\">    <span class=\"comment\">// 将当前hash路由推入数组储存</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.history.push(<span class=\"keyword\">this</span>.currentUrl);</span><br><span class=\"line\">    <span class=\"comment\">// 指针向前移动</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.currentIndex++;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.routes[<span class=\"keyword\">this</span>.currentUrl]();</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n<h5 id=\"2-2-完整实现hash-Router\"><a href=\"#2-2-完整实现hash-Router\" class=\"headerlink\" title=\"2.2 完整实现hash Router\"></a>2.2 完整实现hash Router</h5><p>我们必须做一个判断,如果是后退的话,我们只需要执行回调函数,不需要添加数组和移动指针。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Routers</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">constructor</span>() &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 储存hash与callback键值对</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.routes = &#123;&#125;;</span><br><span class=\"line\">    <span class=\"comment\">// 当前hash</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.currentUrl = <span class=\"string\">''</span>;</span><br><span class=\"line\">    <span class=\"comment\">// 记录出现过的hash</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.history = [];</span><br><span class=\"line\">    <span class=\"comment\">// 作为指针,默认指向this.history的末尾,根据后退前进指向history中不同的hash</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.currentIndex = <span class=\"keyword\">this</span>.history.length - <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.refresh = <span class=\"keyword\">this</span>.refresh.bind(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.backOff = <span class=\"keyword\">this</span>.backOff.bind(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">    <span class=\"comment\">// 默认不是后退操作</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.isBack = <span class=\"literal\">false</span>;</span><br><span class=\"line\">    <span class=\"built_in\">window</span>.addEventListener(<span class=\"string\">'load'</span>, <span class=\"keyword\">this</span>.refresh, <span class=\"literal\">false</span>);</span><br><span class=\"line\">    <span class=\"built_in\">window</span>.addEventListener(<span class=\"string\">'hashchange'</span>, <span class=\"keyword\">this</span>.refresh, <span class=\"literal\">false</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  route(path, callback) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.routes[path] = callback || <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;&#125;;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  refresh() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.currentUrl = location.hash.slice(<span class=\"number\">1</span>) || <span class=\"string\">'/'</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!<span class=\"keyword\">this</span>.isBack) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 如果不是后退操作,且当前指针小于数组总长度,直接截取指针之前的部分储存下来</span></span><br><span class=\"line\">      <span class=\"comment\">// 此操作来避免当点击后退按钮之后,再进行正常跳转,指针会停留在原地,而数组添加新hash路由</span></span><br><span class=\"line\">      <span class=\"comment\">// 避免再次造成指针的不匹配,我们直接截取指针之前的数组</span></span><br><span class=\"line\">      <span class=\"comment\">// 此操作同时与浏览器自带后退功能的行为保持一致</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.currentIndex &lt; <span class=\"keyword\">this</span>.history.length - <span class=\"number\">1</span>)</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.history = <span class=\"keyword\">this</span>.history.slice(<span class=\"number\">0</span>, <span class=\"keyword\">this</span>.currentIndex + <span class=\"number\">1</span>);</span><br><span class=\"line\">      <span class=\"keyword\">this</span>.history.push(<span class=\"keyword\">this</span>.currentUrl);</span><br><span class=\"line\">      <span class=\"keyword\">this</span>.currentIndex++;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.routes[<span class=\"keyword\">this</span>.currentUrl]();</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'指针:'</span>, <span class=\"keyword\">this</span>.currentIndex, <span class=\"string\">'history:'</span>, <span class=\"keyword\">this</span>.history);</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.isBack = <span class=\"literal\">false</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 后退功能</span></span><br><span class=\"line\">  backOff() &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 后退操作设置为true</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.isBack = <span class=\"literal\">true</span>;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.currentIndex &lt;= <span class=\"number\">0</span></span><br><span class=\"line\">      ? (<span class=\"keyword\">this</span>.currentIndex = <span class=\"number\">0</span>)</span><br><span class=\"line\">      : (<span class=\"keyword\">this</span>.currentIndex = <span class=\"keyword\">this</span>.currentIndex - <span class=\"number\">1</span>);</span><br><span class=\"line\">    location.hash = <span class=\"string\">`#<span class=\"subst\">$&#123;<span class=\"keyword\">this</span>.history[<span class=\"keyword\">this</span>.currentIndex]&#125;</span>`</span>;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.routes[<span class=\"keyword\">this</span>.history[<span class=\"keyword\">this</span>.currentIndex]]();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>前进的部分就不实现了,思路我们已经讲得比较清楚了,可以看出来,hash路由这种方式确实有点繁琐,所以HTML5标准提供了History API供我们使用。</p>\n<h4 id=\"3-HTML5新路由方案\"><a href=\"#3-HTML5新路由方案\" class=\"headerlink\" title=\"3. HTML5新路由方案\"></a>3. HTML5新路由方案</h4><h5 id=\"3-1-History-API\"><a href=\"#3-1-History-API\" class=\"headerlink\" title=\"3.1 History API\"></a>3.1 History API</h5><p>我们只简单看一下history常用的三个API.<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">window</span>.history.back();       <span class=\"comment\">// 后退</span></span><br><span class=\"line\"><span class=\"built_in\">window</span>.history.forward();    <span class=\"comment\">// 前进</span></span><br><span class=\"line\"><span class=\"built_in\">window</span>.history.go(<span class=\"number\">-3</span>);       <span class=\"comment\">// 后退三个页面</span></span><br></pre></td></tr></table></figure></p>\n<p><code>history.pushState</code>用于在浏览历史中添加历史记录,但是并不触发跳转,此方法接受三个参数，依次为：</p>\n<blockquote>\n<p><code>state</code>:一个与指定网址相关的状态对象，<code>popstate</code>事件触发时，该对象会传入回调函数。如果不需要这个对象，此处可以填<code>null</code>。<br><code>title</code>：新页面的标题，但是所有浏览器目前都忽略这个值，因此这里可以填null。<br><code>url</code>：新的网址，必须与当前页面处在同一个域。浏览器的地址栏将显示这个网址。</p>\n</blockquote>\n<p><code>history.replaceState</code>方法的参数与<code>pushState</code>方法一模一样，区别是它修改浏览历史中当前纪录,而非添加记录,同样不触发跳转。</p>\n<p><code>popstate</code>事件,每当同一个文档的浏览历史（即<code>history</code>对象）出现变化时，就会触发<code>popstate</code>事件。</p>\n<p>需要注意的是，仅仅调用<code>pushState</code>方法或<code>replaceState</code>方法 ，并不会触发该事件，只有用户点击浏览器倒退按钮和前进按钮，或者使用 <code>JavaScript</code> 调用<code>back</code>、<code>forward</code>、<code>go</code>方法时才会触发。</p>\n<p>另外，该事件只针对同一个文档，如果浏览历史的切换，导致加载不同的文档，该事件也不会触发。</p>\n<h5 id=\"3-2-新标准下路由的实现\"><a href=\"#3-2-新标准下路由的实现\" class=\"headerlink\" title=\"3.2 新标准下路由的实现\"></a>3.2 新标准下路由的实现</h5><p>上一节我们介绍了新标准的History API,相比于我们在Hash 路由实现的那些操作,很显然新标准让我们的实现更加方便和可读。</p>\n<p>所以一个mini路由实现起来其实很简单<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Routers</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">constructor</span>() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.routes = &#123;&#125;;</span><br><span class=\"line\">    <span class=\"comment\">// 在初始化时监听popstate事件</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>._bindPopState();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 初始化路由</span></span><br><span class=\"line\">  init(path) &#123;</span><br><span class=\"line\">    history.replaceState(&#123;<span class=\"attr\">path</span>: path&#125;, <span class=\"literal\">null</span>, path);</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.routes[path] &amp;&amp; <span class=\"keyword\">this</span>.routes[path]();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 将路径和对应回调函数加入hashMap储存</span></span><br><span class=\"line\">  route(path, callback) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.routes[path] = callback || <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;&#125;;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 触发路由对应回调</span></span><br><span class=\"line\">  go(path) &#123;</span><br><span class=\"line\">    history.pushState(&#123;<span class=\"attr\">path</span>: path&#125;, <span class=\"literal\">null</span>, path);</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.routes[path] &amp;&amp; <span class=\"keyword\">this</span>.routes[path]();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 监听popstate事件</span></span><br><span class=\"line\">  _bindPopState() &#123;</span><br><span class=\"line\">    <span class=\"built_in\">window</span>.addEventListener(<span class=\"string\">'popstate'</span>, e =&gt; &#123;</span><br><span class=\"line\">      <span class=\"keyword\">const</span> path = e.state &amp;&amp; e.state.path;</span><br><span class=\"line\">      <span class=\"keyword\">this</span>.routes[path] &amp;&amp; <span class=\"keyword\">this</span>.routes[path]();</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>点击查看H5路由 <a href=\"https://codepen.io/experor-xxy/pen/RyjXEX\" target=\"_blank\" rel=\"noopener\">H5 Router</a></p>\n<p>小结<br>我们大致探究了前端路由的两种实现方法,在没有兼容性要求的情况下显然符合标准的History API实现的路由是更好的选择。</p>\n<p>想更深入了解前端路由实现可以阅读<a href=\"https://github.com/vuejs/vue-router/blob/dev/src/index.js\" target=\"_blank\" rel=\"noopener\">vue-router</a>代码，除去开发模式代码、注释和类型检测代码，核心代码并不多，适合阅读。</p>"},{"title":"你可能真的不懂JavaScript中最基础类型","date":"2018-03-06T06:11:42.000Z","_content":"\n#### 前言\n　　众所周知,JavaScript是动态弱类型的多范式编程语言,由于设计时的粗糙(当时设计js的初衷就是在浏览器中处理表单这种简单事件)导致JavaScript在许多方面表现出了这样或者那样的问题,其中'类型'便是语法层面最常见的'埋坑'重灾区. 　　\n\n> JavaScript原始类型:Undefined、Null、Boolean、Number、String、Symbol\n\n> JavaScript引用类型:Object\n\n<!-- more -->\n***\n#### 1.原始类型与引用类型\n##### 1.1\n&emsp;&emsp;`原始类型`又被称为`引用类型`，原始类型保存的变量和值直接保存在`栈内存(Stack)`中,且空间相互独立,通过值来访问,说到这里肯定一同懵逼,不过我们可以通过一个例子来解释.\n``` javascript\nvar person = 'Messi';\nvar person1 = person;\n```\n上述代码在栈内存的示意图是这样的,可以看到,虽然`person`赋值给了`person1`.但是两个变量并没有指向同一个值,而是`person1`自己单独建立一个内存空间,虽然两个变量的值相等,但却是相互独立的.\n<table><tr><td>person</td><td>Messi</td></tr><tr><td>person1</td><td>Messi</td></tr></table>\n\n``` javascript\nvar person = 'Messi';\nvar person1 = person;\n\nvar person = 1;\n\nconsole.log(person); //1\nconsole.log(person1); //'Messi'\n```\n上述代码示意图是这样的,`person`的值虽然改变,但是由于`person1`的值是独立储存的,因此不受影响.\n\n值得一提的是,虽然原始类型的值是储存在相对独立空间,但是它们之间的比较是按值比较的.\n```javascript\nvar person = 'Messi';\nvar person1 = 'Messi';\nconsole.log(person === person1); //true\n```\n##### 1.2引用类型\n剩下的就是引用类型了,即Object 类型,再往下细分，还可以分为：Object 类型、Array 类型、Date 类型、Function 类型 等。\n\n与原始类型不同的是,引用类型的内容是保存在**堆内存**中,而**栈内存(Heap)**中会有一个**堆内存地址**,通过这个地址变量被指向堆内存中`Object`真正的值,因此引用类型是按照引用访问的.\n\n下例能很清楚的说明引用类型的特质.\n```javascript\nvar a = {name:\"percy\"};\nvar b;\nb = a;\na.name = \"zyj\";\nconsole.log(b.name);    // zyj\nb.age = 22;\nconsole.log(a.age);     // 22\nvar c = {\n  name: \"zyj\",\n  age: 22\n};\nconsole.log(a === c); //false\n```\n我们可以逐行分析:\n1.`b = a`,如果是原始类型的话,`b`会在栈内自己独自创建一个内存空间保存值,但是引用类型只是`b`的产生一个对内存地址,指向堆内存中的`Object`.\n2.`a.name = \"zyj\"`,这个操作属于改变了变量的值,在原始类型中会重新建立新的内存空间(可以看上一节的示意图),而引用类型只需要自己在堆内存中更新自己的属性即可.\n3.最后创建了一个新的对象`c`,看似跟`b` `a`一样,但是在堆内存中确实两个相互独立的`Object`,引用类型是按照**引用比较**,由于`a`  `c`引用的是不同的`Object`所以得到的结果是`fasle`.\n\n![指向问题](https://camo.githubusercontent.com/d1293377721630c02f55d4201bf005eb6582de9b/687474703a2f2f6f6d7262677071796c2e626b742e636c6f7564646e2e636f6d2f31382d322d32302f33343330343934382e6a7067)\n***\n#### 2. 类型中的坑\n##### 2.1\n数组是JavaScript中最常见的类型之一了,但是在我们实践过程中同样会遇到各种各样的麻烦.\n\n**稀疏数组**:指的是含有空白或空缺单元的数组\n```javascript\nvar a = [];\n\nconsole.log(a.length); //0\n\na[4] = a[5];\n\nconsole.log(a.length); //5\n\na.forEach(elem => {\n  console.log(elem); //undefined\n});\n\nconsole.log(a); //[,,,,undefined]\n```\n这里有几个坑需要注意:\n\n> **1.**一开始建立的空数组`a`的长度为`0`,这可以理解,但是在`a[4] = a[5]`之后出现了问题,`a`的长度居然变成了`5`,此时`a`数组是`[,,,,undefined]`这种形态.\n\n> **2.**我们通过遍历,只得到了`undefined`这一个值,这个`undefind`是由于`a[4] = a[5]`赋值,由于`a[5]`没有定义值为`undefined`被赋给了`a[4]`,可以等价为`a[4] = undefined`.\n\n**字符串索引**\n```javascript\nvar a = [];\na[0] = 'Bale';\na['age'] = 28;\nconsole.log(a.length); //1\nconsole.log(a['age']); //28\nconsole.log(a); //[ 'Bale', age: 28 ]\n```\n数组不仅可以通过数字索引,也可以通过字符串索引,但值得注意的是,字符串索引的键值对并不算在数组的长度里.\n\n##### 2.2  二进制浮点数\nJavaScript 中的数字类型是基于“二进制浮点数”实现的,使用的是“双精度”格式,这就带来了一些反常的问题,我们那一道经典面试提来讲解下.\n```javascript\nvar a = 0.1 + 0.2;\nvar b = 0.3;\nconsole.log(a === b); //false\n```\n这是个出人意料的结果,实际上`a`的值约为`0.30000000000000004`这并不是一个整数值,这就是二进制浮点数带来的副作用.\n```javascript\nvar a = 0.1 + 0.2;\nvar b = 0.3;\nconsole.log(a === b); //false\nconsole.log(Number.isInteger(a*10)); //false\nconsole.log(Number.isInteger(b*10)); //true\nconsole.log(a); //0.30000000000000004\n```\n我们可以用`Number.isInteger()`来判断一个数字是否为整数.\n\n**NaN**\n```javascript\nvar a = 1/new Object();\nconsole.log(typeof a); //Number\nconsole.log(a); //NaN\nconsole.log(isNaN(a)); //true\n```\n`NaN`属于特殊的`Number`类型,我们可以把它理解为**坏数值**,因为它属于数值计算中的错误,更加特殊的是它自己都不等价于自己`NaN === NaN //false`,我们只能用`isNaN()`来检测一个数字是否为`NaN`.\n***\n#### 3.类型转换原理\n**类型转换**指的是将一种类型转换为另一种类型,例如:\n```javascript\nvar b = 2;\nvar a = String(b);\nconsole.log(typeof a); //string\n```\n当然,**类型转换**分为显式和隐式,但是不管是隐式转换还是显式转换,都会遵循一定的原理,由于`JavaScript`是一门动态类型的语言,可以随时赋予任意值,但是各种运算符或条件判断中是需要特定类型的,因此`JavaScript`引擎会在运算时为变量设定类型.\n\n这看起来很美好,`JavaScript`引擎帮我们搞定了类型的问题,但是引擎毕竟不是ASI(超级人工智能),它的很多动作会跟我们预期相去甚远,我们可以从一道面试题开始.\n\n\t{}+[] //0\n\n答案是0\n\n是什么原因造成了上述结果呢?那么我们得从**ECMA-262**中提到的转换规则和抽象操作说起,有兴趣的童鞋可以仔细阅读下这浩如烟海的[语言规范](http://ecma-international.org/ecma-262/5.1/),如果没这个耐心还是往下看.\n\n这是JavaScript种类型转换可以从**原始类型**转为**引用类型**,同样可以将**引用类型**转为**原始类型**,转为原始类型的抽象操作为`ToPrimitive`,而后续更加细分的操作为:`ToNumber` `ToString` `ToBoolean`,这三种抽象操作的转换表如下所示\n![转换规则](https://camo.githubusercontent.com/c6bc1eea15735abae88cf5f4565c1a64072952f7/687474703a2f2f6f6d7262677071796c2e626b742e636c6f7564646e2e636f6d2f31372d392d31332f31353531373233312e6a7067)\n\n如果想应付面试,我觉得这张表就差不多了,但是为了更深入的探究JavaScript引擎是如何处理代码中类型转换问题的,就需要看 ECMA-262详细的规范,从而探究其内部原理,我们从这段内部原理示意代码开始.\n\n```javascript\n// ECMA-262, section 9.1, page 30. Use null/undefined for no hint,\n// (1) for number hint, and (2) for string hint.\nfunction ToPrimitive(x, hint) {\n  // Fast case check.\n  if (IS_STRING(x)) return x;\n  // Normal behavior.\n  if (!IS_SPEC_OBJECT(x)) return x;\n  if (IS_SYMBOL_WRAPPER(x)) throw MakeTypeError(kSymbolToPrimitive);\n  if (hint == NO_HINT) hint = (IS_DATE(x)) ? STRING_HINT : NUMBER_HINT;\n  return (hint == NUMBER_HINT) ? DefaultNumber(x) : DefaultString(x);\n}\n\n// ECMA-262, section 8.6.2.6, page 28.\nfunction DefaultNumber(x) {\n  if (!IS_SYMBOL_WRAPPER(x)) {\n    var valueOf = x.valueOf;\n    if (IS_SPEC_FUNCTION(valueOf)) {\n      var v = %_CallFunction(x, valueOf);\n      if (IsPrimitive(v)) return v;\n    }\n\n    var toString = x.toString;\n    if (IS_SPEC_FUNCTION(toString)) {\n      var s = %_CallFunction(x, toString);\n      if (IsPrimitive(s)) return s;\n    }\n  }\n  throw MakeTypeError(kCannotConvertToPrimitive);\n}\n\n// ECMA-262, section 8.6.2.6, page 28.\nfunction DefaultString(x) {\n  if (!IS_SYMBOL_WRAPPER(x)) {\n    var toString = x.toString;\n    if (IS_SPEC_FUNCTION(toString)) {\n      var s = %_CallFunction(x, toString);\n      if (IsPrimitive(s)) return s;\n    }\n\n    var valueOf = x.valueOf;\n    if (IS_SPEC_FUNCTION(valueOf)) {\n      var v = %_CallFunction(x, valueOf);\n      if (IsPrimitive(v)) return v;\n    }\n  }\n  throw MakeTypeError(kCannotConvertToPrimitive);\n}\n```\n\n上面代码的逻辑是这样的：\n\n1. 如果变量为字符串，直接返回.\n2. 如果`!IS_SPEC_OBJECT(x)`，直接返回.\n3. 如果`IS_SYMBOL_WRAPPER(x)`，则抛出异常.\n4. 否则会根据传入的`hint`来调用`DefaultNumber`和`DefaultString`，比如如果为`Date`对象，会调用`DefaultString`.\n5. `DefaultNumber`：首先`x.valueOf`，如果为`primitive`，则返回`valueOf`后的值，否则继续调用`x.toString`，如果为`primitive`，则返回`toString`后的值，否则抛出异常\n6. `DefaultString`：和`DefaultNumber`正好相反，先调用`toString`，如果不是`primitive`再调用`valueOf`.\n\n那讲了实现原理，这个`ToPrimitive`有什么用呢？实际很多操作会调用`ToPrimitive`，比如加、相等或比较操。在进行加操作时会将左右操作数转换为`primitive`，然后进行相加。\n\n下面来个实例，`({}) + 1`（将`{}`放在括号中是为了内核将其认为一个代码块）会输出啥？可能日常写代码并不会这样写，不过网上出过类似的面试题。\n\n加操作只有左右运算符同时为`String`或`Number`时会执行对应的`%_StringAdd`或`%NumberAdd`，下面看下`({}) + 1`内部会经过哪些步骤：\n\n`{}`和`1`首先会调用`ToPrimitive {}`会走到`DefaultNumber`，首先会调用`valueOf`，返回的是`Object {}`，不是`primitive`类型，从而继续走到`toString`，返回`[object Object]`，是`String`类型 最后加操作，结果为`[object Object]1` 再比如有人问你`[] + 1`输出啥时，你可能知道应该怎么去计算了，先对`[]`调用`ToPrimitive`，返回空字符串，最后结果为`\"1\"`。\n\n","source":"_posts/js-dataType.md","raw":"---\ntitle: 你可能真的不懂JavaScript中最基础类型\ndate: 2018-03-06 14:11:42\ntags:\n    - javascript数据类型\ncategories:\n    - 面试题\n---\n\n#### 前言\n　　众所周知,JavaScript是动态弱类型的多范式编程语言,由于设计时的粗糙(当时设计js的初衷就是在浏览器中处理表单这种简单事件)导致JavaScript在许多方面表现出了这样或者那样的问题,其中'类型'便是语法层面最常见的'埋坑'重灾区. 　　\n\n> JavaScript原始类型:Undefined、Null、Boolean、Number、String、Symbol\n\n> JavaScript引用类型:Object\n\n<!-- more -->\n***\n#### 1.原始类型与引用类型\n##### 1.1\n&emsp;&emsp;`原始类型`又被称为`引用类型`，原始类型保存的变量和值直接保存在`栈内存(Stack)`中,且空间相互独立,通过值来访问,说到这里肯定一同懵逼,不过我们可以通过一个例子来解释.\n``` javascript\nvar person = 'Messi';\nvar person1 = person;\n```\n上述代码在栈内存的示意图是这样的,可以看到,虽然`person`赋值给了`person1`.但是两个变量并没有指向同一个值,而是`person1`自己单独建立一个内存空间,虽然两个变量的值相等,但却是相互独立的.\n<table><tr><td>person</td><td>Messi</td></tr><tr><td>person1</td><td>Messi</td></tr></table>\n\n``` javascript\nvar person = 'Messi';\nvar person1 = person;\n\nvar person = 1;\n\nconsole.log(person); //1\nconsole.log(person1); //'Messi'\n```\n上述代码示意图是这样的,`person`的值虽然改变,但是由于`person1`的值是独立储存的,因此不受影响.\n\n值得一提的是,虽然原始类型的值是储存在相对独立空间,但是它们之间的比较是按值比较的.\n```javascript\nvar person = 'Messi';\nvar person1 = 'Messi';\nconsole.log(person === person1); //true\n```\n##### 1.2引用类型\n剩下的就是引用类型了,即Object 类型,再往下细分，还可以分为：Object 类型、Array 类型、Date 类型、Function 类型 等。\n\n与原始类型不同的是,引用类型的内容是保存在**堆内存**中,而**栈内存(Heap)**中会有一个**堆内存地址**,通过这个地址变量被指向堆内存中`Object`真正的值,因此引用类型是按照引用访问的.\n\n下例能很清楚的说明引用类型的特质.\n```javascript\nvar a = {name:\"percy\"};\nvar b;\nb = a;\na.name = \"zyj\";\nconsole.log(b.name);    // zyj\nb.age = 22;\nconsole.log(a.age);     // 22\nvar c = {\n  name: \"zyj\",\n  age: 22\n};\nconsole.log(a === c); //false\n```\n我们可以逐行分析:\n1.`b = a`,如果是原始类型的话,`b`会在栈内自己独自创建一个内存空间保存值,但是引用类型只是`b`的产生一个对内存地址,指向堆内存中的`Object`.\n2.`a.name = \"zyj\"`,这个操作属于改变了变量的值,在原始类型中会重新建立新的内存空间(可以看上一节的示意图),而引用类型只需要自己在堆内存中更新自己的属性即可.\n3.最后创建了一个新的对象`c`,看似跟`b` `a`一样,但是在堆内存中确实两个相互独立的`Object`,引用类型是按照**引用比较**,由于`a`  `c`引用的是不同的`Object`所以得到的结果是`fasle`.\n\n![指向问题](https://camo.githubusercontent.com/d1293377721630c02f55d4201bf005eb6582de9b/687474703a2f2f6f6d7262677071796c2e626b742e636c6f7564646e2e636f6d2f31382d322d32302f33343330343934382e6a7067)\n***\n#### 2. 类型中的坑\n##### 2.1\n数组是JavaScript中最常见的类型之一了,但是在我们实践过程中同样会遇到各种各样的麻烦.\n\n**稀疏数组**:指的是含有空白或空缺单元的数组\n```javascript\nvar a = [];\n\nconsole.log(a.length); //0\n\na[4] = a[5];\n\nconsole.log(a.length); //5\n\na.forEach(elem => {\n  console.log(elem); //undefined\n});\n\nconsole.log(a); //[,,,,undefined]\n```\n这里有几个坑需要注意:\n\n> **1.**一开始建立的空数组`a`的长度为`0`,这可以理解,但是在`a[4] = a[5]`之后出现了问题,`a`的长度居然变成了`5`,此时`a`数组是`[,,,,undefined]`这种形态.\n\n> **2.**我们通过遍历,只得到了`undefined`这一个值,这个`undefind`是由于`a[4] = a[5]`赋值,由于`a[5]`没有定义值为`undefined`被赋给了`a[4]`,可以等价为`a[4] = undefined`.\n\n**字符串索引**\n```javascript\nvar a = [];\na[0] = 'Bale';\na['age'] = 28;\nconsole.log(a.length); //1\nconsole.log(a['age']); //28\nconsole.log(a); //[ 'Bale', age: 28 ]\n```\n数组不仅可以通过数字索引,也可以通过字符串索引,但值得注意的是,字符串索引的键值对并不算在数组的长度里.\n\n##### 2.2  二进制浮点数\nJavaScript 中的数字类型是基于“二进制浮点数”实现的,使用的是“双精度”格式,这就带来了一些反常的问题,我们那一道经典面试提来讲解下.\n```javascript\nvar a = 0.1 + 0.2;\nvar b = 0.3;\nconsole.log(a === b); //false\n```\n这是个出人意料的结果,实际上`a`的值约为`0.30000000000000004`这并不是一个整数值,这就是二进制浮点数带来的副作用.\n```javascript\nvar a = 0.1 + 0.2;\nvar b = 0.3;\nconsole.log(a === b); //false\nconsole.log(Number.isInteger(a*10)); //false\nconsole.log(Number.isInteger(b*10)); //true\nconsole.log(a); //0.30000000000000004\n```\n我们可以用`Number.isInteger()`来判断一个数字是否为整数.\n\n**NaN**\n```javascript\nvar a = 1/new Object();\nconsole.log(typeof a); //Number\nconsole.log(a); //NaN\nconsole.log(isNaN(a)); //true\n```\n`NaN`属于特殊的`Number`类型,我们可以把它理解为**坏数值**,因为它属于数值计算中的错误,更加特殊的是它自己都不等价于自己`NaN === NaN //false`,我们只能用`isNaN()`来检测一个数字是否为`NaN`.\n***\n#### 3.类型转换原理\n**类型转换**指的是将一种类型转换为另一种类型,例如:\n```javascript\nvar b = 2;\nvar a = String(b);\nconsole.log(typeof a); //string\n```\n当然,**类型转换**分为显式和隐式,但是不管是隐式转换还是显式转换,都会遵循一定的原理,由于`JavaScript`是一门动态类型的语言,可以随时赋予任意值,但是各种运算符或条件判断中是需要特定类型的,因此`JavaScript`引擎会在运算时为变量设定类型.\n\n这看起来很美好,`JavaScript`引擎帮我们搞定了类型的问题,但是引擎毕竟不是ASI(超级人工智能),它的很多动作会跟我们预期相去甚远,我们可以从一道面试题开始.\n\n\t{}+[] //0\n\n答案是0\n\n是什么原因造成了上述结果呢?那么我们得从**ECMA-262**中提到的转换规则和抽象操作说起,有兴趣的童鞋可以仔细阅读下这浩如烟海的[语言规范](http://ecma-international.org/ecma-262/5.1/),如果没这个耐心还是往下看.\n\n这是JavaScript种类型转换可以从**原始类型**转为**引用类型**,同样可以将**引用类型**转为**原始类型**,转为原始类型的抽象操作为`ToPrimitive`,而后续更加细分的操作为:`ToNumber` `ToString` `ToBoolean`,这三种抽象操作的转换表如下所示\n![转换规则](https://camo.githubusercontent.com/c6bc1eea15735abae88cf5f4565c1a64072952f7/687474703a2f2f6f6d7262677071796c2e626b742e636c6f7564646e2e636f6d2f31372d392d31332f31353531373233312e6a7067)\n\n如果想应付面试,我觉得这张表就差不多了,但是为了更深入的探究JavaScript引擎是如何处理代码中类型转换问题的,就需要看 ECMA-262详细的规范,从而探究其内部原理,我们从这段内部原理示意代码开始.\n\n```javascript\n// ECMA-262, section 9.1, page 30. Use null/undefined for no hint,\n// (1) for number hint, and (2) for string hint.\nfunction ToPrimitive(x, hint) {\n  // Fast case check.\n  if (IS_STRING(x)) return x;\n  // Normal behavior.\n  if (!IS_SPEC_OBJECT(x)) return x;\n  if (IS_SYMBOL_WRAPPER(x)) throw MakeTypeError(kSymbolToPrimitive);\n  if (hint == NO_HINT) hint = (IS_DATE(x)) ? STRING_HINT : NUMBER_HINT;\n  return (hint == NUMBER_HINT) ? DefaultNumber(x) : DefaultString(x);\n}\n\n// ECMA-262, section 8.6.2.6, page 28.\nfunction DefaultNumber(x) {\n  if (!IS_SYMBOL_WRAPPER(x)) {\n    var valueOf = x.valueOf;\n    if (IS_SPEC_FUNCTION(valueOf)) {\n      var v = %_CallFunction(x, valueOf);\n      if (IsPrimitive(v)) return v;\n    }\n\n    var toString = x.toString;\n    if (IS_SPEC_FUNCTION(toString)) {\n      var s = %_CallFunction(x, toString);\n      if (IsPrimitive(s)) return s;\n    }\n  }\n  throw MakeTypeError(kCannotConvertToPrimitive);\n}\n\n// ECMA-262, section 8.6.2.6, page 28.\nfunction DefaultString(x) {\n  if (!IS_SYMBOL_WRAPPER(x)) {\n    var toString = x.toString;\n    if (IS_SPEC_FUNCTION(toString)) {\n      var s = %_CallFunction(x, toString);\n      if (IsPrimitive(s)) return s;\n    }\n\n    var valueOf = x.valueOf;\n    if (IS_SPEC_FUNCTION(valueOf)) {\n      var v = %_CallFunction(x, valueOf);\n      if (IsPrimitive(v)) return v;\n    }\n  }\n  throw MakeTypeError(kCannotConvertToPrimitive);\n}\n```\n\n上面代码的逻辑是这样的：\n\n1. 如果变量为字符串，直接返回.\n2. 如果`!IS_SPEC_OBJECT(x)`，直接返回.\n3. 如果`IS_SYMBOL_WRAPPER(x)`，则抛出异常.\n4. 否则会根据传入的`hint`来调用`DefaultNumber`和`DefaultString`，比如如果为`Date`对象，会调用`DefaultString`.\n5. `DefaultNumber`：首先`x.valueOf`，如果为`primitive`，则返回`valueOf`后的值，否则继续调用`x.toString`，如果为`primitive`，则返回`toString`后的值，否则抛出异常\n6. `DefaultString`：和`DefaultNumber`正好相反，先调用`toString`，如果不是`primitive`再调用`valueOf`.\n\n那讲了实现原理，这个`ToPrimitive`有什么用呢？实际很多操作会调用`ToPrimitive`，比如加、相等或比较操。在进行加操作时会将左右操作数转换为`primitive`，然后进行相加。\n\n下面来个实例，`({}) + 1`（将`{}`放在括号中是为了内核将其认为一个代码块）会输出啥？可能日常写代码并不会这样写，不过网上出过类似的面试题。\n\n加操作只有左右运算符同时为`String`或`Number`时会执行对应的`%_StringAdd`或`%NumberAdd`，下面看下`({}) + 1`内部会经过哪些步骤：\n\n`{}`和`1`首先会调用`ToPrimitive {}`会走到`DefaultNumber`，首先会调用`valueOf`，返回的是`Object {}`，不是`primitive`类型，从而继续走到`toString`，返回`[object Object]`，是`String`类型 最后加操作，结果为`[object Object]1` 再比如有人问你`[] + 1`输出啥时，你可能知道应该怎么去计算了，先对`[]`调用`ToPrimitive`，返回空字符串，最后结果为`\"1\"`。\n\n","slug":"js-dataType","published":1,"updated":"2018-05-08T02:59:28.789Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjhbjw6qm000dfx9mkpde7hw5","content":"<h4 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h4><p>　　众所周知,JavaScript是动态弱类型的多范式编程语言,由于设计时的粗糙(当时设计js的初衷就是在浏览器中处理表单这种简单事件)导致JavaScript在许多方面表现出了这样或者那样的问题,其中’类型’便是语法层面最常见的’埋坑’重灾区. 　　</p>\n<blockquote>\n<p>JavaScript原始类型:Undefined、Null、Boolean、Number、String、Symbol</p>\n</blockquote>\n<blockquote>\n<p>JavaScript引用类型:Object</p>\n</blockquote>\n<a id=\"more\"></a>\n<hr>\n<h4 id=\"1-原始类型与引用类型\"><a href=\"#1-原始类型与引用类型\" class=\"headerlink\" title=\"1.原始类型与引用类型\"></a>1.原始类型与引用类型</h4><h5 id=\"1-1\"><a href=\"#1-1\" class=\"headerlink\" title=\"1.1\"></a>1.1</h5><p>&emsp;&emsp;<code>原始类型</code>又被称为<code>引用类型</code>，原始类型保存的变量和值直接保存在<code>栈内存(Stack)</code>中,且空间相互独立,通过值来访问,说到这里肯定一同懵逼,不过我们可以通过一个例子来解释.<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> person = <span class=\"string\">'Messi'</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> person1 = person;</span><br></pre></td></tr></table></figure></p>\n<p>上述代码在栈内存的示意图是这样的,可以看到,虽然<code>person</code>赋值给了<code>person1</code>.但是两个变量并没有指向同一个值,而是<code>person1</code>自己单独建立一个内存空间,虽然两个变量的值相等,但却是相互独立的.</p>\n<table><tr><td>person</td><td>Messi</td></tr><tr><td>person1</td><td>Messi</td></tr></table>\n\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> person = <span class=\"string\">'Messi'</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> person1 = person;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> person = <span class=\"number\">1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(person); <span class=\"comment\">//1</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(person1); <span class=\"comment\">//'Messi'</span></span><br></pre></td></tr></table></figure>\n<p>上述代码示意图是这样的,<code>person</code>的值虽然改变,但是由于<code>person1</code>的值是独立储存的,因此不受影响.</p>\n<p>值得一提的是,虽然原始类型的值是储存在相对独立空间,但是它们之间的比较是按值比较的.<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> person = <span class=\"string\">'Messi'</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> person1 = <span class=\"string\">'Messi'</span>;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(person === person1); <span class=\"comment\">//true</span></span><br></pre></td></tr></table></figure></p>\n<h5 id=\"1-2引用类型\"><a href=\"#1-2引用类型\" class=\"headerlink\" title=\"1.2引用类型\"></a>1.2引用类型</h5><p>剩下的就是引用类型了,即Object 类型,再往下细分，还可以分为：Object 类型、Array 类型、Date 类型、Function 类型 等。</p>\n<p>与原始类型不同的是,引用类型的内容是保存在<strong>堆内存</strong>中,而<strong>栈内存(Heap)</strong>中会有一个<strong>堆内存地址</strong>,通过这个地址变量被指向堆内存中<code>Object</code>真正的值,因此引用类型是按照引用访问的.</p>\n<p>下例能很清楚的说明引用类型的特质.<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = &#123;<span class=\"attr\">name</span>:<span class=\"string\">\"percy\"</span>&#125;;</span><br><span class=\"line\"><span class=\"keyword\">var</span> b;</span><br><span class=\"line\">b = a;</span><br><span class=\"line\">a.name = <span class=\"string\">\"zyj\"</span>;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(b.name);    <span class=\"comment\">// zyj</span></span><br><span class=\"line\">b.age = <span class=\"number\">22</span>;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(a.age);     <span class=\"comment\">// 22</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> c = &#123;</span><br><span class=\"line\">  name: <span class=\"string\">\"zyj\"</span>,</span><br><span class=\"line\">  age: <span class=\"number\">22</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(a === c); <span class=\"comment\">//false</span></span><br></pre></td></tr></table></figure></p>\n<p>我们可以逐行分析:<br>1.<code>b = a</code>,如果是原始类型的话,<code>b</code>会在栈内自己独自创建一个内存空间保存值,但是引用类型只是<code>b</code>的产生一个对内存地址,指向堆内存中的<code>Object</code>.<br>2.<code>a.name = &quot;zyj&quot;</code>,这个操作属于改变了变量的值,在原始类型中会重新建立新的内存空间(可以看上一节的示意图),而引用类型只需要自己在堆内存中更新自己的属性即可.<br>3.最后创建了一个新的对象<code>c</code>,看似跟<code>b</code> <code>a</code>一样,但是在堆内存中确实两个相互独立的<code>Object</code>,引用类型是按照<strong>引用比较</strong>,由于<code>a</code>  <code>c</code>引用的是不同的<code>Object</code>所以得到的结果是<code>fasle</code>.</p>\n<p><img src=\"https://camo.githubusercontent.com/d1293377721630c02f55d4201bf005eb6582de9b/687474703a2f2f6f6d7262677071796c2e626b742e636c6f7564646e2e636f6d2f31382d322d32302f33343330343934382e6a7067\" alt=\"指向问题\"></p>\n<hr>\n<h4 id=\"2-类型中的坑\"><a href=\"#2-类型中的坑\" class=\"headerlink\" title=\"2. 类型中的坑\"></a>2. 类型中的坑</h4><h5 id=\"2-1\"><a href=\"#2-1\" class=\"headerlink\" title=\"2.1\"></a>2.1</h5><p>数组是JavaScript中最常见的类型之一了,但是在我们实践过程中同样会遇到各种各样的麻烦.</p>\n<p><strong>稀疏数组</strong>:指的是含有空白或空缺单元的数组<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = [];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(a.length); <span class=\"comment\">//0</span></span><br><span class=\"line\"></span><br><span class=\"line\">a[<span class=\"number\">4</span>] = a[<span class=\"number\">5</span>];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(a.length); <span class=\"comment\">//5</span></span><br><span class=\"line\"></span><br><span class=\"line\">a.forEach(<span class=\"function\"><span class=\"params\">elem</span> =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(elem); <span class=\"comment\">//undefined</span></span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(a); <span class=\"comment\">//[,,,,undefined]</span></span><br></pre></td></tr></table></figure></p>\n<p>这里有几个坑需要注意:</p>\n<blockquote>\n<p><strong>1.</strong>一开始建立的空数组<code>a</code>的长度为<code>0</code>,这可以理解,但是在<code>a[4] = a[5]</code>之后出现了问题,<code>a</code>的长度居然变成了<code>5</code>,此时<code>a</code>数组是<code>[,,,,undefined]</code>这种形态.</p>\n</blockquote>\n<blockquote>\n<p><strong>2.</strong>我们通过遍历,只得到了<code>undefined</code>这一个值,这个<code>undefind</code>是由于<code>a[4] = a[5]</code>赋值,由于<code>a[5]</code>没有定义值为<code>undefined</code>被赋给了<code>a[4]</code>,可以等价为<code>a[4] = undefined</code>.</p>\n</blockquote>\n<p><strong>字符串索引</strong><br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = [];</span><br><span class=\"line\">a[<span class=\"number\">0</span>] = <span class=\"string\">'Bale'</span>;</span><br><span class=\"line\">a[<span class=\"string\">'age'</span>] = <span class=\"number\">28</span>;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(a.length); <span class=\"comment\">//1</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(a[<span class=\"string\">'age'</span>]); <span class=\"comment\">//28</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(a); <span class=\"comment\">//[ 'Bale', age: 28 ]</span></span><br></pre></td></tr></table></figure></p>\n<p>数组不仅可以通过数字索引,也可以通过字符串索引,但值得注意的是,字符串索引的键值对并不算在数组的长度里.</p>\n<h5 id=\"2-2-二进制浮点数\"><a href=\"#2-2-二进制浮点数\" class=\"headerlink\" title=\"2.2  二进制浮点数\"></a>2.2  二进制浮点数</h5><p>JavaScript 中的数字类型是基于“二进制浮点数”实现的,使用的是“双精度”格式,这就带来了一些反常的问题,我们那一道经典面试提来讲解下.<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"number\">0.1</span> + <span class=\"number\">0.2</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> b = <span class=\"number\">0.3</span>;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(a === b); <span class=\"comment\">//false</span></span><br></pre></td></tr></table></figure></p>\n<p>这是个出人意料的结果,实际上<code>a</code>的值约为<code>0.30000000000000004</code>这并不是一个整数值,这就是二进制浮点数带来的副作用.<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"number\">0.1</span> + <span class=\"number\">0.2</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> b = <span class=\"number\">0.3</span>;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(a === b); <span class=\"comment\">//false</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"built_in\">Number</span>.isInteger(a*<span class=\"number\">10</span>)); <span class=\"comment\">//false</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"built_in\">Number</span>.isInteger(b*<span class=\"number\">10</span>)); <span class=\"comment\">//true</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(a); <span class=\"comment\">//0.30000000000000004</span></span><br></pre></td></tr></table></figure></p>\n<p>我们可以用<code>Number.isInteger()</code>来判断一个数字是否为整数.</p>\n<p><strong>NaN</strong><br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"number\">1</span>/<span class=\"keyword\">new</span> <span class=\"built_in\">Object</span>();</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"keyword\">typeof</span> a); <span class=\"comment\">//Number</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(a); <span class=\"comment\">//NaN</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"built_in\">isNaN</span>(a)); <span class=\"comment\">//true</span></span><br></pre></td></tr></table></figure></p>\n<p><code>NaN</code>属于特殊的<code>Number</code>类型,我们可以把它理解为<strong>坏数值</strong>,因为它属于数值计算中的错误,更加特殊的是它自己都不等价于自己<code>NaN === NaN //false</code>,我们只能用<code>isNaN()</code>来检测一个数字是否为<code>NaN</code>.</p>\n<hr>\n<h4 id=\"3-类型转换原理\"><a href=\"#3-类型转换原理\" class=\"headerlink\" title=\"3.类型转换原理\"></a>3.类型转换原理</h4><p><strong>类型转换</strong>指的是将一种类型转换为另一种类型,例如:<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> b = <span class=\"number\">2</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"built_in\">String</span>(b);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"keyword\">typeof</span> a); <span class=\"comment\">//string</span></span><br></pre></td></tr></table></figure></p>\n<p>当然,<strong>类型转换</strong>分为显式和隐式,但是不管是隐式转换还是显式转换,都会遵循一定的原理,由于<code>JavaScript</code>是一门动态类型的语言,可以随时赋予任意值,但是各种运算符或条件判断中是需要特定类型的,因此<code>JavaScript</code>引擎会在运算时为变量设定类型.</p>\n<p>这看起来很美好,<code>JavaScript</code>引擎帮我们搞定了类型的问题,但是引擎毕竟不是ASI(超级人工智能),它的很多动作会跟我们预期相去甚远,我们可以从一道面试题开始.</p>\n<pre><code>{}+[] //0\n</code></pre><p>答案是0</p>\n<p>是什么原因造成了上述结果呢?那么我们得从<strong>ECMA-262</strong>中提到的转换规则和抽象操作说起,有兴趣的童鞋可以仔细阅读下这浩如烟海的<a href=\"http://ecma-international.org/ecma-262/5.1/\" target=\"_blank\" rel=\"noopener\">语言规范</a>,如果没这个耐心还是往下看.</p>\n<p>这是JavaScript种类型转换可以从<strong>原始类型</strong>转为<strong>引用类型</strong>,同样可以将<strong>引用类型</strong>转为<strong>原始类型</strong>,转为原始类型的抽象操作为<code>ToPrimitive</code>,而后续更加细分的操作为:<code>ToNumber</code> <code>ToString</code> <code>ToBoolean</code>,这三种抽象操作的转换表如下所示<br><img src=\"https://camo.githubusercontent.com/c6bc1eea15735abae88cf5f4565c1a64072952f7/687474703a2f2f6f6d7262677071796c2e626b742e636c6f7564646e2e636f6d2f31372d392d31332f31353531373233312e6a7067\" alt=\"转换规则\"></p>\n<p>如果想应付面试,我觉得这张表就差不多了,但是为了更深入的探究JavaScript引擎是如何处理代码中类型转换问题的,就需要看 ECMA-262详细的规范,从而探究其内部原理,我们从这段内部原理示意代码开始.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// ECMA-262, section 9.1, page 30. Use null/undefined for no hint,</span></span><br><span class=\"line\"><span class=\"comment\">// (1) for number hint, and (2) for string hint.</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">ToPrimitive</span>(<span class=\"params\">x, hint</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// Fast case check.</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (IS_STRING(x)) <span class=\"keyword\">return</span> x;</span><br><span class=\"line\">  <span class=\"comment\">// Normal behavior.</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!IS_SPEC_OBJECT(x)) <span class=\"keyword\">return</span> x;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (IS_SYMBOL_WRAPPER(x)) <span class=\"keyword\">throw</span> MakeTypeError(kSymbolToPrimitive);</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (hint == NO_HINT) hint = (IS_DATE(x)) ? STRING_HINT : NUMBER_HINT;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> (hint == NUMBER_HINT) ? DefaultNumber(x) : DefaultString(x);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// ECMA-262, section 8.6.2.6, page 28.</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">DefaultNumber</span>(<span class=\"params\">x</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!IS_SYMBOL_WRAPPER(x)) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> valueOf = x.valueOf;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (IS_SPEC_FUNCTION(valueOf)) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">var</span> v = %_CallFunction(x, valueOf);</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (IsPrimitive(v)) <span class=\"keyword\">return</span> v;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">var</span> toString = x.toString;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (IS_SPEC_FUNCTION(toString)) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">var</span> s = %_CallFunction(x, toString);</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (IsPrimitive(s)) <span class=\"keyword\">return</span> s;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">throw</span> MakeTypeError(kCannotConvertToPrimitive);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// ECMA-262, section 8.6.2.6, page 28.</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">DefaultString</span>(<span class=\"params\">x</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!IS_SYMBOL_WRAPPER(x)) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> toString = x.toString;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (IS_SPEC_FUNCTION(toString)) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">var</span> s = %_CallFunction(x, toString);</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (IsPrimitive(s)) <span class=\"keyword\">return</span> s;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">var</span> valueOf = x.valueOf;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (IS_SPEC_FUNCTION(valueOf)) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">var</span> v = %_CallFunction(x, valueOf);</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (IsPrimitive(v)) <span class=\"keyword\">return</span> v;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">throw</span> MakeTypeError(kCannotConvertToPrimitive);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>上面代码的逻辑是这样的：</p>\n<ol>\n<li>如果变量为字符串，直接返回.</li>\n<li>如果<code>!IS_SPEC_OBJECT(x)</code>，直接返回.</li>\n<li>如果<code>IS_SYMBOL_WRAPPER(x)</code>，则抛出异常.</li>\n<li>否则会根据传入的<code>hint</code>来调用<code>DefaultNumber</code>和<code>DefaultString</code>，比如如果为<code>Date</code>对象，会调用<code>DefaultString</code>.</li>\n<li><code>DefaultNumber</code>：首先<code>x.valueOf</code>，如果为<code>primitive</code>，则返回<code>valueOf</code>后的值，否则继续调用<code>x.toString</code>，如果为<code>primitive</code>，则返回<code>toString</code>后的值，否则抛出异常</li>\n<li><code>DefaultString</code>：和<code>DefaultNumber</code>正好相反，先调用<code>toString</code>，如果不是<code>primitive</code>再调用<code>valueOf</code>.</li>\n</ol>\n<p>那讲了实现原理，这个<code>ToPrimitive</code>有什么用呢？实际很多操作会调用<code>ToPrimitive</code>，比如加、相等或比较操。在进行加操作时会将左右操作数转换为<code>primitive</code>，然后进行相加。</p>\n<p>下面来个实例，<code>({}) + 1</code>（将<code>{}</code>放在括号中是为了内核将其认为一个代码块）会输出啥？可能日常写代码并不会这样写，不过网上出过类似的面试题。</p>\n<p>加操作只有左右运算符同时为<code>String</code>或<code>Number</code>时会执行对应的<code>%_StringAdd</code>或<code>%NumberAdd</code>，下面看下<code>({}) + 1</code>内部会经过哪些步骤：</p>\n<p><code>{}</code>和<code>1</code>首先会调用<code>ToPrimitive {}</code>会走到<code>DefaultNumber</code>，首先会调用<code>valueOf</code>，返回的是<code>Object {}</code>，不是<code>primitive</code>类型，从而继续走到<code>toString</code>，返回<code>[object Object]</code>，是<code>String</code>类型 最后加操作，结果为<code>[object Object]1</code> 再比如有人问你<code>[] + 1</code>输出啥时，你可能知道应该怎么去计算了，先对<code>[]</code>调用<code>ToPrimitive</code>，返回空字符串，最后结果为<code>&quot;1&quot;</code>。</p>\n","site":{"data":{}},"excerpt":"<h4 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h4><p>　　众所周知,JavaScript是动态弱类型的多范式编程语言,由于设计时的粗糙(当时设计js的初衷就是在浏览器中处理表单这种简单事件)导致JavaScript在许多方面表现出了这样或者那样的问题,其中’类型’便是语法层面最常见的’埋坑’重灾区. 　　</p>\n<blockquote>\n<p>JavaScript原始类型:Undefined、Null、Boolean、Number、String、Symbol</p>\n</blockquote>\n<blockquote>\n<p>JavaScript引用类型:Object</p>\n</blockquote>","more":"<hr>\n<h4 id=\"1-原始类型与引用类型\"><a href=\"#1-原始类型与引用类型\" class=\"headerlink\" title=\"1.原始类型与引用类型\"></a>1.原始类型与引用类型</h4><h5 id=\"1-1\"><a href=\"#1-1\" class=\"headerlink\" title=\"1.1\"></a>1.1</h5><p>&emsp;&emsp;<code>原始类型</code>又被称为<code>引用类型</code>，原始类型保存的变量和值直接保存在<code>栈内存(Stack)</code>中,且空间相互独立,通过值来访问,说到这里肯定一同懵逼,不过我们可以通过一个例子来解释.<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> person = <span class=\"string\">'Messi'</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> person1 = person;</span><br></pre></td></tr></table></figure></p>\n<p>上述代码在栈内存的示意图是这样的,可以看到,虽然<code>person</code>赋值给了<code>person1</code>.但是两个变量并没有指向同一个值,而是<code>person1</code>自己单独建立一个内存空间,虽然两个变量的值相等,但却是相互独立的.</p>\n<table><tr><td>person</td><td>Messi</td></tr><tr><td>person1</td><td>Messi</td></tr></table>\n\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> person = <span class=\"string\">'Messi'</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> person1 = person;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> person = <span class=\"number\">1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(person); <span class=\"comment\">//1</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(person1); <span class=\"comment\">//'Messi'</span></span><br></pre></td></tr></table></figure>\n<p>上述代码示意图是这样的,<code>person</code>的值虽然改变,但是由于<code>person1</code>的值是独立储存的,因此不受影响.</p>\n<p>值得一提的是,虽然原始类型的值是储存在相对独立空间,但是它们之间的比较是按值比较的.<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> person = <span class=\"string\">'Messi'</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> person1 = <span class=\"string\">'Messi'</span>;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(person === person1); <span class=\"comment\">//true</span></span><br></pre></td></tr></table></figure></p>\n<h5 id=\"1-2引用类型\"><a href=\"#1-2引用类型\" class=\"headerlink\" title=\"1.2引用类型\"></a>1.2引用类型</h5><p>剩下的就是引用类型了,即Object 类型,再往下细分，还可以分为：Object 类型、Array 类型、Date 类型、Function 类型 等。</p>\n<p>与原始类型不同的是,引用类型的内容是保存在<strong>堆内存</strong>中,而<strong>栈内存(Heap)</strong>中会有一个<strong>堆内存地址</strong>,通过这个地址变量被指向堆内存中<code>Object</code>真正的值,因此引用类型是按照引用访问的.</p>\n<p>下例能很清楚的说明引用类型的特质.<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = &#123;<span class=\"attr\">name</span>:<span class=\"string\">\"percy\"</span>&#125;;</span><br><span class=\"line\"><span class=\"keyword\">var</span> b;</span><br><span class=\"line\">b = a;</span><br><span class=\"line\">a.name = <span class=\"string\">\"zyj\"</span>;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(b.name);    <span class=\"comment\">// zyj</span></span><br><span class=\"line\">b.age = <span class=\"number\">22</span>;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(a.age);     <span class=\"comment\">// 22</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> c = &#123;</span><br><span class=\"line\">  name: <span class=\"string\">\"zyj\"</span>,</span><br><span class=\"line\">  age: <span class=\"number\">22</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(a === c); <span class=\"comment\">//false</span></span><br></pre></td></tr></table></figure></p>\n<p>我们可以逐行分析:<br>1.<code>b = a</code>,如果是原始类型的话,<code>b</code>会在栈内自己独自创建一个内存空间保存值,但是引用类型只是<code>b</code>的产生一个对内存地址,指向堆内存中的<code>Object</code>.<br>2.<code>a.name = &quot;zyj&quot;</code>,这个操作属于改变了变量的值,在原始类型中会重新建立新的内存空间(可以看上一节的示意图),而引用类型只需要自己在堆内存中更新自己的属性即可.<br>3.最后创建了一个新的对象<code>c</code>,看似跟<code>b</code> <code>a</code>一样,但是在堆内存中确实两个相互独立的<code>Object</code>,引用类型是按照<strong>引用比较</strong>,由于<code>a</code>  <code>c</code>引用的是不同的<code>Object</code>所以得到的结果是<code>fasle</code>.</p>\n<p><img src=\"https://camo.githubusercontent.com/d1293377721630c02f55d4201bf005eb6582de9b/687474703a2f2f6f6d7262677071796c2e626b742e636c6f7564646e2e636f6d2f31382d322d32302f33343330343934382e6a7067\" alt=\"指向问题\"></p>\n<hr>\n<h4 id=\"2-类型中的坑\"><a href=\"#2-类型中的坑\" class=\"headerlink\" title=\"2. 类型中的坑\"></a>2. 类型中的坑</h4><h5 id=\"2-1\"><a href=\"#2-1\" class=\"headerlink\" title=\"2.1\"></a>2.1</h5><p>数组是JavaScript中最常见的类型之一了,但是在我们实践过程中同样会遇到各种各样的麻烦.</p>\n<p><strong>稀疏数组</strong>:指的是含有空白或空缺单元的数组<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = [];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(a.length); <span class=\"comment\">//0</span></span><br><span class=\"line\"></span><br><span class=\"line\">a[<span class=\"number\">4</span>] = a[<span class=\"number\">5</span>];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(a.length); <span class=\"comment\">//5</span></span><br><span class=\"line\"></span><br><span class=\"line\">a.forEach(<span class=\"function\"><span class=\"params\">elem</span> =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(elem); <span class=\"comment\">//undefined</span></span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(a); <span class=\"comment\">//[,,,,undefined]</span></span><br></pre></td></tr></table></figure></p>\n<p>这里有几个坑需要注意:</p>\n<blockquote>\n<p><strong>1.</strong>一开始建立的空数组<code>a</code>的长度为<code>0</code>,这可以理解,但是在<code>a[4] = a[5]</code>之后出现了问题,<code>a</code>的长度居然变成了<code>5</code>,此时<code>a</code>数组是<code>[,,,,undefined]</code>这种形态.</p>\n</blockquote>\n<blockquote>\n<p><strong>2.</strong>我们通过遍历,只得到了<code>undefined</code>这一个值,这个<code>undefind</code>是由于<code>a[4] = a[5]</code>赋值,由于<code>a[5]</code>没有定义值为<code>undefined</code>被赋给了<code>a[4]</code>,可以等价为<code>a[4] = undefined</code>.</p>\n</blockquote>\n<p><strong>字符串索引</strong><br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = [];</span><br><span class=\"line\">a[<span class=\"number\">0</span>] = <span class=\"string\">'Bale'</span>;</span><br><span class=\"line\">a[<span class=\"string\">'age'</span>] = <span class=\"number\">28</span>;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(a.length); <span class=\"comment\">//1</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(a[<span class=\"string\">'age'</span>]); <span class=\"comment\">//28</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(a); <span class=\"comment\">//[ 'Bale', age: 28 ]</span></span><br></pre></td></tr></table></figure></p>\n<p>数组不仅可以通过数字索引,也可以通过字符串索引,但值得注意的是,字符串索引的键值对并不算在数组的长度里.</p>\n<h5 id=\"2-2-二进制浮点数\"><a href=\"#2-2-二进制浮点数\" class=\"headerlink\" title=\"2.2  二进制浮点数\"></a>2.2  二进制浮点数</h5><p>JavaScript 中的数字类型是基于“二进制浮点数”实现的,使用的是“双精度”格式,这就带来了一些反常的问题,我们那一道经典面试提来讲解下.<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"number\">0.1</span> + <span class=\"number\">0.2</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> b = <span class=\"number\">0.3</span>;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(a === b); <span class=\"comment\">//false</span></span><br></pre></td></tr></table></figure></p>\n<p>这是个出人意料的结果,实际上<code>a</code>的值约为<code>0.30000000000000004</code>这并不是一个整数值,这就是二进制浮点数带来的副作用.<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"number\">0.1</span> + <span class=\"number\">0.2</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> b = <span class=\"number\">0.3</span>;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(a === b); <span class=\"comment\">//false</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"built_in\">Number</span>.isInteger(a*<span class=\"number\">10</span>)); <span class=\"comment\">//false</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"built_in\">Number</span>.isInteger(b*<span class=\"number\">10</span>)); <span class=\"comment\">//true</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(a); <span class=\"comment\">//0.30000000000000004</span></span><br></pre></td></tr></table></figure></p>\n<p>我们可以用<code>Number.isInteger()</code>来判断一个数字是否为整数.</p>\n<p><strong>NaN</strong><br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"number\">1</span>/<span class=\"keyword\">new</span> <span class=\"built_in\">Object</span>();</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"keyword\">typeof</span> a); <span class=\"comment\">//Number</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(a); <span class=\"comment\">//NaN</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"built_in\">isNaN</span>(a)); <span class=\"comment\">//true</span></span><br></pre></td></tr></table></figure></p>\n<p><code>NaN</code>属于特殊的<code>Number</code>类型,我们可以把它理解为<strong>坏数值</strong>,因为它属于数值计算中的错误,更加特殊的是它自己都不等价于自己<code>NaN === NaN //false</code>,我们只能用<code>isNaN()</code>来检测一个数字是否为<code>NaN</code>.</p>\n<hr>\n<h4 id=\"3-类型转换原理\"><a href=\"#3-类型转换原理\" class=\"headerlink\" title=\"3.类型转换原理\"></a>3.类型转换原理</h4><p><strong>类型转换</strong>指的是将一种类型转换为另一种类型,例如:<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> b = <span class=\"number\">2</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"built_in\">String</span>(b);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"keyword\">typeof</span> a); <span class=\"comment\">//string</span></span><br></pre></td></tr></table></figure></p>\n<p>当然,<strong>类型转换</strong>分为显式和隐式,但是不管是隐式转换还是显式转换,都会遵循一定的原理,由于<code>JavaScript</code>是一门动态类型的语言,可以随时赋予任意值,但是各种运算符或条件判断中是需要特定类型的,因此<code>JavaScript</code>引擎会在运算时为变量设定类型.</p>\n<p>这看起来很美好,<code>JavaScript</code>引擎帮我们搞定了类型的问题,但是引擎毕竟不是ASI(超级人工智能),它的很多动作会跟我们预期相去甚远,我们可以从一道面试题开始.</p>\n<pre><code>{}+[] //0\n</code></pre><p>答案是0</p>\n<p>是什么原因造成了上述结果呢?那么我们得从<strong>ECMA-262</strong>中提到的转换规则和抽象操作说起,有兴趣的童鞋可以仔细阅读下这浩如烟海的<a href=\"http://ecma-international.org/ecma-262/5.1/\" target=\"_blank\" rel=\"noopener\">语言规范</a>,如果没这个耐心还是往下看.</p>\n<p>这是JavaScript种类型转换可以从<strong>原始类型</strong>转为<strong>引用类型</strong>,同样可以将<strong>引用类型</strong>转为<strong>原始类型</strong>,转为原始类型的抽象操作为<code>ToPrimitive</code>,而后续更加细分的操作为:<code>ToNumber</code> <code>ToString</code> <code>ToBoolean</code>,这三种抽象操作的转换表如下所示<br><img src=\"https://camo.githubusercontent.com/c6bc1eea15735abae88cf5f4565c1a64072952f7/687474703a2f2f6f6d7262677071796c2e626b742e636c6f7564646e2e636f6d2f31372d392d31332f31353531373233312e6a7067\" alt=\"转换规则\"></p>\n<p>如果想应付面试,我觉得这张表就差不多了,但是为了更深入的探究JavaScript引擎是如何处理代码中类型转换问题的,就需要看 ECMA-262详细的规范,从而探究其内部原理,我们从这段内部原理示意代码开始.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// ECMA-262, section 9.1, page 30. Use null/undefined for no hint,</span></span><br><span class=\"line\"><span class=\"comment\">// (1) for number hint, and (2) for string hint.</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">ToPrimitive</span>(<span class=\"params\">x, hint</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// Fast case check.</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (IS_STRING(x)) <span class=\"keyword\">return</span> x;</span><br><span class=\"line\">  <span class=\"comment\">// Normal behavior.</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!IS_SPEC_OBJECT(x)) <span class=\"keyword\">return</span> x;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (IS_SYMBOL_WRAPPER(x)) <span class=\"keyword\">throw</span> MakeTypeError(kSymbolToPrimitive);</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (hint == NO_HINT) hint = (IS_DATE(x)) ? STRING_HINT : NUMBER_HINT;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> (hint == NUMBER_HINT) ? DefaultNumber(x) : DefaultString(x);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// ECMA-262, section 8.6.2.6, page 28.</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">DefaultNumber</span>(<span class=\"params\">x</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!IS_SYMBOL_WRAPPER(x)) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> valueOf = x.valueOf;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (IS_SPEC_FUNCTION(valueOf)) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">var</span> v = %_CallFunction(x, valueOf);</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (IsPrimitive(v)) <span class=\"keyword\">return</span> v;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">var</span> toString = x.toString;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (IS_SPEC_FUNCTION(toString)) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">var</span> s = %_CallFunction(x, toString);</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (IsPrimitive(s)) <span class=\"keyword\">return</span> s;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">throw</span> MakeTypeError(kCannotConvertToPrimitive);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// ECMA-262, section 8.6.2.6, page 28.</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">DefaultString</span>(<span class=\"params\">x</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!IS_SYMBOL_WRAPPER(x)) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> toString = x.toString;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (IS_SPEC_FUNCTION(toString)) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">var</span> s = %_CallFunction(x, toString);</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (IsPrimitive(s)) <span class=\"keyword\">return</span> s;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">var</span> valueOf = x.valueOf;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (IS_SPEC_FUNCTION(valueOf)) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">var</span> v = %_CallFunction(x, valueOf);</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (IsPrimitive(v)) <span class=\"keyword\">return</span> v;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">throw</span> MakeTypeError(kCannotConvertToPrimitive);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>上面代码的逻辑是这样的：</p>\n<ol>\n<li>如果变量为字符串，直接返回.</li>\n<li>如果<code>!IS_SPEC_OBJECT(x)</code>，直接返回.</li>\n<li>如果<code>IS_SYMBOL_WRAPPER(x)</code>，则抛出异常.</li>\n<li>否则会根据传入的<code>hint</code>来调用<code>DefaultNumber</code>和<code>DefaultString</code>，比如如果为<code>Date</code>对象，会调用<code>DefaultString</code>.</li>\n<li><code>DefaultNumber</code>：首先<code>x.valueOf</code>，如果为<code>primitive</code>，则返回<code>valueOf</code>后的值，否则继续调用<code>x.toString</code>，如果为<code>primitive</code>，则返回<code>toString</code>后的值，否则抛出异常</li>\n<li><code>DefaultString</code>：和<code>DefaultNumber</code>正好相反，先调用<code>toString</code>，如果不是<code>primitive</code>再调用<code>valueOf</code>.</li>\n</ol>\n<p>那讲了实现原理，这个<code>ToPrimitive</code>有什么用呢？实际很多操作会调用<code>ToPrimitive</code>，比如加、相等或比较操。在进行加操作时会将左右操作数转换为<code>primitive</code>，然后进行相加。</p>\n<p>下面来个实例，<code>({}) + 1</code>（将<code>{}</code>放在括号中是为了内核将其认为一个代码块）会输出啥？可能日常写代码并不会这样写，不过网上出过类似的面试题。</p>\n<p>加操作只有左右运算符同时为<code>String</code>或<code>Number</code>时会执行对应的<code>%_StringAdd</code>或<code>%NumberAdd</code>，下面看下<code>({}) + 1</code>内部会经过哪些步骤：</p>\n<p><code>{}</code>和<code>1</code>首先会调用<code>ToPrimitive {}</code>会走到<code>DefaultNumber</code>，首先会调用<code>valueOf</code>，返回的是<code>Object {}</code>，不是<code>primitive</code>类型，从而继续走到<code>toString</code>，返回<code>[object Object]</code>，是<code>String</code>类型 最后加操作，结果为<code>[object Object]1</code> 再比如有人问你<code>[] + 1</code>输出啥时，你可能知道应该怎么去计算了，先对<code>[]</code>调用<code>ToPrimitive</code>，返回空字符串，最后结果为<code>&quot;1&quot;</code>。</p>"},{"title":"markdown摘要","date":"2018-05-11T09:57:40.000Z","_content":"### 概述\n#### 出发点\n本文主要是针对Markdown的中文文档进行整理，筛选出一些重点，查看更完整描述异步[中文文档](http://wowubuntu.com/markdown/index.html)\n\n<!--more-->\n#### 兼容HTML\nMarkdown 语法的目标是：成为一种适用于网络的书写语言。\nHTML 是一种**发布**的格式，Markdown 是一种**书写**的格式。\n\n不在 Markdown 涵盖范围之内的标签，都可以直接在文档里面用 HTML 撰写。不需要额外标注这是 HTML 或是 Markdown；只要直接加标签就可以了。\n\n请注意，在 HTML 区块标签间的 Markdown 格式语法将不会被处理。比如，你在 HTML 区块内使用 Markdown 样式的*强调*会没有效果。\n\nHTML 的区段（行内）标签如 `<span>`、`<cite>`、`<del>` 可以在 Markdown 的段落、列表或是标题里随意使用。依照个人习惯，甚至可以不用 Markdown 格式，而直接采用 HTML 标签来格式化。举例说明：如果比较喜欢 HTML 的 `<a>` 或 `<img>` 标签，可以直接使用这些标签，而不用 Markdown 提供的链接或是图像标签语法。\n\n和处在 HTML 区块标签间不同，Markdown 语法在 HTML 区段标签间是有效的。\n\n#### 标题\nMarkdown 支持两种标题的语法，类 Setext 和类 atx 形式。\n\n类 Setext 形式是用底线的形式，利用 = （最高阶标题）和 - （第二阶标题），例如：\n``` bash\nThis is an H1\n=============\n\nThis is an H2\n-------------\n```\n任何数量的 = 和 - 都可以有效果。(大于等于2)\n\n类 Atx 形式则是在行首插入 1 到 6 个 # ，对应到标题 1 到 6 阶，例如：\n```bash\n# 这是 H1\n\n## 这是 H2\n\n###### 这是 H6\n```\n\n#### 区块引用 Blockquotes\nMarkdown 标记区块引用是使用类似 email 中用 `>` 的引用方式。如果你还熟悉在 email 信件中的引言部分，你就知道怎么在 Markdown 文件中建立一个区块引用，那会看起来像是你自己先断好行，然后在每行的最前面加上 `>`：\n\n```bash\n> This is a blockquote with two paragraphs. Lorem ipsum dolor sit amet,\n> consectetuer adipiscing elit. Aliquam hendrerit mi posuere lectus.\n> Vestibulum enim wisi, viverra nec, fringilla in, laoreet vitae, risus.\n>\n> Donec sit amet nisl. Aliquam semper ipsum sit amet velit. Suspendisse\n> id sem consectetuer libero luctus adipiscing.\n```\n\nMarkdown 也允许你偷懒只在整个段落的第一行最前面加上 `>` ：\n```bash\n> This is a blockquote with two paragraphs. Lorem ipsum dolor sit amet,\nconsectetuer adipiscing elit. Aliquam hendrerit mi posuere lectus.\nVestibulum enim wisi, viverra nec, fringilla in, laoreet vitae, risus.\n\n> Donec sit amet nisl. Aliquam semper ipsum sit amet velit. Suspendisse\nid sem consectetuer libero luctus adipiscing.\n```\n区块引用可以嵌套（例如：引用内的引用），只要根据层次加上不同数量的 `>` ：\n```bash\n> This is the first level of quoting.\n>\n> > This is nested blockquote.\n>\n> Back to the first level.\n```\n引用的区块内也可以使用其他的 Markdown 语法，包括标题、列表、代码区块等：\n```bash\n> ## 这是一个标题。\n>\n> 1.   这是第一行列表项。\n> 2.   这是第二行列表项。\n>\n> 给出一些例子代码：\n>\n>     return shell_exec(\"echo $input | $markdown_script\");\n```\n\n#### 列表\nMarkdown 支持有序列表和无序列表。\n\n无序列表使用星号、加号或是减号作为列表标记：\n```bash\n*   Red\n*   Green\n*   Blue\n```\n等同于：\n```bash\n+   Red\n+   Green\n+   Blue\n```\n也等同于\n```bash\n-   Red\n-   Green\n-   Blue\n```\n\n有序列表则使用数字接着一个英文句点：\n```bash\n1. Amy\n2. Bob\n3. John\n```\n\n#### 代码区块\n和程序相关的写作或是标签语言原始码通常会有已经排版好的代码区块，通常这些区块我们并不希望它以一般段落文件的方式去排版，而是照原来的样子显示，Markdown 会用 `<pre>` 和 `<code>` 标签来把代码区块包起来。\n\n要在 Markdown 中建立代码区块很简单，只要简单地缩进 4 个空格或是 1 个制表符就可以，例如，下面的输入：\n\n```bash\n这是一个普通段落：\n\n    这是一个代码区块。\n```\nMarkdown 会转换成：\n\n```bash\n<p>这是一个普通段落：</p>\n\n<pre><code>这是一个代码区块。\n</code></pre>\n```\n\n#### 分隔线\n你可以在一行中用三个以上的星号、减号、底线来建立一个分隔线，行内不能有其他东西。你也可以在星号或是减号中间插入空格。下面每种写法都可以建立分隔线：\n\n```bash\n* * *\n\n***\n\n*****\n\n- - -\n\n---------------------------------------\n```\n---\n\n#### 链接\nMarkdown 支持两种形式的链接语法： **行内式**和**参考式**两种形式。\n\n不管是哪一种，链接文字都是用 [方括号] 来标记。\n\n要建立一个行内式的链接，只要在方块括号后面紧接着圆括号并插入网址链接即可，如果你还想要加上链接的 title 文字，只要在网址后面，用双引号把 title 文字包起来即可，例如：\n\n```bash\nThis is [an example](http://example.com/ \"Title\") inline link.\n\n[This link](http://example.net/) has no title attribute.\n```\n\n如果你是要链接到同样主机的资源，你可以使用相对路径：\n\n\tSee my [About](/about/) page for details.\n\n**参考式**的链接是在链接文字的括号后面再接上另一个方括号，而在第二个方括号里面要填入用以辨识链接的标记：\n\n\tThis is [an example][id] reference-style link.\n\n#### 强调\nMarkdown 使用星号（*）和底线（_）作为标记强调字词的符号，被 * 或 _ 包围的字词会被转成用 <em> 标签包围，用两个 * 或 _ 包起来的话，则会被转成 <strong>，例如：\n\n```bash\n*single asterisks*\n\n_single underscores_\n\n**double asterisks**\n\n__double underscores__\n```\n\n#### 图片\n很明显地，要在纯文字应用中设计一个「自然」的语法来插入图片是有一定难度的。\n\nMarkdown 使用一种和链接很相似的语法来标记图片，同样也允许两种样式： 行内式和参考式。\n\n行内式的图片语法看起来像是：\n\t![Alt text](/path/to/img.jpg)\n\n\t![Alt text](/path/to/img.jpg \"Optional title\")\n\n详细叙述如下：\n\n* 一个惊叹号 !\n* 接着一个方括号，里面放上图片的替代文字\n* 接着一个普通括号，里面放上图片的网址，最后还可以用引号包住并加上 选择性的 'title' 文字。\n\n参考式的图片语法则长得像这样：\n\n\t![Alt text][id]\n\n####其它\n#####自动链接\nMarkdown 支持以比较简短的自动链接形式来处理网址和电子邮件信箱，只要是用尖括号包起来， Markdown 就会自动把它转成链接。一般网址的链接文字就和链接地址一样，例如：\n\n\t<http://example.com/>\n\nMarkdown 会转为：\n\n\t<a href=\"http://example.com/\">http://example.com/</a>\n\n##### 反斜杠\nMarkdown 可以利用反斜杠来插入一些在语法中有其它意义的符号，例如：如果你想要用星号加在文字旁边的方式来做出强调效果（但不用 <em> 标签），你可以在星号的前面加上反斜杠：\n```bash\n\\*literal asterisks\\*\n```\nMarkdown 支持以下这些符号前面加上反斜杠来帮助插入普通的符号：\n```bash\n\\   反斜线\n`   反引号\n*   星号\n_   底线\n{}  花括号\n[]  方括号\n()  括弧\n#   井字号\n+   加号\n-   减号\n.   英文句点\n!   惊叹号\n```","source":"_posts/markdown摘要.md","raw":"---\ntitle: markdown摘要\ndate: 2018-05-11 17:57:40\ntags:\n    -markdown\ncategories:\n    - 技术分享\n---\n### 概述\n#### 出发点\n本文主要是针对Markdown的中文文档进行整理，筛选出一些重点，查看更完整描述异步[中文文档](http://wowubuntu.com/markdown/index.html)\n\n<!--more-->\n#### 兼容HTML\nMarkdown 语法的目标是：成为一种适用于网络的书写语言。\nHTML 是一种**发布**的格式，Markdown 是一种**书写**的格式。\n\n不在 Markdown 涵盖范围之内的标签，都可以直接在文档里面用 HTML 撰写。不需要额外标注这是 HTML 或是 Markdown；只要直接加标签就可以了。\n\n请注意，在 HTML 区块标签间的 Markdown 格式语法将不会被处理。比如，你在 HTML 区块内使用 Markdown 样式的*强调*会没有效果。\n\nHTML 的区段（行内）标签如 `<span>`、`<cite>`、`<del>` 可以在 Markdown 的段落、列表或是标题里随意使用。依照个人习惯，甚至可以不用 Markdown 格式，而直接采用 HTML 标签来格式化。举例说明：如果比较喜欢 HTML 的 `<a>` 或 `<img>` 标签，可以直接使用这些标签，而不用 Markdown 提供的链接或是图像标签语法。\n\n和处在 HTML 区块标签间不同，Markdown 语法在 HTML 区段标签间是有效的。\n\n#### 标题\nMarkdown 支持两种标题的语法，类 Setext 和类 atx 形式。\n\n类 Setext 形式是用底线的形式，利用 = （最高阶标题）和 - （第二阶标题），例如：\n``` bash\nThis is an H1\n=============\n\nThis is an H2\n-------------\n```\n任何数量的 = 和 - 都可以有效果。(大于等于2)\n\n类 Atx 形式则是在行首插入 1 到 6 个 # ，对应到标题 1 到 6 阶，例如：\n```bash\n# 这是 H1\n\n## 这是 H2\n\n###### 这是 H6\n```\n\n#### 区块引用 Blockquotes\nMarkdown 标记区块引用是使用类似 email 中用 `>` 的引用方式。如果你还熟悉在 email 信件中的引言部分，你就知道怎么在 Markdown 文件中建立一个区块引用，那会看起来像是你自己先断好行，然后在每行的最前面加上 `>`：\n\n```bash\n> This is a blockquote with two paragraphs. Lorem ipsum dolor sit amet,\n> consectetuer adipiscing elit. Aliquam hendrerit mi posuere lectus.\n> Vestibulum enim wisi, viverra nec, fringilla in, laoreet vitae, risus.\n>\n> Donec sit amet nisl. Aliquam semper ipsum sit amet velit. Suspendisse\n> id sem consectetuer libero luctus adipiscing.\n```\n\nMarkdown 也允许你偷懒只在整个段落的第一行最前面加上 `>` ：\n```bash\n> This is a blockquote with two paragraphs. Lorem ipsum dolor sit amet,\nconsectetuer adipiscing elit. Aliquam hendrerit mi posuere lectus.\nVestibulum enim wisi, viverra nec, fringilla in, laoreet vitae, risus.\n\n> Donec sit amet nisl. Aliquam semper ipsum sit amet velit. Suspendisse\nid sem consectetuer libero luctus adipiscing.\n```\n区块引用可以嵌套（例如：引用内的引用），只要根据层次加上不同数量的 `>` ：\n```bash\n> This is the first level of quoting.\n>\n> > This is nested blockquote.\n>\n> Back to the first level.\n```\n引用的区块内也可以使用其他的 Markdown 语法，包括标题、列表、代码区块等：\n```bash\n> ## 这是一个标题。\n>\n> 1.   这是第一行列表项。\n> 2.   这是第二行列表项。\n>\n> 给出一些例子代码：\n>\n>     return shell_exec(\"echo $input | $markdown_script\");\n```\n\n#### 列表\nMarkdown 支持有序列表和无序列表。\n\n无序列表使用星号、加号或是减号作为列表标记：\n```bash\n*   Red\n*   Green\n*   Blue\n```\n等同于：\n```bash\n+   Red\n+   Green\n+   Blue\n```\n也等同于\n```bash\n-   Red\n-   Green\n-   Blue\n```\n\n有序列表则使用数字接着一个英文句点：\n```bash\n1. Amy\n2. Bob\n3. John\n```\n\n#### 代码区块\n和程序相关的写作或是标签语言原始码通常会有已经排版好的代码区块，通常这些区块我们并不希望它以一般段落文件的方式去排版，而是照原来的样子显示，Markdown 会用 `<pre>` 和 `<code>` 标签来把代码区块包起来。\n\n要在 Markdown 中建立代码区块很简单，只要简单地缩进 4 个空格或是 1 个制表符就可以，例如，下面的输入：\n\n```bash\n这是一个普通段落：\n\n    这是一个代码区块。\n```\nMarkdown 会转换成：\n\n```bash\n<p>这是一个普通段落：</p>\n\n<pre><code>这是一个代码区块。\n</code></pre>\n```\n\n#### 分隔线\n你可以在一行中用三个以上的星号、减号、底线来建立一个分隔线，行内不能有其他东西。你也可以在星号或是减号中间插入空格。下面每种写法都可以建立分隔线：\n\n```bash\n* * *\n\n***\n\n*****\n\n- - -\n\n---------------------------------------\n```\n---\n\n#### 链接\nMarkdown 支持两种形式的链接语法： **行内式**和**参考式**两种形式。\n\n不管是哪一种，链接文字都是用 [方括号] 来标记。\n\n要建立一个行内式的链接，只要在方块括号后面紧接着圆括号并插入网址链接即可，如果你还想要加上链接的 title 文字，只要在网址后面，用双引号把 title 文字包起来即可，例如：\n\n```bash\nThis is [an example](http://example.com/ \"Title\") inline link.\n\n[This link](http://example.net/) has no title attribute.\n```\n\n如果你是要链接到同样主机的资源，你可以使用相对路径：\n\n\tSee my [About](/about/) page for details.\n\n**参考式**的链接是在链接文字的括号后面再接上另一个方括号，而在第二个方括号里面要填入用以辨识链接的标记：\n\n\tThis is [an example][id] reference-style link.\n\n#### 强调\nMarkdown 使用星号（*）和底线（_）作为标记强调字词的符号，被 * 或 _ 包围的字词会被转成用 <em> 标签包围，用两个 * 或 _ 包起来的话，则会被转成 <strong>，例如：\n\n```bash\n*single asterisks*\n\n_single underscores_\n\n**double asterisks**\n\n__double underscores__\n```\n\n#### 图片\n很明显地，要在纯文字应用中设计一个「自然」的语法来插入图片是有一定难度的。\n\nMarkdown 使用一种和链接很相似的语法来标记图片，同样也允许两种样式： 行内式和参考式。\n\n行内式的图片语法看起来像是：\n\t![Alt text](/path/to/img.jpg)\n\n\t![Alt text](/path/to/img.jpg \"Optional title\")\n\n详细叙述如下：\n\n* 一个惊叹号 !\n* 接着一个方括号，里面放上图片的替代文字\n* 接着一个普通括号，里面放上图片的网址，最后还可以用引号包住并加上 选择性的 'title' 文字。\n\n参考式的图片语法则长得像这样：\n\n\t![Alt text][id]\n\n####其它\n#####自动链接\nMarkdown 支持以比较简短的自动链接形式来处理网址和电子邮件信箱，只要是用尖括号包起来， Markdown 就会自动把它转成链接。一般网址的链接文字就和链接地址一样，例如：\n\n\t<http://example.com/>\n\nMarkdown 会转为：\n\n\t<a href=\"http://example.com/\">http://example.com/</a>\n\n##### 反斜杠\nMarkdown 可以利用反斜杠来插入一些在语法中有其它意义的符号，例如：如果你想要用星号加在文字旁边的方式来做出强调效果（但不用 <em> 标签），你可以在星号的前面加上反斜杠：\n```bash\n\\*literal asterisks\\*\n```\nMarkdown 支持以下这些符号前面加上反斜杠来帮助插入普通的符号：\n```bash\n\\   反斜线\n`   反引号\n*   星号\n_   底线\n{}  花括号\n[]  方括号\n()  括弧\n#   井字号\n+   加号\n-   减号\n.   英文句点\n!   惊叹号\n```","slug":"markdown摘要","published":1,"updated":"2018-05-11T09:59:29.327Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjhbjw6qp000hfx9mrktuj8za","content":"<h3 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h3><h4 id=\"出发点\"><a href=\"#出发点\" class=\"headerlink\" title=\"出发点\"></a>出发点</h4><p>本文主要是针对Markdown的中文文档进行整理，筛选出一些重点，查看更完整描述异步<a href=\"http://wowubuntu.com/markdown/index.html\" target=\"_blank\" rel=\"noopener\">中文文档</a></p>\n<a id=\"more\"></a>\n<h4 id=\"兼容HTML\"><a href=\"#兼容HTML\" class=\"headerlink\" title=\"兼容HTML\"></a>兼容HTML</h4><p>Markdown 语法的目标是：成为一种适用于网络的书写语言。<br>HTML 是一种<strong>发布</strong>的格式，Markdown 是一种<strong>书写</strong>的格式。</p>\n<p>不在 Markdown 涵盖范围之内的标签，都可以直接在文档里面用 HTML 撰写。不需要额外标注这是 HTML 或是 Markdown；只要直接加标签就可以了。</p>\n<p>请注意，在 HTML 区块标签间的 Markdown 格式语法将不会被处理。比如，你在 HTML 区块内使用 Markdown 样式的<em>强调</em>会没有效果。</p>\n<p>HTML 的区段（行内）标签如 <code>&lt;span&gt;</code>、<code>&lt;cite&gt;</code>、<code>&lt;del&gt;</code> 可以在 Markdown 的段落、列表或是标题里随意使用。依照个人习惯，甚至可以不用 Markdown 格式，而直接采用 HTML 标签来格式化。举例说明：如果比较喜欢 HTML 的 <code>&lt;a&gt;</code> 或 <code>&lt;img&gt;</code> 标签，可以直接使用这些标签，而不用 Markdown 提供的链接或是图像标签语法。</p>\n<p>和处在 HTML 区块标签间不同，Markdown 语法在 HTML 区段标签间是有效的。</p>\n<h4 id=\"标题\"><a href=\"#标题\" class=\"headerlink\" title=\"标题\"></a>标题</h4><p>Markdown 支持两种标题的语法，类 Setext 和类 atx 形式。</p>\n<p>类 Setext 形式是用底线的形式，利用 = （最高阶标题）和 - （第二阶标题），例如：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">This is an H1</span><br><span class=\"line\">=============</span><br><span class=\"line\"></span><br><span class=\"line\">This is an H2</span><br><span class=\"line\">-------------</span><br></pre></td></tr></table></figure></p>\n<p>任何数量的 = 和 - 都可以有效果。(大于等于2)</p>\n<p>类 Atx 形式则是在行首插入 1 到 6 个 # ，对应到标题 1 到 6 阶，例如：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 这是 H1</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">## 这是 H2</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">###### 这是 H6</span></span><br></pre></td></tr></table></figure></p>\n<h4 id=\"区块引用-Blockquotes\"><a href=\"#区块引用-Blockquotes\" class=\"headerlink\" title=\"区块引用 Blockquotes\"></a>区块引用 Blockquotes</h4><p>Markdown 标记区块引用是使用类似 email 中用 <code>&gt;</code> 的引用方式。如果你还熟悉在 email 信件中的引言部分，你就知道怎么在 Markdown 文件中建立一个区块引用，那会看起来像是你自己先断好行，然后在每行的最前面加上 <code>&gt;</code>：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; This is a blockquote with two paragraphs. Lorem ipsum dolor sit amet,</span><br><span class=\"line\">&gt; consectetuer adipiscing elit. Aliquam hendrerit mi posuere lectus.</span><br><span class=\"line\">&gt; Vestibulum enim wisi, viverra nec, fringilla <span class=\"keyword\">in</span>, laoreet vitae, risus.</span><br><span class=\"line\">&gt;</span><br><span class=\"line\">&gt; Donec sit amet nisl. Aliquam semper ipsum sit amet velit. Suspendisse</span><br><span class=\"line\">&gt; id sem consectetuer libero luctus adipiscing.</span><br></pre></td></tr></table></figure>\n<p>Markdown 也允许你偷懒只在整个段落的第一行最前面加上 <code>&gt;</code> ：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; This is a blockquote with two paragraphs. Lorem ipsum dolor sit amet,</span><br><span class=\"line\">consectetuer adipiscing elit. Aliquam hendrerit mi posuere lectus.</span><br><span class=\"line\">Vestibulum enim wisi, viverra nec, fringilla <span class=\"keyword\">in</span>, laoreet vitae, risus.</span><br><span class=\"line\"></span><br><span class=\"line\">&gt; Donec sit amet nisl. Aliquam semper ipsum sit amet velit. Suspendisse</span><br><span class=\"line\">id sem consectetuer libero luctus adipiscing.</span><br></pre></td></tr></table></figure></p>\n<p>区块引用可以嵌套（例如：引用内的引用），只要根据层次加上不同数量的 <code>&gt;</code> ：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; This is the first level of quoting.</span><br><span class=\"line\">&gt;</span><br><span class=\"line\">&gt; &gt; This is nested blockquote.</span><br><span class=\"line\">&gt;</span><br><span class=\"line\">&gt; Back to the first level.</span><br></pre></td></tr></table></figure></p>\n<p>引用的区块内也可以使用其他的 Markdown 语法，包括标题、列表、代码区块等：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; <span class=\"comment\">## 这是一个标题。</span></span><br><span class=\"line\">&gt;</span><br><span class=\"line\">&gt; 1.   这是第一行列表项。</span><br><span class=\"line\">&gt; 2.   这是第二行列表项。</span><br><span class=\"line\">&gt;</span><br><span class=\"line\">&gt; 给出一些例子代码：</span><br><span class=\"line\">&gt;</span><br><span class=\"line\">&gt;     <span class=\"built_in\">return</span> shell_exec(<span class=\"string\">\"echo <span class=\"variable\">$input</span> | <span class=\"variable\">$markdown_script</span>\"</span>);</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"列表\"><a href=\"#列表\" class=\"headerlink\" title=\"列表\"></a>列表</h4><p>Markdown 支持有序列表和无序列表。</p>\n<p>无序列表使用星号、加号或是减号作为列表标记：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">*   Red</span><br><span class=\"line\">*   Green</span><br><span class=\"line\">*   Blue</span><br></pre></td></tr></table></figure></p>\n<p>等同于：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">+   Red</span><br><span class=\"line\">+   Green</span><br><span class=\"line\">+   Blue</span><br></pre></td></tr></table></figure></p>\n<p>也等同于<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-   Red</span><br><span class=\"line\">-   Green</span><br><span class=\"line\">-   Blue</span><br></pre></td></tr></table></figure></p>\n<p>有序列表则使用数字接着一个英文句点：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1. Amy</span><br><span class=\"line\">2. Bob</span><br><span class=\"line\">3. John</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"代码区块\"><a href=\"#代码区块\" class=\"headerlink\" title=\"代码区块\"></a>代码区块</h4><p>和程序相关的写作或是标签语言原始码通常会有已经排版好的代码区块，通常这些区块我们并不希望它以一般段落文件的方式去排版，而是照原来的样子显示，Markdown 会用 <code>&lt;pre&gt;</code> 和 <code>&lt;code&gt;</code> 标签来把代码区块包起来。</p>\n<p>要在 Markdown 中建立代码区块很简单，只要简单地缩进 4 个空格或是 1 个制表符就可以，例如，下面的输入：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">这是一个普通段落：</span><br><span class=\"line\"></span><br><span class=\"line\">    这是一个代码区块。</span><br></pre></td></tr></table></figure>\n<p>Markdown 会转换成：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;p&gt;这是一个普通段落：&lt;/p&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;pre&gt;&lt;code&gt;这是一个代码区块。</span><br><span class=\"line\">&lt;/code&gt;&lt;/pre&gt;</span><br></pre></td></tr></table></figure>\n<h4 id=\"分隔线\"><a href=\"#分隔线\" class=\"headerlink\" title=\"分隔线\"></a>分隔线</h4><p>你可以在一行中用三个以上的星号、减号、底线来建立一个分隔线，行内不能有其他东西。你也可以在星号或是减号中间插入空格。下面每种写法都可以建立分隔线：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">* * *</span><br><span class=\"line\"></span><br><span class=\"line\">***</span><br><span class=\"line\"></span><br><span class=\"line\">*****</span><br><span class=\"line\"></span><br><span class=\"line\">- - -</span><br><span class=\"line\"></span><br><span class=\"line\">---------------------------------------</span><br></pre></td></tr></table></figure>\n<hr>\n<h4 id=\"链接\"><a href=\"#链接\" class=\"headerlink\" title=\"链接\"></a>链接</h4><p>Markdown 支持两种形式的链接语法： <strong>行内式</strong>和<strong>参考式</strong>两种形式。</p>\n<p>不管是哪一种，链接文字都是用 [方括号] 来标记。</p>\n<p>要建立一个行内式的链接，只要在方块括号后面紧接着圆括号并插入网址链接即可，如果你还想要加上链接的 title 文字，只要在网址后面，用双引号把 title 文字包起来即可，例如：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">This is [an example](http://example.com/ <span class=\"string\">\"Title\"</span>) inline link.</span><br><span class=\"line\"></span><br><span class=\"line\">[This link](http://example.net/) has no title attribute.</span><br></pre></td></tr></table></figure>\n<p>如果你是要链接到同样主机的资源，你可以使用相对路径：</p>\n<pre><code>See my [About](/about/) page for details.\n</code></pre><p><strong>参考式</strong>的链接是在链接文字的括号后面再接上另一个方括号，而在第二个方括号里面要填入用以辨识链接的标记：</p>\n<pre><code>This is [an example][id] reference-style link.\n</code></pre><h4 id=\"强调\"><a href=\"#强调\" class=\"headerlink\" title=\"强调\"></a>强调</h4><p>Markdown 使用星号（<em>）和底线（_）作为标记强调字词的符号，被 </em> 或 _ 包围的字词会被转成用 <em> 标签包围，用两个 * 或 _ 包起来的话，则会被转成 <strong>，例如：</strong></em></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">*single asterisks*</span><br><span class=\"line\"></span><br><span class=\"line\">_single underscores_</span><br><span class=\"line\"></span><br><span class=\"line\">**double asterisks**</span><br><span class=\"line\"></span><br><span class=\"line\">__double underscores__</span><br></pre></td></tr></table></figure>\n<h4 id=\"图片\"><a href=\"#图片\" class=\"headerlink\" title=\"图片\"></a>图片</h4><p>很明显地，要在纯文字应用中设计一个「自然」的语法来插入图片是有一定难度的。</p>\n<p>Markdown 使用一种和链接很相似的语法来标记图片，同样也允许两种样式： 行内式和参考式。</p>\n<p>行内式的图片语法看起来像是：<br>    <img src=\"/path/to/img.jpg\" alt=\"Alt text\"></p>\n<pre><code>![Alt text](/path/to/img.jpg &quot;Optional title&quot;)\n</code></pre><p>详细叙述如下：</p>\n<ul>\n<li>一个惊叹号 !</li>\n<li>接着一个方括号，里面放上图片的替代文字</li>\n<li>接着一个普通括号，里面放上图片的网址，最后还可以用引号包住并加上 选择性的 ‘title’ 文字。</li>\n</ul>\n<p>参考式的图片语法则长得像这样：</p>\n<pre><code>![Alt text][id]\n</code></pre><p>####其它</p>\n<p>#####自动链接<br>Markdown 支持以比较简短的自动链接形式来处理网址和电子邮件信箱，只要是用尖括号包起来， Markdown 就会自动把它转成链接。一般网址的链接文字就和链接地址一样，例如：</p>\n<pre><code>&lt;http://example.com/&gt;\n</code></pre><p>Markdown 会转为：</p>\n<pre><code>&lt;a href=&quot;http://example.com/&quot;&gt;http://example.com/&lt;/a&gt;\n</code></pre><h5 id=\"反斜杠\"><a href=\"#反斜杠\" class=\"headerlink\" title=\"反斜杠\"></a>反斜杠</h5><p>Markdown 可以利用反斜杠来插入一些在语法中有其它意义的符号，例如：如果你想要用星号加在文字旁边的方式来做出强调效果（但不用 <em> 标签），你可以在星号的前面加上反斜杠：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">\\*literal asterisks\\*</span><br></pre></td></tr></table></figure></em></p>\n<p>Markdown 支持以下这些符号前面加上反斜杠来帮助插入普通的符号：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">\\   反斜线</span><br><span class=\"line\">`   反引号</span><br><span class=\"line\">*   星号</span><br><span class=\"line\">_   底线</span><br><span class=\"line\">&#123;&#125;  花括号</span><br><span class=\"line\">[]  方括号</span><br><span class=\"line\">()  括弧</span><br><span class=\"line\"><span class=\"comment\">#   井字号</span></span><br><span class=\"line\">+   加号</span><br><span class=\"line\">-   减号</span><br><span class=\"line\">.   英文句点</span><br><span class=\"line\">!   惊叹号</span><br></pre></td></tr></table></figure></p>\n","site":{"data":{}},"excerpt":"<h3 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h3><h4 id=\"出发点\"><a href=\"#出发点\" class=\"headerlink\" title=\"出发点\"></a>出发点</h4><p>本文主要是针对Markdown的中文文档进行整理，筛选出一些重点，查看更完整描述异步<a href=\"http://wowubuntu.com/markdown/index.html\" target=\"_blank\" rel=\"noopener\">中文文档</a></p>","more":"<h4 id=\"兼容HTML\"><a href=\"#兼容HTML\" class=\"headerlink\" title=\"兼容HTML\"></a>兼容HTML</h4><p>Markdown 语法的目标是：成为一种适用于网络的书写语言。<br>HTML 是一种<strong>发布</strong>的格式，Markdown 是一种<strong>书写</strong>的格式。</p>\n<p>不在 Markdown 涵盖范围之内的标签，都可以直接在文档里面用 HTML 撰写。不需要额外标注这是 HTML 或是 Markdown；只要直接加标签就可以了。</p>\n<p>请注意，在 HTML 区块标签间的 Markdown 格式语法将不会被处理。比如，你在 HTML 区块内使用 Markdown 样式的<em>强调</em>会没有效果。</p>\n<p>HTML 的区段（行内）标签如 <code>&lt;span&gt;</code>、<code>&lt;cite&gt;</code>、<code>&lt;del&gt;</code> 可以在 Markdown 的段落、列表或是标题里随意使用。依照个人习惯，甚至可以不用 Markdown 格式，而直接采用 HTML 标签来格式化。举例说明：如果比较喜欢 HTML 的 <code>&lt;a&gt;</code> 或 <code>&lt;img&gt;</code> 标签，可以直接使用这些标签，而不用 Markdown 提供的链接或是图像标签语法。</p>\n<p>和处在 HTML 区块标签间不同，Markdown 语法在 HTML 区段标签间是有效的。</p>\n<h4 id=\"标题\"><a href=\"#标题\" class=\"headerlink\" title=\"标题\"></a>标题</h4><p>Markdown 支持两种标题的语法，类 Setext 和类 atx 形式。</p>\n<p>类 Setext 形式是用底线的形式，利用 = （最高阶标题）和 - （第二阶标题），例如：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">This is an H1</span><br><span class=\"line\">=============</span><br><span class=\"line\"></span><br><span class=\"line\">This is an H2</span><br><span class=\"line\">-------------</span><br></pre></td></tr></table></figure></p>\n<p>任何数量的 = 和 - 都可以有效果。(大于等于2)</p>\n<p>类 Atx 形式则是在行首插入 1 到 6 个 # ，对应到标题 1 到 6 阶，例如：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 这是 H1</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">## 这是 H2</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">###### 这是 H6</span></span><br></pre></td></tr></table></figure></p>\n<h4 id=\"区块引用-Blockquotes\"><a href=\"#区块引用-Blockquotes\" class=\"headerlink\" title=\"区块引用 Blockquotes\"></a>区块引用 Blockquotes</h4><p>Markdown 标记区块引用是使用类似 email 中用 <code>&gt;</code> 的引用方式。如果你还熟悉在 email 信件中的引言部分，你就知道怎么在 Markdown 文件中建立一个区块引用，那会看起来像是你自己先断好行，然后在每行的最前面加上 <code>&gt;</code>：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; This is a blockquote with two paragraphs. Lorem ipsum dolor sit amet,</span><br><span class=\"line\">&gt; consectetuer adipiscing elit. Aliquam hendrerit mi posuere lectus.</span><br><span class=\"line\">&gt; Vestibulum enim wisi, viverra nec, fringilla <span class=\"keyword\">in</span>, laoreet vitae, risus.</span><br><span class=\"line\">&gt;</span><br><span class=\"line\">&gt; Donec sit amet nisl. Aliquam semper ipsum sit amet velit. Suspendisse</span><br><span class=\"line\">&gt; id sem consectetuer libero luctus adipiscing.</span><br></pre></td></tr></table></figure>\n<p>Markdown 也允许你偷懒只在整个段落的第一行最前面加上 <code>&gt;</code> ：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; This is a blockquote with two paragraphs. Lorem ipsum dolor sit amet,</span><br><span class=\"line\">consectetuer adipiscing elit. Aliquam hendrerit mi posuere lectus.</span><br><span class=\"line\">Vestibulum enim wisi, viverra nec, fringilla <span class=\"keyword\">in</span>, laoreet vitae, risus.</span><br><span class=\"line\"></span><br><span class=\"line\">&gt; Donec sit amet nisl. Aliquam semper ipsum sit amet velit. Suspendisse</span><br><span class=\"line\">id sem consectetuer libero luctus adipiscing.</span><br></pre></td></tr></table></figure></p>\n<p>区块引用可以嵌套（例如：引用内的引用），只要根据层次加上不同数量的 <code>&gt;</code> ：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; This is the first level of quoting.</span><br><span class=\"line\">&gt;</span><br><span class=\"line\">&gt; &gt; This is nested blockquote.</span><br><span class=\"line\">&gt;</span><br><span class=\"line\">&gt; Back to the first level.</span><br></pre></td></tr></table></figure></p>\n<p>引用的区块内也可以使用其他的 Markdown 语法，包括标题、列表、代码区块等：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; <span class=\"comment\">## 这是一个标题。</span></span><br><span class=\"line\">&gt;</span><br><span class=\"line\">&gt; 1.   这是第一行列表项。</span><br><span class=\"line\">&gt; 2.   这是第二行列表项。</span><br><span class=\"line\">&gt;</span><br><span class=\"line\">&gt; 给出一些例子代码：</span><br><span class=\"line\">&gt;</span><br><span class=\"line\">&gt;     <span class=\"built_in\">return</span> shell_exec(<span class=\"string\">\"echo <span class=\"variable\">$input</span> | <span class=\"variable\">$markdown_script</span>\"</span>);</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"列表\"><a href=\"#列表\" class=\"headerlink\" title=\"列表\"></a>列表</h4><p>Markdown 支持有序列表和无序列表。</p>\n<p>无序列表使用星号、加号或是减号作为列表标记：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">*   Red</span><br><span class=\"line\">*   Green</span><br><span class=\"line\">*   Blue</span><br></pre></td></tr></table></figure></p>\n<p>等同于：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">+   Red</span><br><span class=\"line\">+   Green</span><br><span class=\"line\">+   Blue</span><br></pre></td></tr></table></figure></p>\n<p>也等同于<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-   Red</span><br><span class=\"line\">-   Green</span><br><span class=\"line\">-   Blue</span><br></pre></td></tr></table></figure></p>\n<p>有序列表则使用数字接着一个英文句点：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1. Amy</span><br><span class=\"line\">2. Bob</span><br><span class=\"line\">3. John</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"代码区块\"><a href=\"#代码区块\" class=\"headerlink\" title=\"代码区块\"></a>代码区块</h4><p>和程序相关的写作或是标签语言原始码通常会有已经排版好的代码区块，通常这些区块我们并不希望它以一般段落文件的方式去排版，而是照原来的样子显示，Markdown 会用 <code>&lt;pre&gt;</code> 和 <code>&lt;code&gt;</code> 标签来把代码区块包起来。</p>\n<p>要在 Markdown 中建立代码区块很简单，只要简单地缩进 4 个空格或是 1 个制表符就可以，例如，下面的输入：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">这是一个普通段落：</span><br><span class=\"line\"></span><br><span class=\"line\">    这是一个代码区块。</span><br></pre></td></tr></table></figure>\n<p>Markdown 会转换成：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;p&gt;这是一个普通段落：&lt;/p&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;pre&gt;&lt;code&gt;这是一个代码区块。</span><br><span class=\"line\">&lt;/code&gt;&lt;/pre&gt;</span><br></pre></td></tr></table></figure>\n<h4 id=\"分隔线\"><a href=\"#分隔线\" class=\"headerlink\" title=\"分隔线\"></a>分隔线</h4><p>你可以在一行中用三个以上的星号、减号、底线来建立一个分隔线，行内不能有其他东西。你也可以在星号或是减号中间插入空格。下面每种写法都可以建立分隔线：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">* * *</span><br><span class=\"line\"></span><br><span class=\"line\">***</span><br><span class=\"line\"></span><br><span class=\"line\">*****</span><br><span class=\"line\"></span><br><span class=\"line\">- - -</span><br><span class=\"line\"></span><br><span class=\"line\">---------------------------------------</span><br></pre></td></tr></table></figure>\n<hr>\n<h4 id=\"链接\"><a href=\"#链接\" class=\"headerlink\" title=\"链接\"></a>链接</h4><p>Markdown 支持两种形式的链接语法： <strong>行内式</strong>和<strong>参考式</strong>两种形式。</p>\n<p>不管是哪一种，链接文字都是用 [方括号] 来标记。</p>\n<p>要建立一个行内式的链接，只要在方块括号后面紧接着圆括号并插入网址链接即可，如果你还想要加上链接的 title 文字，只要在网址后面，用双引号把 title 文字包起来即可，例如：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">This is [an example](http://example.com/ <span class=\"string\">\"Title\"</span>) inline link.</span><br><span class=\"line\"></span><br><span class=\"line\">[This link](http://example.net/) has no title attribute.</span><br></pre></td></tr></table></figure>\n<p>如果你是要链接到同样主机的资源，你可以使用相对路径：</p>\n<pre><code>See my [About](/about/) page for details.\n</code></pre><p><strong>参考式</strong>的链接是在链接文字的括号后面再接上另一个方括号，而在第二个方括号里面要填入用以辨识链接的标记：</p>\n<pre><code>This is [an example][id] reference-style link.\n</code></pre><h4 id=\"强调\"><a href=\"#强调\" class=\"headerlink\" title=\"强调\"></a>强调</h4><p>Markdown 使用星号（<em>）和底线（_）作为标记强调字词的符号，被 </em> 或 _ 包围的字词会被转成用 <em> 标签包围，用两个 * 或 _ 包起来的话，则会被转成 <strong>，例如：</strong></em></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">*single asterisks*</span><br><span class=\"line\"></span><br><span class=\"line\">_single underscores_</span><br><span class=\"line\"></span><br><span class=\"line\">**double asterisks**</span><br><span class=\"line\"></span><br><span class=\"line\">__double underscores__</span><br></pre></td></tr></table></figure>\n<h4 id=\"图片\"><a href=\"#图片\" class=\"headerlink\" title=\"图片\"></a>图片</h4><p>很明显地，要在纯文字应用中设计一个「自然」的语法来插入图片是有一定难度的。</p>\n<p>Markdown 使用一种和链接很相似的语法来标记图片，同样也允许两种样式： 行内式和参考式。</p>\n<p>行内式的图片语法看起来像是：<br>    <img src=\"/path/to/img.jpg\" alt=\"Alt text\"></p>\n<pre><code>![Alt text](/path/to/img.jpg &quot;Optional title&quot;)\n</code></pre><p>详细叙述如下：</p>\n<ul>\n<li>一个惊叹号 !</li>\n<li>接着一个方括号，里面放上图片的替代文字</li>\n<li>接着一个普通括号，里面放上图片的网址，最后还可以用引号包住并加上 选择性的 ‘title’ 文字。</li>\n</ul>\n<p>参考式的图片语法则长得像这样：</p>\n<pre><code>![Alt text][id]\n</code></pre><p>####其它</p>\n<p>#####自动链接<br>Markdown 支持以比较简短的自动链接形式来处理网址和电子邮件信箱，只要是用尖括号包起来， Markdown 就会自动把它转成链接。一般网址的链接文字就和链接地址一样，例如：</p>\n<pre><code>&lt;http://example.com/&gt;\n</code></pre><p>Markdown 会转为：</p>\n<pre><code>&lt;a href=&quot;http://example.com/&quot;&gt;http://example.com/&lt;/a&gt;\n</code></pre><h5 id=\"反斜杠\"><a href=\"#反斜杠\" class=\"headerlink\" title=\"反斜杠\"></a>反斜杠</h5><p>Markdown 可以利用反斜杠来插入一些在语法中有其它意义的符号，例如：如果你想要用星号加在文字旁边的方式来做出强调效果（但不用 <em> 标签），你可以在星号的前面加上反斜杠：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">\\*literal asterisks\\*</span><br></pre></td></tr></table></figure></em></p>\n<p>Markdown 支持以下这些符号前面加上反斜杠来帮助插入普通的符号：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">\\   反斜线</span><br><span class=\"line\">`   反引号</span><br><span class=\"line\">*   星号</span><br><span class=\"line\">_   底线</span><br><span class=\"line\">&#123;&#125;  花括号</span><br><span class=\"line\">[]  方括号</span><br><span class=\"line\">()  括弧</span><br><span class=\"line\"><span class=\"comment\">#   井字号</span></span><br><span class=\"line\">+   加号</span><br><span class=\"line\">-   减号</span><br><span class=\"line\">.   英文句点</span><br><span class=\"line\">!   惊叹号</span><br></pre></td></tr></table></figure></p>"},{"title":"实现双向绑定Proxy比defineproperty优劣","date":"2018-05-08T03:00:13.000Z","_content":"\n#### 前言\n**双向绑定**其实已经是一个老掉牙的问题了,只要涉及到MVVM框架就不得不谈的知识点,但它毕竟是Vue的三要素之一.\n\n**Vue三要素**\n\n* 响应式: 例如如何监听数据变化,其中的实现方法就是我们提到的双向绑定\n* 模板引擎: 如何解析模板\n* 渲染: Vue如何将监听到的数据变化和解析后的HTML进行渲染\n\n可以实现双向绑定的方法有很多,KnockoutJS基于观察者模式的双向绑定,Ember基于数据模型的双向绑定,Angular基于脏检查的双向绑定,本篇文章我们重点讲面试中常见的基于**数据劫持**的双向绑定。\n<!-- more -->\n常见的基于数据劫持的双向绑定有两种实现,一个是目前Vue在用的`Object.defineProperty`,另一个是ES2015中新增的`Proxy`,而Vue的作者宣称将在Vue3.0版本后加入`Proxy`从而代替`Object.defineProperty`,通过本文你也可以知道为什么Vue未来会选择`Proxy`。\n\n> 严格来讲Proxy应该被称为『代理』而非『劫持』,不过由于作用有很多相似之处,我们在下文中就不再做区分,统一叫『劫持』。\n\n我们可以通过下图清楚看到以上两种方法在**双向绑定**体系中的关系.\n\n![](https://user-gold-cdn.xitu.io/2018/5/1/1631801840069098?imageslim)\n\n> 基于数据劫持的当然还有已经凉透的Object.observe方法,已被废弃。\n> 提前声明: 我们没有对传入的参数进行及时判断而规避错误,仅仅对核心方法进行了实现.\n\n***\n#### 1.基于数据劫持实现的双向绑定的特点\n##### 1.1 什么是数据劫持\n数据劫持比较好理解,通常我们利用`Object.defineProperty`劫持对象的访问器,在属性值发生变化时我们可以获取变化,从而进行进一步操作。\n```javascript\n// 这是将要被劫持的对象\nconst data = {\n  name: '',\n};\n\nfunction say(name) {\n  if (name === '古天乐') {\n    console.log('给大家推荐一款超好玩的游戏');\n  } else if (name === '渣渣辉') {\n    console.log('戏我演过很多,可游戏我只玩贪玩懒月');\n  } else {\n    console.log('来做我的兄弟');\n  }\n}\n\n// 遍历对象,对其属性值进行劫持\nObject.keys(data).forEach(function(key) {\n  Object.defineProperty(data, key, {\n    enumerable: true,\n    configurable: true,\n    get: function() {\n      console.log('get');\n    },\n    set: function(newVal) {\n      // 当属性值发生变化时我们可以进行额外操作\n      console.log(`大家好,我系${newVal}`);\n      say(newVal);\n    },\n  });\n});\n\ndata.name = '渣渣辉';\n//大家好,我系渣渣辉\n//戏我演过很多,可游戏我只玩贪玩懒月\n```\n\n##### 1.2 数据劫持的优势\n\n目前业界分为两个大的流派,一个是以React为首的单向数据绑定,另一个是以Angular、Vue为主的双向数据绑定。\n\n> 其实三大框架都是既可以双向绑定也可以单向绑定,比如React可以手动绑定onChange和value实现双向绑定,也可以调用一些双向绑定库,Vue也加入了props这种单向流的api,不过都并非主流卖点。\n\n单向或者双向的优劣不在我们的讨论范围,我们需要讨论一下对比其他双向绑定的实现方法,数据劫持的优势所在。\n\n1. 无需显示调用: 例如Vue运用数据劫持+发布订阅,直接可以通知变化并驱动视图,上面的例子也是比较简单的实现`data.name = '渣渣辉'`后直接触发变更,而比如Angular的脏检测则需要显示调用`markForCheck`(可以用zone.js避免显示调用,不展开),react需要显示调用`setState`。\n\n2. 可精确得知变化数据：还是上面的小例子，我们劫持了属性的setter,当属性值改变,我们可以精确获知变化的内容`newVal`,因此在这部分不需要额外的diff操作,否则我们只知道数据发生了变化而不知道具体哪些数据变化了,这个时候需要大量diff来找出变化值,这是额外性能损耗。\n\n##### 1.3 基于数据劫持双向绑定的实现思路\n\n**数据劫持**是双向绑定各种方案中比较流行的一种,最著名的实现就是Vue。\n\n基于数据劫持的双向绑定离不开`Proxy`与`Object.defineProperty`等方法对对象/对象属性的\"劫持\",我们要实现一个完整的双向绑定需要以下几个要点。\n\n1. 利用`Proxy`或`Object.defineProperty`生成的Observer针对对象/对象的属性进行\"劫持\",在属性发生变化后通知订阅者\n2. 解析器Compile解析模板中的`Directive`(指令)，收集指令所依赖的方法和数据,等待数据变化然后进行渲染\n3. Watcher属于Observer和Compile桥梁,它将接收到的Observer产生的数据变化,并根据Compile提供的指令进行视图渲染,使得数据变化促使视图变化\n\n![](https://user-gold-cdn.xitu.io/2018/4/11/162b38ab2d635662?imageslim)\n\n> 我们看到，虽然Vue运用了数据劫持，但是依然离不开发布订阅的模式，之所以在系列2做了[Event Bus](/blog/2018/04/23/vue-react-EventBus/#more)的实现,就是因为我们不管在学习一些框架的原理还是一些流行库（例如Redux、Vuex）,基本上都离不开发布订阅模式,而Event模块则是此模式的经典实现,所以如果不熟悉发布订阅模式,建议读一下系列2的文章。\n\n#### 2.基于Object.defineProperty双向绑定的特点\n关于`Object.defineProperty`的文章在网络上已经汗牛充栋,我们不想花过多时间在`Object.defineProperty`上面,本节我们主要讲解`Object.defineProperty`的特点,方便接下来与`Proxy`进行对比。\n\n> 对`Object.defineProperty`还不了解的请阅读[文档](https://link.juejin.im/?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fzh-CN%2Fdocs%2FWeb%2FJavaScript%2FReference%2FGlobal_Objects%2FObject%2FdefineProperty)\n\n两年前就有人写过基于`Object.defineProperty`实现的[文章](https://segmentfault.com/a/1190000006599500),想深入理解`Object.defineProperty`实现的推荐阅读,本文也做了相关参考。\n\n> 上面我们推荐的文章为比较完整的实现(400行代码),我们在本节只提供一个极简版(20行)和一个简化版(150行)的实现,读者可以循序渐进地阅读。\n\n##### 2.1 极简版的双向绑定\n\n我们都知道,`Object.defineProperty`的作用就是劫持一个对象的属性,通常我们对属性的`getter`和`setter`方法进行劫持,在对象的属性发生变化时进行特定的操作。\n\n我们就对对象`obj`的`text`属性进行劫持,在获取此属性的值时打印`'get val'`,在更改属性值的时候对DOM进行操作,这就是一个极简的双向绑定。\n\n```javascript\nconst obj = {};\nObject.defineProperty(obj, 'text', {\n  get: function() {\n    console.log('get val');&emsp;\n  },\n  set: function(newVal) {\n    console.log('set val:' + newVal);\n    document.getElementById('input').value = newVal;\n    document.getElementById('span').innerHTML = newVal;\n  }\n});\n\nconst input = document.getElementById('input');\ninput.addEventListener('keyup', function(e){\n  obj.text = e.target.value;\n})\n```\n在线示例[极简版双向绑定](https://codepen.io/experor-xxy/pen/BxJBZW)\n\n##### 2.2 升级改造\n我们很快会发现，这个所谓的双向绑定貌似并没有什么乱用。。。\n\n原因如下:\n\n1. 我们只监听了一个属性,一个对象不可能只有一个属性,我们需要对对象每个属性进行监听。\n2. 违反开放封闭原则,我们如果了解[开放封闭原则](https://link.juejin.im/?target=https%3A%2F%2Fzh.wikipedia.org%2Fzh-hans%2F%25E5%25BC%2580%25E9%2597%25AD%25E5%258E%259F%25E5%2588%2599)的话,上述代码是明显违反此原则,我们每次修改都需要进入方法内部,这是需要坚决杜绝的。\n3. 代码耦合严重,我们的数据、方法和DOM都是耦合在一起的，就是传说中的面条代码。\n\n那么如何解决上述问题？\n\nVue的操作就是加入了**发布订阅**模式，结合`Object.defineProperty`的劫持能力，实现了可用性很高的双向绑定。\n\n首先，我们以**发布订阅**的角度看我们第一部分写的那一坨代码,会发现它的监听、发布和订阅都是写在一起的,我们首先要做的就是解耦。\n\n我们先实现一个订阅发布中心，即消息管理员（Dep）,它负责储存订阅者和消息的分发,不管是订阅者还是发布者都需要依赖于它。\n\n```javascript\nlet uid = 0;\n  // 用于储存订阅者并发布消息\n  class Dep {\n    constructor() {\n      // 设置id,用于区分新Watcher和只改变属性值后新产生的Watcher\n      this.id = uid++;\n      // 储存订阅者的数组\n      this.subs = [];\n    }\n    // 触发target上的Watcher中的addDep方法,参数为dep的实例本身\n    depend() {\n      Dep.target.addDep(this);\n    }\n    // 添加订阅者\n    addSub(sub) {\n      this.subs.push(sub);\n    }\n    notify() {\n      // 通知所有的订阅者(Watcher)，触发订阅者的相应逻辑处理\n      this.subs.forEach(sub => sub.update());\n    }\n  }\n  // 为Dep类设置一个静态属性,默认为null,工作时指向当前的Watcher\n  Dep.target = null;\n```\n现在我们需要实现监听者(Observer),用于监听属性值的变化。\n```javascript\n// 监听者,监听对象属性值的变化\n  class Observer {\n    constructor(value) {\n      this.value = value;\n      this.walk(value);\n    }\n    // 遍历属性值并监听\n    walk(value) {\n      Object.keys(value).forEach(key => this.convert(key, value[key]));\n    }\n    // 执行监听的具体方法\n    convert(key, val) {\n      defineReactive(this.value, key, val);\n    }\n  }\n\n  function defineReactive(obj, key, val) {\n    const dep = new Dep();\n    // 给当前属性的值添加监听\n    let chlidOb = observe(val);\n    Object.defineProperty(obj, key, {\n      enumerable: true,\n      configurable: true,\n      get: () => {\n        // 如果Dep类存在target属性，将其添加到dep实例的subs数组中\n        // target指向一个Watcher实例，每个Watcher都是一个订阅者\n        // Watcher实例在实例化过程中，会读取data中的某个属性，从而触发当前get方法\n        if (Dep.target) {\n          dep.depend();\n        }\n        return val;\n      },\n      set: newVal => {\n        if (val === newVal) return;\n        val = newVal;\n        // 对新值进行监听\n        chlidOb = observe(newVal);\n        // 通知所有订阅者，数值被改变了\n        dep.notify();\n      },\n    });\n  }\n\n  function observe(value) {\n    // 当值不存在，或者不是复杂数据类型时，不再需要继续深入监听\n    if (!value || typeof value !== 'object') {\n      return;\n    }\n    return new Observer(value);\n  }\n```\n那么接下来就简单了,我们需要实现一个订阅者(Watcher)。\n```javascript\nclass Watcher {\n    constructor(vm, expOrFn, cb) {\n      this.depIds = {}; // hash储存订阅者的id,避免重复的订阅者\n      this.vm = vm; // 被订阅的数据一定来自于当前Vue实例\n      this.cb = cb; // 当数据更新时想要做的事情\n      this.expOrFn = expOrFn; // 被订阅的数据\n      this.val = this.get(); // 维护更新之前的数据\n    }\n    // 对外暴露的接口，用于在订阅的数据被更新时，由订阅者管理员(Dep)调用\n    update() {\n      this.run();\n    }\n    addDep(dep) {\n      // 如果在depIds的hash中没有当前的id,可以判断是新Watcher,因此可以添加到dep的数组中储存\n      // 此判断是避免同id的Watcher被多次储存\n      if (!this.depIds.hasOwnProperty(dep.id)) {\n        dep.addSub(this);\n        this.depIds[dep.id] = dep;\n      }\n    }\n    run() {\n      const val = this.get();\n      console.log(val);\n      if (val !== this.val) {\n        this.val = val;\n        this.cb.call(this.vm, val);\n      }\n    }\n    get() {\n      // 当前订阅者(Watcher)读取被订阅数据的最新更新后的值时，通知订阅者管理员收集当前订阅者\n      Dep.target = this;\n      const val = this.vm._data[this.expOrFn];\n      // 置空，用于下一个Watcher使用\n      Dep.target = null;\n      return val;\n    }\n  }\n```\n那么我们最后完成Vue,将上述方法挂载在Vue上。\n```javascript\nclass Vue {\n    constructor(options = {}) {\n      // 简化了$options的处理\n      this.$options = options;\n      // 简化了对data的处理\n      let data = (this._data = this.$options.data);\n      // 将所有data最外层属性代理到Vue实例上\n      Object.keys(data).forEach(key => this._proxy(key));\n      // 监听数据\n      observe(data);\n    }\n    // 对外暴露调用订阅者的接口，内部主要在指令中使用订阅者\n    $watch(expOrFn, cb) {\n      new Watcher(this, expOrFn, cb);\n    }\n    _proxy(key) {\n      Object.defineProperty(this, key, {\n        configurable: true,\n        enumerable: true,\n        get: () => this._data[key],\n        set: val => {\n          this._data[key] = val;\n        },\n      });\n    }\n  }\n```\n\n看下效果：\n&emsp;&emsp;&emsp;&emsp;![](https://user-gold-cdn.xitu.io/2018/5/1/1631c5aa9c52493e?imageslim)\n\n在线示例[双向绑定实现---无漏洞版](https://codepen.io/experor-xxy/pen/gzoYXL)\n\n至此,一个简单的双向绑定算是被我们实现了。\n\n##### 2.3 Object.defineProperty的缺陷\n其实我们升级版的双向绑定依然存在漏洞,比如我们将属性值改为数组。\n```javascript\nlet demo = new Vue({\n  data: {\n    list: [1],\n  },\n});\n\nconst list = document.getElementById('list');\nconst btn = document.getElementById('btn');\n\nbtn.addEventListener('click', function() {\n  demo.list.push(1);\n});\n\n\nconst render = arr => {\n  const fragment = document.createDocumentFragment();\n  for (let i = 0; i < arr.length; i++) {\n    const li = document.createElement('li');\n    li.textContent = arr[i];\n    fragment.appendChild(li);\n  }\n  list.appendChild(fragment);\n};\n\n// 监听数组,每次数组变化则触发渲染函数,然而...无法监听\ndemo.$watch('list', list => render(list));\n\nsetTimeout(\n  function() {\n    alert(demo.list);\n  },\n  5000,\n);\n```\n在线示例 [双向绑定-数组漏洞](https://codepen.io/experor-xxy/pen/VxyZXv)\n\n是的,`Object.defineProperty`的第一个缺陷,无法监听数组变化。 然而Vue的文档提到了Vue是可以检测到数组变化的，但是只有以下八种方法,`vm.items[indexOfItem] = newValue`这种是无法检测的。\n\n```javascript\npush()\npop()\nshift()\nunshift()\nsplice()\nsort()\nreverse()\n```\n其实作者在这里用了一些奇技淫巧,把无法监听数组的情况hack掉了,以下是方法示例。\n```javascript\nconst aryMethods = ['push', 'pop', 'shift', 'unshift', 'splice', 'sort', 'reverse'];\nconst arrayAugmentations = [];\n\naryMethods.forEach((method)=> {\n\n    // 这里是原生Array的原型方法\n    let original = Array.prototype[method];\n\n   // 将push, pop等封装好的方法定义在对象arrayAugmentations的属性上\n   // 注意：是属性而非原型属性\n    arrayAugmentations[method] = function () {\n        console.log('我被改变啦!');\n\n        // 调用对应的原生方法并返回结果\n        return original.apply(this, arguments);\n    };\n\n});\n\nlet list = ['a', 'b', 'c'];\n// 将我们要监听的数组的原型指针指向上面定义的空数组对象\n// 别忘了这个空数组的属性上定义了我们封装好的push等方法\nlist.__proto__ = arrayAugmentations;\nlist.push('d');  // 我被改变啦！ 4\n\n// 这里的list2没有被重新定义原型指针，所以就正常输出\nlet list2 = ['a', 'b', 'c'];\nlist2.push('d');  // 4\n```\n\n由于只针对了八种方法进行了hack,所以其他数组的属性也是检测不到的,其中的坑很多,可以阅读上面提到的文档。\n\n我们应该注意到在上文中的实现里,我们多次用遍历方法遍历对象的属性，这就引出了`Object.defineProperty`的第二个缺陷,只能劫持对象的属性,因此我们需要对每个对象的每个属性进行遍历，如果属性值也是对象那么需要深度遍历,显然能劫持一个完整的对象是更好的选择。\n\n\tObject.keys(value).forEach(key => this.convert(key, value[key]));\n\n***\n####3.Proxy实现的双向绑定的特点\n`Proxy`在ES2015规范中被正式发布,它在目标对象之前架设一层“拦截”，外界对该对象的访问，都必须先通过这层拦截，因此提供了一种机制，可以对外界的访问进行过滤和改写,我们可以这样认为,`Proxy`是`Object.defineProperty`的全方位加强版,具体的文档可以查看[此处](http://es6.ruanyifeng.com/#docs/proxy);\n\n##### 3.1 Proxy可以直接监听对象而非属性\n我们还是以上文中用`Object.defineProperty`实现的极简版双向绑定为例,用`Proxy`进行改写。\n```javascript\nconst input = document.getElementById('input');\nconst p = document.getElementById('p');\nconst obj = {};\n\nconst newObj = new Proxy(obj, {\n  get: function(target, key, receiver) {\n    console.log(`getting ${key}!`);\n    return Reflect.get(target, key, receiver);\n  },\n  set: function(target, key, value, receiver) {\n    console.log(target, key, value, receiver);\n    if (key === 'text') {\n      input.value = value;\n      p.innerHTML = value;\n    }\n    return Reflect.set(target, key, value, receiver);\n  },\n});\n\ninput.addEventListener('keyup', function(e) {\n  newObj.text = e.target.value;\n});\n```\n在线示例 [Proxy版](https://codepen.io/experor-xxy/pen/pVpvjg)\n\n我们可以看到,`Proxy`直接可以劫持整个对象,并返回一个新对象,不管是操作便利程度还是底层功能上都远强于`Object.defineProperty`。\n\n##### 3.2 Proxy可以直接监听数组的变化\n当我们对数组进行操作(`push`、`shift`、`splice`等)时，会触发对应的方法名称和`length`的变化，我们可以借此进行操作,以上文中`Object.defineProperty`无法生效的列表渲染为例。\n\n```javascript\nconst list = document.getElementById('list');\nconst btn = document.getElementById('btn');\n\n// 渲染列表\nconst Render = {\n  // 初始化\n  init: function(arr) {\n    const fragment = document.createDocumentFragment();\n    for (let i = 0; i < arr.length; i++) {\n      const li = document.createElement('li');\n      li.textContent = arr[i];\n      fragment.appendChild(li);\n    }\n    list.appendChild(fragment);\n  },\n  // 我们只考虑了增加的情况,仅作为示例\n  change: function(val) {\n    const li = document.createElement('li');\n    li.textContent = val;\n    list.appendChild(li);\n  },\n};\n\n// 初始数组\nconst arr = [1, 2, 3, 4];\n\n// 监听数组\nconst newArr = new Proxy(arr, {\n  get: function(target, key, receiver) {\n    console.log(key);\n    return Reflect.get(target, key, receiver);\n  },\n  set: function(target, key, value, receiver) {\n    console.log(target, key, value, receiver);\n    if (key !== 'length') {\n      Render.change(value);\n    }\n    return Reflect.set(target, key, value, receiver);\n  },\n});\n\n// 初始化\nwindow.onload = function() {\n    Render.init(arr);\n}\n\n// push数字\nbtn.addEventListener('click', function() {\n  newArr.push(6);\n});\n```\n\n在线示例 [Proxy列表渲染](https://codepen.io/experor-xxy/pen/qYpEbx)\n\n很显然,Proxy不需要那么多hack（即使hack也无法完美实现监听）就可以无压力监听数组的变化,我们都知道,标准永远优先于hack。\n\n##### 3.3 Proxy的其他优势\n\nProxy有多达13种拦截方法,不限于`apply`、`ownKeys`、`deleteProperty`、`has`等等是`Object.defineProperty`不具备的。\n\nProxy返回的是一个新对象,我们可以只操作新的对象达到目的,而`Object.defineProperty`只能遍历对象属性直接修改。\n\nProxy作为新标准将受到浏览器厂商重点持续的性能优化，也就是传说中的新标准的性能红利。\n\n当然,Proxy的劣势就是兼容性问题,而且无法用polyfill磨平,因此Vue的作者才声明需要等到下个大版本(3.0)才能用Proxy重写。\n\n","source":"_posts/vue-proxy_defineproperty优劣.md","raw":"---\ntitle: 实现双向绑定Proxy比defineproperty优劣\ndate: 2018-05-08 11:00:13\ntags:\n    - vue\n    - proxy\n    - defineproperty\ncategories:\n    - 面试题\n    - vue\n---\n\n#### 前言\n**双向绑定**其实已经是一个老掉牙的问题了,只要涉及到MVVM框架就不得不谈的知识点,但它毕竟是Vue的三要素之一.\n\n**Vue三要素**\n\n* 响应式: 例如如何监听数据变化,其中的实现方法就是我们提到的双向绑定\n* 模板引擎: 如何解析模板\n* 渲染: Vue如何将监听到的数据变化和解析后的HTML进行渲染\n\n可以实现双向绑定的方法有很多,KnockoutJS基于观察者模式的双向绑定,Ember基于数据模型的双向绑定,Angular基于脏检查的双向绑定,本篇文章我们重点讲面试中常见的基于**数据劫持**的双向绑定。\n<!-- more -->\n常见的基于数据劫持的双向绑定有两种实现,一个是目前Vue在用的`Object.defineProperty`,另一个是ES2015中新增的`Proxy`,而Vue的作者宣称将在Vue3.0版本后加入`Proxy`从而代替`Object.defineProperty`,通过本文你也可以知道为什么Vue未来会选择`Proxy`。\n\n> 严格来讲Proxy应该被称为『代理』而非『劫持』,不过由于作用有很多相似之处,我们在下文中就不再做区分,统一叫『劫持』。\n\n我们可以通过下图清楚看到以上两种方法在**双向绑定**体系中的关系.\n\n![](https://user-gold-cdn.xitu.io/2018/5/1/1631801840069098?imageslim)\n\n> 基于数据劫持的当然还有已经凉透的Object.observe方法,已被废弃。\n> 提前声明: 我们没有对传入的参数进行及时判断而规避错误,仅仅对核心方法进行了实现.\n\n***\n#### 1.基于数据劫持实现的双向绑定的特点\n##### 1.1 什么是数据劫持\n数据劫持比较好理解,通常我们利用`Object.defineProperty`劫持对象的访问器,在属性值发生变化时我们可以获取变化,从而进行进一步操作。\n```javascript\n// 这是将要被劫持的对象\nconst data = {\n  name: '',\n};\n\nfunction say(name) {\n  if (name === '古天乐') {\n    console.log('给大家推荐一款超好玩的游戏');\n  } else if (name === '渣渣辉') {\n    console.log('戏我演过很多,可游戏我只玩贪玩懒月');\n  } else {\n    console.log('来做我的兄弟');\n  }\n}\n\n// 遍历对象,对其属性值进行劫持\nObject.keys(data).forEach(function(key) {\n  Object.defineProperty(data, key, {\n    enumerable: true,\n    configurable: true,\n    get: function() {\n      console.log('get');\n    },\n    set: function(newVal) {\n      // 当属性值发生变化时我们可以进行额外操作\n      console.log(`大家好,我系${newVal}`);\n      say(newVal);\n    },\n  });\n});\n\ndata.name = '渣渣辉';\n//大家好,我系渣渣辉\n//戏我演过很多,可游戏我只玩贪玩懒月\n```\n\n##### 1.2 数据劫持的优势\n\n目前业界分为两个大的流派,一个是以React为首的单向数据绑定,另一个是以Angular、Vue为主的双向数据绑定。\n\n> 其实三大框架都是既可以双向绑定也可以单向绑定,比如React可以手动绑定onChange和value实现双向绑定,也可以调用一些双向绑定库,Vue也加入了props这种单向流的api,不过都并非主流卖点。\n\n单向或者双向的优劣不在我们的讨论范围,我们需要讨论一下对比其他双向绑定的实现方法,数据劫持的优势所在。\n\n1. 无需显示调用: 例如Vue运用数据劫持+发布订阅,直接可以通知变化并驱动视图,上面的例子也是比较简单的实现`data.name = '渣渣辉'`后直接触发变更,而比如Angular的脏检测则需要显示调用`markForCheck`(可以用zone.js避免显示调用,不展开),react需要显示调用`setState`。\n\n2. 可精确得知变化数据：还是上面的小例子，我们劫持了属性的setter,当属性值改变,我们可以精确获知变化的内容`newVal`,因此在这部分不需要额外的diff操作,否则我们只知道数据发生了变化而不知道具体哪些数据变化了,这个时候需要大量diff来找出变化值,这是额外性能损耗。\n\n##### 1.3 基于数据劫持双向绑定的实现思路\n\n**数据劫持**是双向绑定各种方案中比较流行的一种,最著名的实现就是Vue。\n\n基于数据劫持的双向绑定离不开`Proxy`与`Object.defineProperty`等方法对对象/对象属性的\"劫持\",我们要实现一个完整的双向绑定需要以下几个要点。\n\n1. 利用`Proxy`或`Object.defineProperty`生成的Observer针对对象/对象的属性进行\"劫持\",在属性发生变化后通知订阅者\n2. 解析器Compile解析模板中的`Directive`(指令)，收集指令所依赖的方法和数据,等待数据变化然后进行渲染\n3. Watcher属于Observer和Compile桥梁,它将接收到的Observer产生的数据变化,并根据Compile提供的指令进行视图渲染,使得数据变化促使视图变化\n\n![](https://user-gold-cdn.xitu.io/2018/4/11/162b38ab2d635662?imageslim)\n\n> 我们看到，虽然Vue运用了数据劫持，但是依然离不开发布订阅的模式，之所以在系列2做了[Event Bus](/blog/2018/04/23/vue-react-EventBus/#more)的实现,就是因为我们不管在学习一些框架的原理还是一些流行库（例如Redux、Vuex）,基本上都离不开发布订阅模式,而Event模块则是此模式的经典实现,所以如果不熟悉发布订阅模式,建议读一下系列2的文章。\n\n#### 2.基于Object.defineProperty双向绑定的特点\n关于`Object.defineProperty`的文章在网络上已经汗牛充栋,我们不想花过多时间在`Object.defineProperty`上面,本节我们主要讲解`Object.defineProperty`的特点,方便接下来与`Proxy`进行对比。\n\n> 对`Object.defineProperty`还不了解的请阅读[文档](https://link.juejin.im/?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fzh-CN%2Fdocs%2FWeb%2FJavaScript%2FReference%2FGlobal_Objects%2FObject%2FdefineProperty)\n\n两年前就有人写过基于`Object.defineProperty`实现的[文章](https://segmentfault.com/a/1190000006599500),想深入理解`Object.defineProperty`实现的推荐阅读,本文也做了相关参考。\n\n> 上面我们推荐的文章为比较完整的实现(400行代码),我们在本节只提供一个极简版(20行)和一个简化版(150行)的实现,读者可以循序渐进地阅读。\n\n##### 2.1 极简版的双向绑定\n\n我们都知道,`Object.defineProperty`的作用就是劫持一个对象的属性,通常我们对属性的`getter`和`setter`方法进行劫持,在对象的属性发生变化时进行特定的操作。\n\n我们就对对象`obj`的`text`属性进行劫持,在获取此属性的值时打印`'get val'`,在更改属性值的时候对DOM进行操作,这就是一个极简的双向绑定。\n\n```javascript\nconst obj = {};\nObject.defineProperty(obj, 'text', {\n  get: function() {\n    console.log('get val');&emsp;\n  },\n  set: function(newVal) {\n    console.log('set val:' + newVal);\n    document.getElementById('input').value = newVal;\n    document.getElementById('span').innerHTML = newVal;\n  }\n});\n\nconst input = document.getElementById('input');\ninput.addEventListener('keyup', function(e){\n  obj.text = e.target.value;\n})\n```\n在线示例[极简版双向绑定](https://codepen.io/experor-xxy/pen/BxJBZW)\n\n##### 2.2 升级改造\n我们很快会发现，这个所谓的双向绑定貌似并没有什么乱用。。。\n\n原因如下:\n\n1. 我们只监听了一个属性,一个对象不可能只有一个属性,我们需要对对象每个属性进行监听。\n2. 违反开放封闭原则,我们如果了解[开放封闭原则](https://link.juejin.im/?target=https%3A%2F%2Fzh.wikipedia.org%2Fzh-hans%2F%25E5%25BC%2580%25E9%2597%25AD%25E5%258E%259F%25E5%2588%2599)的话,上述代码是明显违反此原则,我们每次修改都需要进入方法内部,这是需要坚决杜绝的。\n3. 代码耦合严重,我们的数据、方法和DOM都是耦合在一起的，就是传说中的面条代码。\n\n那么如何解决上述问题？\n\nVue的操作就是加入了**发布订阅**模式，结合`Object.defineProperty`的劫持能力，实现了可用性很高的双向绑定。\n\n首先，我们以**发布订阅**的角度看我们第一部分写的那一坨代码,会发现它的监听、发布和订阅都是写在一起的,我们首先要做的就是解耦。\n\n我们先实现一个订阅发布中心，即消息管理员（Dep）,它负责储存订阅者和消息的分发,不管是订阅者还是发布者都需要依赖于它。\n\n```javascript\nlet uid = 0;\n  // 用于储存订阅者并发布消息\n  class Dep {\n    constructor() {\n      // 设置id,用于区分新Watcher和只改变属性值后新产生的Watcher\n      this.id = uid++;\n      // 储存订阅者的数组\n      this.subs = [];\n    }\n    // 触发target上的Watcher中的addDep方法,参数为dep的实例本身\n    depend() {\n      Dep.target.addDep(this);\n    }\n    // 添加订阅者\n    addSub(sub) {\n      this.subs.push(sub);\n    }\n    notify() {\n      // 通知所有的订阅者(Watcher)，触发订阅者的相应逻辑处理\n      this.subs.forEach(sub => sub.update());\n    }\n  }\n  // 为Dep类设置一个静态属性,默认为null,工作时指向当前的Watcher\n  Dep.target = null;\n```\n现在我们需要实现监听者(Observer),用于监听属性值的变化。\n```javascript\n// 监听者,监听对象属性值的变化\n  class Observer {\n    constructor(value) {\n      this.value = value;\n      this.walk(value);\n    }\n    // 遍历属性值并监听\n    walk(value) {\n      Object.keys(value).forEach(key => this.convert(key, value[key]));\n    }\n    // 执行监听的具体方法\n    convert(key, val) {\n      defineReactive(this.value, key, val);\n    }\n  }\n\n  function defineReactive(obj, key, val) {\n    const dep = new Dep();\n    // 给当前属性的值添加监听\n    let chlidOb = observe(val);\n    Object.defineProperty(obj, key, {\n      enumerable: true,\n      configurable: true,\n      get: () => {\n        // 如果Dep类存在target属性，将其添加到dep实例的subs数组中\n        // target指向一个Watcher实例，每个Watcher都是一个订阅者\n        // Watcher实例在实例化过程中，会读取data中的某个属性，从而触发当前get方法\n        if (Dep.target) {\n          dep.depend();\n        }\n        return val;\n      },\n      set: newVal => {\n        if (val === newVal) return;\n        val = newVal;\n        // 对新值进行监听\n        chlidOb = observe(newVal);\n        // 通知所有订阅者，数值被改变了\n        dep.notify();\n      },\n    });\n  }\n\n  function observe(value) {\n    // 当值不存在，或者不是复杂数据类型时，不再需要继续深入监听\n    if (!value || typeof value !== 'object') {\n      return;\n    }\n    return new Observer(value);\n  }\n```\n那么接下来就简单了,我们需要实现一个订阅者(Watcher)。\n```javascript\nclass Watcher {\n    constructor(vm, expOrFn, cb) {\n      this.depIds = {}; // hash储存订阅者的id,避免重复的订阅者\n      this.vm = vm; // 被订阅的数据一定来自于当前Vue实例\n      this.cb = cb; // 当数据更新时想要做的事情\n      this.expOrFn = expOrFn; // 被订阅的数据\n      this.val = this.get(); // 维护更新之前的数据\n    }\n    // 对外暴露的接口，用于在订阅的数据被更新时，由订阅者管理员(Dep)调用\n    update() {\n      this.run();\n    }\n    addDep(dep) {\n      // 如果在depIds的hash中没有当前的id,可以判断是新Watcher,因此可以添加到dep的数组中储存\n      // 此判断是避免同id的Watcher被多次储存\n      if (!this.depIds.hasOwnProperty(dep.id)) {\n        dep.addSub(this);\n        this.depIds[dep.id] = dep;\n      }\n    }\n    run() {\n      const val = this.get();\n      console.log(val);\n      if (val !== this.val) {\n        this.val = val;\n        this.cb.call(this.vm, val);\n      }\n    }\n    get() {\n      // 当前订阅者(Watcher)读取被订阅数据的最新更新后的值时，通知订阅者管理员收集当前订阅者\n      Dep.target = this;\n      const val = this.vm._data[this.expOrFn];\n      // 置空，用于下一个Watcher使用\n      Dep.target = null;\n      return val;\n    }\n  }\n```\n那么我们最后完成Vue,将上述方法挂载在Vue上。\n```javascript\nclass Vue {\n    constructor(options = {}) {\n      // 简化了$options的处理\n      this.$options = options;\n      // 简化了对data的处理\n      let data = (this._data = this.$options.data);\n      // 将所有data最外层属性代理到Vue实例上\n      Object.keys(data).forEach(key => this._proxy(key));\n      // 监听数据\n      observe(data);\n    }\n    // 对外暴露调用订阅者的接口，内部主要在指令中使用订阅者\n    $watch(expOrFn, cb) {\n      new Watcher(this, expOrFn, cb);\n    }\n    _proxy(key) {\n      Object.defineProperty(this, key, {\n        configurable: true,\n        enumerable: true,\n        get: () => this._data[key],\n        set: val => {\n          this._data[key] = val;\n        },\n      });\n    }\n  }\n```\n\n看下效果：\n&emsp;&emsp;&emsp;&emsp;![](https://user-gold-cdn.xitu.io/2018/5/1/1631c5aa9c52493e?imageslim)\n\n在线示例[双向绑定实现---无漏洞版](https://codepen.io/experor-xxy/pen/gzoYXL)\n\n至此,一个简单的双向绑定算是被我们实现了。\n\n##### 2.3 Object.defineProperty的缺陷\n其实我们升级版的双向绑定依然存在漏洞,比如我们将属性值改为数组。\n```javascript\nlet demo = new Vue({\n  data: {\n    list: [1],\n  },\n});\n\nconst list = document.getElementById('list');\nconst btn = document.getElementById('btn');\n\nbtn.addEventListener('click', function() {\n  demo.list.push(1);\n});\n\n\nconst render = arr => {\n  const fragment = document.createDocumentFragment();\n  for (let i = 0; i < arr.length; i++) {\n    const li = document.createElement('li');\n    li.textContent = arr[i];\n    fragment.appendChild(li);\n  }\n  list.appendChild(fragment);\n};\n\n// 监听数组,每次数组变化则触发渲染函数,然而...无法监听\ndemo.$watch('list', list => render(list));\n\nsetTimeout(\n  function() {\n    alert(demo.list);\n  },\n  5000,\n);\n```\n在线示例 [双向绑定-数组漏洞](https://codepen.io/experor-xxy/pen/VxyZXv)\n\n是的,`Object.defineProperty`的第一个缺陷,无法监听数组变化。 然而Vue的文档提到了Vue是可以检测到数组变化的，但是只有以下八种方法,`vm.items[indexOfItem] = newValue`这种是无法检测的。\n\n```javascript\npush()\npop()\nshift()\nunshift()\nsplice()\nsort()\nreverse()\n```\n其实作者在这里用了一些奇技淫巧,把无法监听数组的情况hack掉了,以下是方法示例。\n```javascript\nconst aryMethods = ['push', 'pop', 'shift', 'unshift', 'splice', 'sort', 'reverse'];\nconst arrayAugmentations = [];\n\naryMethods.forEach((method)=> {\n\n    // 这里是原生Array的原型方法\n    let original = Array.prototype[method];\n\n   // 将push, pop等封装好的方法定义在对象arrayAugmentations的属性上\n   // 注意：是属性而非原型属性\n    arrayAugmentations[method] = function () {\n        console.log('我被改变啦!');\n\n        // 调用对应的原生方法并返回结果\n        return original.apply(this, arguments);\n    };\n\n});\n\nlet list = ['a', 'b', 'c'];\n// 将我们要监听的数组的原型指针指向上面定义的空数组对象\n// 别忘了这个空数组的属性上定义了我们封装好的push等方法\nlist.__proto__ = arrayAugmentations;\nlist.push('d');  // 我被改变啦！ 4\n\n// 这里的list2没有被重新定义原型指针，所以就正常输出\nlet list2 = ['a', 'b', 'c'];\nlist2.push('d');  // 4\n```\n\n由于只针对了八种方法进行了hack,所以其他数组的属性也是检测不到的,其中的坑很多,可以阅读上面提到的文档。\n\n我们应该注意到在上文中的实现里,我们多次用遍历方法遍历对象的属性，这就引出了`Object.defineProperty`的第二个缺陷,只能劫持对象的属性,因此我们需要对每个对象的每个属性进行遍历，如果属性值也是对象那么需要深度遍历,显然能劫持一个完整的对象是更好的选择。\n\n\tObject.keys(value).forEach(key => this.convert(key, value[key]));\n\n***\n####3.Proxy实现的双向绑定的特点\n`Proxy`在ES2015规范中被正式发布,它在目标对象之前架设一层“拦截”，外界对该对象的访问，都必须先通过这层拦截，因此提供了一种机制，可以对外界的访问进行过滤和改写,我们可以这样认为,`Proxy`是`Object.defineProperty`的全方位加强版,具体的文档可以查看[此处](http://es6.ruanyifeng.com/#docs/proxy);\n\n##### 3.1 Proxy可以直接监听对象而非属性\n我们还是以上文中用`Object.defineProperty`实现的极简版双向绑定为例,用`Proxy`进行改写。\n```javascript\nconst input = document.getElementById('input');\nconst p = document.getElementById('p');\nconst obj = {};\n\nconst newObj = new Proxy(obj, {\n  get: function(target, key, receiver) {\n    console.log(`getting ${key}!`);\n    return Reflect.get(target, key, receiver);\n  },\n  set: function(target, key, value, receiver) {\n    console.log(target, key, value, receiver);\n    if (key === 'text') {\n      input.value = value;\n      p.innerHTML = value;\n    }\n    return Reflect.set(target, key, value, receiver);\n  },\n});\n\ninput.addEventListener('keyup', function(e) {\n  newObj.text = e.target.value;\n});\n```\n在线示例 [Proxy版](https://codepen.io/experor-xxy/pen/pVpvjg)\n\n我们可以看到,`Proxy`直接可以劫持整个对象,并返回一个新对象,不管是操作便利程度还是底层功能上都远强于`Object.defineProperty`。\n\n##### 3.2 Proxy可以直接监听数组的变化\n当我们对数组进行操作(`push`、`shift`、`splice`等)时，会触发对应的方法名称和`length`的变化，我们可以借此进行操作,以上文中`Object.defineProperty`无法生效的列表渲染为例。\n\n```javascript\nconst list = document.getElementById('list');\nconst btn = document.getElementById('btn');\n\n// 渲染列表\nconst Render = {\n  // 初始化\n  init: function(arr) {\n    const fragment = document.createDocumentFragment();\n    for (let i = 0; i < arr.length; i++) {\n      const li = document.createElement('li');\n      li.textContent = arr[i];\n      fragment.appendChild(li);\n    }\n    list.appendChild(fragment);\n  },\n  // 我们只考虑了增加的情况,仅作为示例\n  change: function(val) {\n    const li = document.createElement('li');\n    li.textContent = val;\n    list.appendChild(li);\n  },\n};\n\n// 初始数组\nconst arr = [1, 2, 3, 4];\n\n// 监听数组\nconst newArr = new Proxy(arr, {\n  get: function(target, key, receiver) {\n    console.log(key);\n    return Reflect.get(target, key, receiver);\n  },\n  set: function(target, key, value, receiver) {\n    console.log(target, key, value, receiver);\n    if (key !== 'length') {\n      Render.change(value);\n    }\n    return Reflect.set(target, key, value, receiver);\n  },\n});\n\n// 初始化\nwindow.onload = function() {\n    Render.init(arr);\n}\n\n// push数字\nbtn.addEventListener('click', function() {\n  newArr.push(6);\n});\n```\n\n在线示例 [Proxy列表渲染](https://codepen.io/experor-xxy/pen/qYpEbx)\n\n很显然,Proxy不需要那么多hack（即使hack也无法完美实现监听）就可以无压力监听数组的变化,我们都知道,标准永远优先于hack。\n\n##### 3.3 Proxy的其他优势\n\nProxy有多达13种拦截方法,不限于`apply`、`ownKeys`、`deleteProperty`、`has`等等是`Object.defineProperty`不具备的。\n\nProxy返回的是一个新对象,我们可以只操作新的对象达到目的,而`Object.defineProperty`只能遍历对象属性直接修改。\n\nProxy作为新标准将受到浏览器厂商重点持续的性能优化，也就是传说中的新标准的性能红利。\n\n当然,Proxy的劣势就是兼容性问题,而且无法用polyfill磨平,因此Vue的作者才声明需要等到下个大版本(3.0)才能用Proxy重写。\n\n","slug":"vue-proxy_defineproperty优劣","published":1,"updated":"2018-05-08T05:10:26.537Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjhbjw6qq000kfx9m6z8pw1ds","content":"<h4 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h4><p><strong>双向绑定</strong>其实已经是一个老掉牙的问题了,只要涉及到MVVM框架就不得不谈的知识点,但它毕竟是Vue的三要素之一.</p>\n<p><strong>Vue三要素</strong></p>\n<ul>\n<li>响应式: 例如如何监听数据变化,其中的实现方法就是我们提到的双向绑定</li>\n<li>模板引擎: 如何解析模板</li>\n<li>渲染: Vue如何将监听到的数据变化和解析后的HTML进行渲染</li>\n</ul>\n<p>可以实现双向绑定的方法有很多,KnockoutJS基于观察者模式的双向绑定,Ember基于数据模型的双向绑定,Angular基于脏检查的双向绑定,本篇文章我们重点讲面试中常见的基于<strong>数据劫持</strong>的双向绑定。<br><a id=\"more\"></a><br>常见的基于数据劫持的双向绑定有两种实现,一个是目前Vue在用的<code>Object.defineProperty</code>,另一个是ES2015中新增的<code>Proxy</code>,而Vue的作者宣称将在Vue3.0版本后加入<code>Proxy</code>从而代替<code>Object.defineProperty</code>,通过本文你也可以知道为什么Vue未来会选择<code>Proxy</code>。</p>\n<blockquote>\n<p>严格来讲Proxy应该被称为『代理』而非『劫持』,不过由于作用有很多相似之处,我们在下文中就不再做区分,统一叫『劫持』。</p>\n</blockquote>\n<p>我们可以通过下图清楚看到以上两种方法在<strong>双向绑定</strong>体系中的关系.</p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2018/5/1/1631801840069098?imageslim\" alt=\"\"></p>\n<blockquote>\n<p>基于数据劫持的当然还有已经凉透的Object.observe方法,已被废弃。<br>提前声明: 我们没有对传入的参数进行及时判断而规避错误,仅仅对核心方法进行了实现.</p>\n</blockquote>\n<hr>\n<h4 id=\"1-基于数据劫持实现的双向绑定的特点\"><a href=\"#1-基于数据劫持实现的双向绑定的特点\" class=\"headerlink\" title=\"1.基于数据劫持实现的双向绑定的特点\"></a>1.基于数据劫持实现的双向绑定的特点</h4><h5 id=\"1-1-什么是数据劫持\"><a href=\"#1-1-什么是数据劫持\" class=\"headerlink\" title=\"1.1 什么是数据劫持\"></a>1.1 什么是数据劫持</h5><p>数据劫持比较好理解,通常我们利用<code>Object.defineProperty</code>劫持对象的访问器,在属性值发生变化时我们可以获取变化,从而进行进一步操作。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 这是将要被劫持的对象</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> data = &#123;</span><br><span class=\"line\">  name: <span class=\"string\">''</span>,</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">say</span>(<span class=\"params\">name</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (name === <span class=\"string\">'古天乐'</span>) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'给大家推荐一款超好玩的游戏'</span>);</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (name === <span class=\"string\">'渣渣辉'</span>) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'戏我演过很多,可游戏我只玩贪玩懒月'</span>);</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'来做我的兄弟'</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 遍历对象,对其属性值进行劫持</span></span><br><span class=\"line\"><span class=\"built_in\">Object</span>.keys(data).forEach(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">key</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">Object</span>.defineProperty(data, key, &#123;</span><br><span class=\"line\">    enumerable: <span class=\"literal\">true</span>,</span><br><span class=\"line\">    configurable: <span class=\"literal\">true</span>,</span><br><span class=\"line\">    get: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">      <span class=\"built_in\">console</span>.log(<span class=\"string\">'get'</span>);</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    set: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">newVal</span>) </span>&#123;</span><br><span class=\"line\">      <span class=\"comment\">// 当属性值发生变化时我们可以进行额外操作</span></span><br><span class=\"line\">      <span class=\"built_in\">console</span>.log(<span class=\"string\">`大家好,我系<span class=\"subst\">$&#123;newVal&#125;</span>`</span>);</span><br><span class=\"line\">      say(newVal);</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">data.name = <span class=\"string\">'渣渣辉'</span>;</span><br><span class=\"line\"><span class=\"comment\">//大家好,我系渣渣辉</span></span><br><span class=\"line\"><span class=\"comment\">//戏我演过很多,可游戏我只玩贪玩懒月</span></span><br></pre></td></tr></table></figure></p>\n<h5 id=\"1-2-数据劫持的优势\"><a href=\"#1-2-数据劫持的优势\" class=\"headerlink\" title=\"1.2 数据劫持的优势\"></a>1.2 数据劫持的优势</h5><p>目前业界分为两个大的流派,一个是以React为首的单向数据绑定,另一个是以Angular、Vue为主的双向数据绑定。</p>\n<blockquote>\n<p>其实三大框架都是既可以双向绑定也可以单向绑定,比如React可以手动绑定onChange和value实现双向绑定,也可以调用一些双向绑定库,Vue也加入了props这种单向流的api,不过都并非主流卖点。</p>\n</blockquote>\n<p>单向或者双向的优劣不在我们的讨论范围,我们需要讨论一下对比其他双向绑定的实现方法,数据劫持的优势所在。</p>\n<ol>\n<li><p>无需显示调用: 例如Vue运用数据劫持+发布订阅,直接可以通知变化并驱动视图,上面的例子也是比较简单的实现<code>data.name = &#39;渣渣辉&#39;</code>后直接触发变更,而比如Angular的脏检测则需要显示调用<code>markForCheck</code>(可以用zone.js避免显示调用,不展开),react需要显示调用<code>setState</code>。</p>\n</li>\n<li><p>可精确得知变化数据：还是上面的小例子，我们劫持了属性的setter,当属性值改变,我们可以精确获知变化的内容<code>newVal</code>,因此在这部分不需要额外的diff操作,否则我们只知道数据发生了变化而不知道具体哪些数据变化了,这个时候需要大量diff来找出变化值,这是额外性能损耗。</p>\n</li>\n</ol>\n<h5 id=\"1-3-基于数据劫持双向绑定的实现思路\"><a href=\"#1-3-基于数据劫持双向绑定的实现思路\" class=\"headerlink\" title=\"1.3 基于数据劫持双向绑定的实现思路\"></a>1.3 基于数据劫持双向绑定的实现思路</h5><p><strong>数据劫持</strong>是双向绑定各种方案中比较流行的一种,最著名的实现就是Vue。</p>\n<p>基于数据劫持的双向绑定离不开<code>Proxy</code>与<code>Object.defineProperty</code>等方法对对象/对象属性的”劫持”,我们要实现一个完整的双向绑定需要以下几个要点。</p>\n<ol>\n<li>利用<code>Proxy</code>或<code>Object.defineProperty</code>生成的Observer针对对象/对象的属性进行”劫持”,在属性发生变化后通知订阅者</li>\n<li>解析器Compile解析模板中的<code>Directive</code>(指令)，收集指令所依赖的方法和数据,等待数据变化然后进行渲染</li>\n<li>Watcher属于Observer和Compile桥梁,它将接收到的Observer产生的数据变化,并根据Compile提供的指令进行视图渲染,使得数据变化促使视图变化</li>\n</ol>\n<p><img src=\"https://user-gold-cdn.xitu.io/2018/4/11/162b38ab2d635662?imageslim\" alt=\"\"></p>\n<blockquote>\n<p>我们看到，虽然Vue运用了数据劫持，但是依然离不开发布订阅的模式，之所以在系列2做了<a href=\"/blog/2018/04/23/vue-react-EventBus/#more\">Event Bus</a>的实现,就是因为我们不管在学习一些框架的原理还是一些流行库（例如Redux、Vuex）,基本上都离不开发布订阅模式,而Event模块则是此模式的经典实现,所以如果不熟悉发布订阅模式,建议读一下系列2的文章。</p>\n</blockquote>\n<h4 id=\"2-基于Object-defineProperty双向绑定的特点\"><a href=\"#2-基于Object-defineProperty双向绑定的特点\" class=\"headerlink\" title=\"2.基于Object.defineProperty双向绑定的特点\"></a>2.基于Object.defineProperty双向绑定的特点</h4><p>关于<code>Object.defineProperty</code>的文章在网络上已经汗牛充栋,我们不想花过多时间在<code>Object.defineProperty</code>上面,本节我们主要讲解<code>Object.defineProperty</code>的特点,方便接下来与<code>Proxy</code>进行对比。</p>\n<blockquote>\n<p>对<code>Object.defineProperty</code>还不了解的请阅读<a href=\"https://link.juejin.im/?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fzh-CN%2Fdocs%2FWeb%2FJavaScript%2FReference%2FGlobal_Objects%2FObject%2FdefineProperty\" target=\"_blank\" rel=\"noopener\">文档</a></p>\n</blockquote>\n<p>两年前就有人写过基于<code>Object.defineProperty</code>实现的<a href=\"https://segmentfault.com/a/1190000006599500\" target=\"_blank\" rel=\"noopener\">文章</a>,想深入理解<code>Object.defineProperty</code>实现的推荐阅读,本文也做了相关参考。</p>\n<blockquote>\n<p>上面我们推荐的文章为比较完整的实现(400行代码),我们在本节只提供一个极简版(20行)和一个简化版(150行)的实现,读者可以循序渐进地阅读。</p>\n</blockquote>\n<h5 id=\"2-1-极简版的双向绑定\"><a href=\"#2-1-极简版的双向绑定\" class=\"headerlink\" title=\"2.1 极简版的双向绑定\"></a>2.1 极简版的双向绑定</h5><p>我们都知道,<code>Object.defineProperty</code>的作用就是劫持一个对象的属性,通常我们对属性的<code>getter</code>和<code>setter</code>方法进行劫持,在对象的属性发生变化时进行特定的操作。</p>\n<p>我们就对对象<code>obj</code>的<code>text</code>属性进行劫持,在获取此属性的值时打印<code>&#39;get val&#39;</code>,在更改属性值的时候对DOM进行操作,这就是一个极简的双向绑定。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> obj = &#123;&#125;;</span><br><span class=\"line\"><span class=\"built_in\">Object</span>.defineProperty(obj, <span class=\"string\">'text'</span>, &#123;</span><br><span class=\"line\">  get: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'get val'</span>);&amp;emsp;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  set: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">newVal</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'set val:'</span> + newVal);</span><br><span class=\"line\">    <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">'input'</span>).value = newVal;</span><br><span class=\"line\">    <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">'span'</span>).innerHTML = newVal;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> input = <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">'input'</span>);</span><br><span class=\"line\">input.addEventListener(<span class=\"string\">'keyup'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">e</span>)</span>&#123;</span><br><span class=\"line\">  obj.text = e.target.value;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<p>在线示例<a href=\"https://codepen.io/experor-xxy/pen/BxJBZW\" target=\"_blank\" rel=\"noopener\">极简版双向绑定</a></p>\n<h5 id=\"2-2-升级改造\"><a href=\"#2-2-升级改造\" class=\"headerlink\" title=\"2.2 升级改造\"></a>2.2 升级改造</h5><p>我们很快会发现，这个所谓的双向绑定貌似并没有什么乱用。。。</p>\n<p>原因如下:</p>\n<ol>\n<li>我们只监听了一个属性,一个对象不可能只有一个属性,我们需要对对象每个属性进行监听。</li>\n<li>违反开放封闭原则,我们如果了解<a href=\"https://link.juejin.im/?target=https%3A%2F%2Fzh.wikipedia.org%2Fzh-hans%2F%25E5%25BC%2580%25E9%2597%25AD%25E5%258E%259F%25E5%2588%2599\" target=\"_blank\" rel=\"noopener\">开放封闭原则</a>的话,上述代码是明显违反此原则,我们每次修改都需要进入方法内部,这是需要坚决杜绝的。</li>\n<li>代码耦合严重,我们的数据、方法和DOM都是耦合在一起的，就是传说中的面条代码。</li>\n</ol>\n<p>那么如何解决上述问题？</p>\n<p>Vue的操作就是加入了<strong>发布订阅</strong>模式，结合<code>Object.defineProperty</code>的劫持能力，实现了可用性很高的双向绑定。</p>\n<p>首先，我们以<strong>发布订阅</strong>的角度看我们第一部分写的那一坨代码,会发现它的监听、发布和订阅都是写在一起的,我们首先要做的就是解耦。</p>\n<p>我们先实现一个订阅发布中心，即消息管理员（Dep）,它负责储存订阅者和消息的分发,不管是订阅者还是发布者都需要依赖于它。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> uid = <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"comment\">// 用于储存订阅者并发布消息</span></span><br><span class=\"line\">  <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Dep</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">constructor</span>() &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 设置id,用于区分新Watcher和只改变属性值后新产生的Watcher</span></span><br><span class=\"line\">      <span class=\"keyword\">this</span>.id = uid++;</span><br><span class=\"line\">      <span class=\"comment\">// 储存订阅者的数组</span></span><br><span class=\"line\">      <span class=\"keyword\">this</span>.subs = [];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 触发target上的Watcher中的addDep方法,参数为dep的实例本身</span></span><br><span class=\"line\">    depend() &#123;</span><br><span class=\"line\">      Dep.target.addDep(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 添加订阅者</span></span><br><span class=\"line\">    addSub(sub) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">this</span>.subs.push(sub);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    notify() &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 通知所有的订阅者(Watcher)，触发订阅者的相应逻辑处理</span></span><br><span class=\"line\">      <span class=\"keyword\">this</span>.subs.forEach(<span class=\"function\"><span class=\"params\">sub</span> =&gt;</span> sub.update());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 为Dep类设置一个静态属性,默认为null,工作时指向当前的Watcher</span></span><br><span class=\"line\">  Dep.target = <span class=\"literal\">null</span>;</span><br></pre></td></tr></table></figure>\n<p>现在我们需要实现监听者(Observer),用于监听属性值的变化。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 监听者,监听对象属性值的变化</span></span><br><span class=\"line\">  <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Observer</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">constructor</span>(value) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">this</span>.value = value;</span><br><span class=\"line\">      <span class=\"keyword\">this</span>.walk(value);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 遍历属性值并监听</span></span><br><span class=\"line\">    walk(value) &#123;</span><br><span class=\"line\">      <span class=\"built_in\">Object</span>.keys(value).forEach(<span class=\"function\"><span class=\"params\">key</span> =&gt;</span> <span class=\"keyword\">this</span>.convert(key, value[key]));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 执行监听的具体方法</span></span><br><span class=\"line\">    convert(key, val) &#123;</span><br><span class=\"line\">      defineReactive(<span class=\"keyword\">this</span>.value, key, val);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">defineReactive</span>(<span class=\"params\">obj, key, val</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> dep = <span class=\"keyword\">new</span> Dep();</span><br><span class=\"line\">    <span class=\"comment\">// 给当前属性的值添加监听</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> chlidOb = observe(val);</span><br><span class=\"line\">    <span class=\"built_in\">Object</span>.defineProperty(obj, key, &#123;</span><br><span class=\"line\">      enumerable: <span class=\"literal\">true</span>,</span><br><span class=\"line\">      configurable: <span class=\"literal\">true</span>,</span><br><span class=\"line\">      get: <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 如果Dep类存在target属性，将其添加到dep实例的subs数组中</span></span><br><span class=\"line\">        <span class=\"comment\">// target指向一个Watcher实例，每个Watcher都是一个订阅者</span></span><br><span class=\"line\">        <span class=\"comment\">// Watcher实例在实例化过程中，会读取data中的某个属性，从而触发当前get方法</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (Dep.target) &#123;</span><br><span class=\"line\">          dep.depend();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> val;</span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">      set: <span class=\"function\"><span class=\"params\">newVal</span> =&gt;</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (val === newVal) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        val = newVal;</span><br><span class=\"line\">        <span class=\"comment\">// 对新值进行监听</span></span><br><span class=\"line\">        chlidOb = observe(newVal);</span><br><span class=\"line\">        <span class=\"comment\">// 通知所有订阅者，数值被改变了</span></span><br><span class=\"line\">        dep.notify();</span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">observe</span>(<span class=\"params\">value</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 当值不存在，或者不是复杂数据类型时，不再需要继续深入监听</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!value || <span class=\"keyword\">typeof</span> value !== <span class=\"string\">'object'</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Observer(value);</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure></p>\n<p>那么接下来就简单了,我们需要实现一个订阅者(Watcher)。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Watcher</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">constructor</span>(vm, expOrFn, cb) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">this</span>.depIds = &#123;&#125;; <span class=\"comment\">// hash储存订阅者的id,避免重复的订阅者</span></span><br><span class=\"line\">      <span class=\"keyword\">this</span>.vm = vm; <span class=\"comment\">// 被订阅的数据一定来自于当前Vue实例</span></span><br><span class=\"line\">      <span class=\"keyword\">this</span>.cb = cb; <span class=\"comment\">// 当数据更新时想要做的事情</span></span><br><span class=\"line\">      <span class=\"keyword\">this</span>.expOrFn = expOrFn; <span class=\"comment\">// 被订阅的数据</span></span><br><span class=\"line\">      <span class=\"keyword\">this</span>.val = <span class=\"keyword\">this</span>.get(); <span class=\"comment\">// 维护更新之前的数据</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 对外暴露的接口，用于在订阅的数据被更新时，由订阅者管理员(Dep)调用</span></span><br><span class=\"line\">    update() &#123;</span><br><span class=\"line\">      <span class=\"keyword\">this</span>.run();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    addDep(dep) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 如果在depIds的hash中没有当前的id,可以判断是新Watcher,因此可以添加到dep的数组中储存</span></span><br><span class=\"line\">      <span class=\"comment\">// 此判断是避免同id的Watcher被多次储存</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (!<span class=\"keyword\">this</span>.depIds.hasOwnProperty(dep.id)) &#123;</span><br><span class=\"line\">        dep.addSub(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.depIds[dep.id] = dep;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    run() &#123;</span><br><span class=\"line\">      <span class=\"keyword\">const</span> val = <span class=\"keyword\">this</span>.get();</span><br><span class=\"line\">      <span class=\"built_in\">console</span>.log(val);</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (val !== <span class=\"keyword\">this</span>.val) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.val = val;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.cb.call(<span class=\"keyword\">this</span>.vm, val);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    get() &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 当前订阅者(Watcher)读取被订阅数据的最新更新后的值时，通知订阅者管理员收集当前订阅者</span></span><br><span class=\"line\">      Dep.target = <span class=\"keyword\">this</span>;</span><br><span class=\"line\">      <span class=\"keyword\">const</span> val = <span class=\"keyword\">this</span>.vm._data[<span class=\"keyword\">this</span>.expOrFn];</span><br><span class=\"line\">      <span class=\"comment\">// 置空，用于下一个Watcher使用</span></span><br><span class=\"line\">      Dep.target = <span class=\"literal\">null</span>;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> val;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure></p>\n<p>那么我们最后完成Vue,将上述方法挂载在Vue上。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Vue</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">constructor</span>(options = &#123;&#125;) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 简化了$options的处理</span></span><br><span class=\"line\">      <span class=\"keyword\">this</span>.$options = options;</span><br><span class=\"line\">      <span class=\"comment\">// 简化了对data的处理</span></span><br><span class=\"line\">      <span class=\"keyword\">let</span> data = (<span class=\"keyword\">this</span>._data = <span class=\"keyword\">this</span>.$options.data);</span><br><span class=\"line\">      <span class=\"comment\">// 将所有data最外层属性代理到Vue实例上</span></span><br><span class=\"line\">      <span class=\"built_in\">Object</span>.keys(data).forEach(<span class=\"function\"><span class=\"params\">key</span> =&gt;</span> <span class=\"keyword\">this</span>._proxy(key));</span><br><span class=\"line\">      <span class=\"comment\">// 监听数据</span></span><br><span class=\"line\">      observe(data);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 对外暴露调用订阅者的接口，内部主要在指令中使用订阅者</span></span><br><span class=\"line\">    $watch(expOrFn, cb) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">new</span> Watcher(<span class=\"keyword\">this</span>, expOrFn, cb);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    _proxy(key) &#123;</span><br><span class=\"line\">      <span class=\"built_in\">Object</span>.defineProperty(<span class=\"keyword\">this</span>, key, &#123;</span><br><span class=\"line\">        configurable: <span class=\"literal\">true</span>,</span><br><span class=\"line\">        enumerable: <span class=\"literal\">true</span>,</span><br><span class=\"line\">        get: <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> <span class=\"keyword\">this</span>._data[key],</span><br><span class=\"line\">        set: <span class=\"function\"><span class=\"params\">val</span> =&gt;</span> &#123;</span><br><span class=\"line\">          <span class=\"keyword\">this</span>._data[key] = val;</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">      &#125;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure></p>\n<p>看下效果：<br>&emsp;&emsp;&emsp;&emsp;<img src=\"https://user-gold-cdn.xitu.io/2018/5/1/1631c5aa9c52493e?imageslim\" alt=\"\"></p>\n<p>在线示例<a href=\"https://codepen.io/experor-xxy/pen/gzoYXL\" target=\"_blank\" rel=\"noopener\">双向绑定实现—无漏洞版</a></p>\n<p>至此,一个简单的双向绑定算是被我们实现了。</p>\n<h5 id=\"2-3-Object-defineProperty的缺陷\"><a href=\"#2-3-Object-defineProperty的缺陷\" class=\"headerlink\" title=\"2.3 Object.defineProperty的缺陷\"></a>2.3 Object.defineProperty的缺陷</h5><p>其实我们升级版的双向绑定依然存在漏洞,比如我们将属性值改为数组。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> demo = <span class=\"keyword\">new</span> Vue(&#123;</span><br><span class=\"line\">  data: &#123;</span><br><span class=\"line\">    list: [<span class=\"number\">1</span>],</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> list = <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">'list'</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> btn = <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">'btn'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">btn.addEventListener(<span class=\"string\">'click'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  demo.list.push(<span class=\"number\">1</span>);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> render = <span class=\"function\"><span class=\"params\">arr</span> =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> fragment = <span class=\"built_in\">document</span>.createDocumentFragment();</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> li = <span class=\"built_in\">document</span>.createElement(<span class=\"string\">'li'</span>);</span><br><span class=\"line\">    li.textContent = arr[i];</span><br><span class=\"line\">    fragment.appendChild(li);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  list.appendChild(fragment);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 监听数组,每次数组变化则触发渲染函数,然而...无法监听</span></span><br><span class=\"line\">demo.$watch(<span class=\"string\">'list'</span>, list =&gt; render(list));</span><br><span class=\"line\"></span><br><span class=\"line\">setTimeout(</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    alert(demo.list);</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  <span class=\"number\">5000</span>,</span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure></p>\n<p>在线示例 <a href=\"https://codepen.io/experor-xxy/pen/VxyZXv\" target=\"_blank\" rel=\"noopener\">双向绑定-数组漏洞</a></p>\n<p>是的,<code>Object.defineProperty</code>的第一个缺陷,无法监听数组变化。 然而Vue的文档提到了Vue是可以检测到数组变化的，但是只有以下八种方法,<code>vm.items[indexOfItem] = newValue</code>这种是无法检测的。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">push()</span><br><span class=\"line\">pop()</span><br><span class=\"line\">shift()</span><br><span class=\"line\">unshift()</span><br><span class=\"line\">splice()</span><br><span class=\"line\">sort()</span><br><span class=\"line\">reverse()</span><br></pre></td></tr></table></figure>\n<p>其实作者在这里用了一些奇技淫巧,把无法监听数组的情况hack掉了,以下是方法示例。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> aryMethods = [<span class=\"string\">'push'</span>, <span class=\"string\">'pop'</span>, <span class=\"string\">'shift'</span>, <span class=\"string\">'unshift'</span>, <span class=\"string\">'splice'</span>, <span class=\"string\">'sort'</span>, <span class=\"string\">'reverse'</span>];</span><br><span class=\"line\"><span class=\"keyword\">const</span> arrayAugmentations = [];</span><br><span class=\"line\"></span><br><span class=\"line\">aryMethods.forEach(<span class=\"function\">(<span class=\"params\">method</span>)=&gt;</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 这里是原生Array的原型方法</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> original = <span class=\"built_in\">Array</span>.prototype[method];</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"comment\">// 将push, pop等封装好的方法定义在对象arrayAugmentations的属性上</span></span><br><span class=\"line\">   <span class=\"comment\">// 注意：是属性而非原型属性</span></span><br><span class=\"line\">    arrayAugmentations[method] = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">'我被改变啦!'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 调用对应的原生方法并返回结果</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> original.apply(<span class=\"keyword\">this</span>, <span class=\"built_in\">arguments</span>);</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> list = [<span class=\"string\">'a'</span>, <span class=\"string\">'b'</span>, <span class=\"string\">'c'</span>];</span><br><span class=\"line\"><span class=\"comment\">// 将我们要监听的数组的原型指针指向上面定义的空数组对象</span></span><br><span class=\"line\"><span class=\"comment\">// 别忘了这个空数组的属性上定义了我们封装好的push等方法</span></span><br><span class=\"line\">list.__proto__ = arrayAugmentations;</span><br><span class=\"line\">list.push(<span class=\"string\">'d'</span>);  <span class=\"comment\">// 我被改变啦！ 4</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 这里的list2没有被重新定义原型指针，所以就正常输出</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> list2 = [<span class=\"string\">'a'</span>, <span class=\"string\">'b'</span>, <span class=\"string\">'c'</span>];</span><br><span class=\"line\">list2.push(<span class=\"string\">'d'</span>);  <span class=\"comment\">// 4</span></span><br></pre></td></tr></table></figure></p>\n<p>由于只针对了八种方法进行了hack,所以其他数组的属性也是检测不到的,其中的坑很多,可以阅读上面提到的文档。</p>\n<p>我们应该注意到在上文中的实现里,我们多次用遍历方法遍历对象的属性，这就引出了<code>Object.defineProperty</code>的第二个缺陷,只能劫持对象的属性,因此我们需要对每个对象的每个属性进行遍历，如果属性值也是对象那么需要深度遍历,显然能劫持一个完整的对象是更好的选择。</p>\n<pre><code>Object.keys(value).forEach(key =&gt; this.convert(key, value[key]));\n</code></pre><hr>\n<p>####3.Proxy实现的双向绑定的特点<br><code>Proxy</code>在ES2015规范中被正式发布,它在目标对象之前架设一层“拦截”，外界对该对象的访问，都必须先通过这层拦截，因此提供了一种机制，可以对外界的访问进行过滤和改写,我们可以这样认为,<code>Proxy</code>是<code>Object.defineProperty</code>的全方位加强版,具体的文档可以查看<a href=\"http://es6.ruanyifeng.com/#docs/proxy\" target=\"_blank\" rel=\"noopener\">此处</a>;</p>\n<h5 id=\"3-1-Proxy可以直接监听对象而非属性\"><a href=\"#3-1-Proxy可以直接监听对象而非属性\" class=\"headerlink\" title=\"3.1 Proxy可以直接监听对象而非属性\"></a>3.1 Proxy可以直接监听对象而非属性</h5><p>我们还是以上文中用<code>Object.defineProperty</code>实现的极简版双向绑定为例,用<code>Proxy</code>进行改写。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> input = <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">'input'</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> p = <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">'p'</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> obj = &#123;&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> newObj = <span class=\"keyword\">new</span> <span class=\"built_in\">Proxy</span>(obj, &#123;</span><br><span class=\"line\">  get: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">target, key, receiver</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">`getting <span class=\"subst\">$&#123;key&#125;</span>!`</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">Reflect</span>.get(target, key, receiver);</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  set: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">target, key, value, receiver</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(target, key, value, receiver);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (key === <span class=\"string\">'text'</span>) &#123;</span><br><span class=\"line\">      input.value = value;</span><br><span class=\"line\">      p.innerHTML = value;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">Reflect</span>.set(target, key, value, receiver);</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">input.addEventListener(<span class=\"string\">'keyup'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">e</span>) </span>&#123;</span><br><span class=\"line\">  newObj.text = e.target.value;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></p>\n<p>在线示例 <a href=\"https://codepen.io/experor-xxy/pen/pVpvjg\" target=\"_blank\" rel=\"noopener\">Proxy版</a></p>\n<p>我们可以看到,<code>Proxy</code>直接可以劫持整个对象,并返回一个新对象,不管是操作便利程度还是底层功能上都远强于<code>Object.defineProperty</code>。</p>\n<h5 id=\"3-2-Proxy可以直接监听数组的变化\"><a href=\"#3-2-Proxy可以直接监听数组的变化\" class=\"headerlink\" title=\"3.2 Proxy可以直接监听数组的变化\"></a>3.2 Proxy可以直接监听数组的变化</h5><p>当我们对数组进行操作(<code>push</code>、<code>shift</code>、<code>splice</code>等)时，会触发对应的方法名称和<code>length</code>的变化，我们可以借此进行操作,以上文中<code>Object.defineProperty</code>无法生效的列表渲染为例。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> list = <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">'list'</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> btn = <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">'btn'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 渲染列表</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> Render = &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 初始化</span></span><br><span class=\"line\">  init: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">arr</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> fragment = <span class=\"built_in\">document</span>.createDocumentFragment();</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">const</span> li = <span class=\"built_in\">document</span>.createElement(<span class=\"string\">'li'</span>);</span><br><span class=\"line\">      li.textContent = arr[i];</span><br><span class=\"line\">      fragment.appendChild(li);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    list.appendChild(fragment);</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  <span class=\"comment\">// 我们只考虑了增加的情况,仅作为示例</span></span><br><span class=\"line\">  change: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">val</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> li = <span class=\"built_in\">document</span>.createElement(<span class=\"string\">'li'</span>);</span><br><span class=\"line\">    li.textContent = val;</span><br><span class=\"line\">    list.appendChild(li);</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 初始数组</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> arr = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 监听数组</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> newArr = <span class=\"keyword\">new</span> <span class=\"built_in\">Proxy</span>(arr, &#123;</span><br><span class=\"line\">  get: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">target, key, receiver</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(key);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">Reflect</span>.get(target, key, receiver);</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  set: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">target, key, value, receiver</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(target, key, value, receiver);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (key !== <span class=\"string\">'length'</span>) &#123;</span><br><span class=\"line\">      Render.change(value);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">Reflect</span>.set(target, key, value, receiver);</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 初始化</span></span><br><span class=\"line\"><span class=\"built_in\">window</span>.onload = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    Render.init(arr);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// push数字</span></span><br><span class=\"line\">btn.addEventListener(<span class=\"string\">'click'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  newArr.push(<span class=\"number\">6</span>);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>在线示例 <a href=\"https://codepen.io/experor-xxy/pen/qYpEbx\" target=\"_blank\" rel=\"noopener\">Proxy列表渲染</a></p>\n<p>很显然,Proxy不需要那么多hack（即使hack也无法完美实现监听）就可以无压力监听数组的变化,我们都知道,标准永远优先于hack。</p>\n<h5 id=\"3-3-Proxy的其他优势\"><a href=\"#3-3-Proxy的其他优势\" class=\"headerlink\" title=\"3.3 Proxy的其他优势\"></a>3.3 Proxy的其他优势</h5><p>Proxy有多达13种拦截方法,不限于<code>apply</code>、<code>ownKeys</code>、<code>deleteProperty</code>、<code>has</code>等等是<code>Object.defineProperty</code>不具备的。</p>\n<p>Proxy返回的是一个新对象,我们可以只操作新的对象达到目的,而<code>Object.defineProperty</code>只能遍历对象属性直接修改。</p>\n<p>Proxy作为新标准将受到浏览器厂商重点持续的性能优化，也就是传说中的新标准的性能红利。</p>\n<p>当然,Proxy的劣势就是兼容性问题,而且无法用polyfill磨平,因此Vue的作者才声明需要等到下个大版本(3.0)才能用Proxy重写。</p>\n","site":{"data":{}},"excerpt":"<h4 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h4><p><strong>双向绑定</strong>其实已经是一个老掉牙的问题了,只要涉及到MVVM框架就不得不谈的知识点,但它毕竟是Vue的三要素之一.</p>\n<p><strong>Vue三要素</strong></p>\n<ul>\n<li>响应式: 例如如何监听数据变化,其中的实现方法就是我们提到的双向绑定</li>\n<li>模板引擎: 如何解析模板</li>\n<li>渲染: Vue如何将监听到的数据变化和解析后的HTML进行渲染</li>\n</ul>\n<p>可以实现双向绑定的方法有很多,KnockoutJS基于观察者模式的双向绑定,Ember基于数据模型的双向绑定,Angular基于脏检查的双向绑定,本篇文章我们重点讲面试中常见的基于<strong>数据劫持</strong>的双向绑定。<br>","more":"<br>常见的基于数据劫持的双向绑定有两种实现,一个是目前Vue在用的<code>Object.defineProperty</code>,另一个是ES2015中新增的<code>Proxy</code>,而Vue的作者宣称将在Vue3.0版本后加入<code>Proxy</code>从而代替<code>Object.defineProperty</code>,通过本文你也可以知道为什么Vue未来会选择<code>Proxy</code>。</p>\n<blockquote>\n<p>严格来讲Proxy应该被称为『代理』而非『劫持』,不过由于作用有很多相似之处,我们在下文中就不再做区分,统一叫『劫持』。</p>\n</blockquote>\n<p>我们可以通过下图清楚看到以上两种方法在<strong>双向绑定</strong>体系中的关系.</p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2018/5/1/1631801840069098?imageslim\" alt=\"\"></p>\n<blockquote>\n<p>基于数据劫持的当然还有已经凉透的Object.observe方法,已被废弃。<br>提前声明: 我们没有对传入的参数进行及时判断而规避错误,仅仅对核心方法进行了实现.</p>\n</blockquote>\n<hr>\n<h4 id=\"1-基于数据劫持实现的双向绑定的特点\"><a href=\"#1-基于数据劫持实现的双向绑定的特点\" class=\"headerlink\" title=\"1.基于数据劫持实现的双向绑定的特点\"></a>1.基于数据劫持实现的双向绑定的特点</h4><h5 id=\"1-1-什么是数据劫持\"><a href=\"#1-1-什么是数据劫持\" class=\"headerlink\" title=\"1.1 什么是数据劫持\"></a>1.1 什么是数据劫持</h5><p>数据劫持比较好理解,通常我们利用<code>Object.defineProperty</code>劫持对象的访问器,在属性值发生变化时我们可以获取变化,从而进行进一步操作。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 这是将要被劫持的对象</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> data = &#123;</span><br><span class=\"line\">  name: <span class=\"string\">''</span>,</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">say</span>(<span class=\"params\">name</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (name === <span class=\"string\">'古天乐'</span>) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'给大家推荐一款超好玩的游戏'</span>);</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (name === <span class=\"string\">'渣渣辉'</span>) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'戏我演过很多,可游戏我只玩贪玩懒月'</span>);</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'来做我的兄弟'</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 遍历对象,对其属性值进行劫持</span></span><br><span class=\"line\"><span class=\"built_in\">Object</span>.keys(data).forEach(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">key</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">Object</span>.defineProperty(data, key, &#123;</span><br><span class=\"line\">    enumerable: <span class=\"literal\">true</span>,</span><br><span class=\"line\">    configurable: <span class=\"literal\">true</span>,</span><br><span class=\"line\">    get: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">      <span class=\"built_in\">console</span>.log(<span class=\"string\">'get'</span>);</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    set: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">newVal</span>) </span>&#123;</span><br><span class=\"line\">      <span class=\"comment\">// 当属性值发生变化时我们可以进行额外操作</span></span><br><span class=\"line\">      <span class=\"built_in\">console</span>.log(<span class=\"string\">`大家好,我系<span class=\"subst\">$&#123;newVal&#125;</span>`</span>);</span><br><span class=\"line\">      say(newVal);</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">data.name = <span class=\"string\">'渣渣辉'</span>;</span><br><span class=\"line\"><span class=\"comment\">//大家好,我系渣渣辉</span></span><br><span class=\"line\"><span class=\"comment\">//戏我演过很多,可游戏我只玩贪玩懒月</span></span><br></pre></td></tr></table></figure></p>\n<h5 id=\"1-2-数据劫持的优势\"><a href=\"#1-2-数据劫持的优势\" class=\"headerlink\" title=\"1.2 数据劫持的优势\"></a>1.2 数据劫持的优势</h5><p>目前业界分为两个大的流派,一个是以React为首的单向数据绑定,另一个是以Angular、Vue为主的双向数据绑定。</p>\n<blockquote>\n<p>其实三大框架都是既可以双向绑定也可以单向绑定,比如React可以手动绑定onChange和value实现双向绑定,也可以调用一些双向绑定库,Vue也加入了props这种单向流的api,不过都并非主流卖点。</p>\n</blockquote>\n<p>单向或者双向的优劣不在我们的讨论范围,我们需要讨论一下对比其他双向绑定的实现方法,数据劫持的优势所在。</p>\n<ol>\n<li><p>无需显示调用: 例如Vue运用数据劫持+发布订阅,直接可以通知变化并驱动视图,上面的例子也是比较简单的实现<code>data.name = &#39;渣渣辉&#39;</code>后直接触发变更,而比如Angular的脏检测则需要显示调用<code>markForCheck</code>(可以用zone.js避免显示调用,不展开),react需要显示调用<code>setState</code>。</p>\n</li>\n<li><p>可精确得知变化数据：还是上面的小例子，我们劫持了属性的setter,当属性值改变,我们可以精确获知变化的内容<code>newVal</code>,因此在这部分不需要额外的diff操作,否则我们只知道数据发生了变化而不知道具体哪些数据变化了,这个时候需要大量diff来找出变化值,这是额外性能损耗。</p>\n</li>\n</ol>\n<h5 id=\"1-3-基于数据劫持双向绑定的实现思路\"><a href=\"#1-3-基于数据劫持双向绑定的实现思路\" class=\"headerlink\" title=\"1.3 基于数据劫持双向绑定的实现思路\"></a>1.3 基于数据劫持双向绑定的实现思路</h5><p><strong>数据劫持</strong>是双向绑定各种方案中比较流行的一种,最著名的实现就是Vue。</p>\n<p>基于数据劫持的双向绑定离不开<code>Proxy</code>与<code>Object.defineProperty</code>等方法对对象/对象属性的”劫持”,我们要实现一个完整的双向绑定需要以下几个要点。</p>\n<ol>\n<li>利用<code>Proxy</code>或<code>Object.defineProperty</code>生成的Observer针对对象/对象的属性进行”劫持”,在属性发生变化后通知订阅者</li>\n<li>解析器Compile解析模板中的<code>Directive</code>(指令)，收集指令所依赖的方法和数据,等待数据变化然后进行渲染</li>\n<li>Watcher属于Observer和Compile桥梁,它将接收到的Observer产生的数据变化,并根据Compile提供的指令进行视图渲染,使得数据变化促使视图变化</li>\n</ol>\n<p><img src=\"https://user-gold-cdn.xitu.io/2018/4/11/162b38ab2d635662?imageslim\" alt=\"\"></p>\n<blockquote>\n<p>我们看到，虽然Vue运用了数据劫持，但是依然离不开发布订阅的模式，之所以在系列2做了<a href=\"/blog/2018/04/23/vue-react-EventBus/#more\">Event Bus</a>的实现,就是因为我们不管在学习一些框架的原理还是一些流行库（例如Redux、Vuex）,基本上都离不开发布订阅模式,而Event模块则是此模式的经典实现,所以如果不熟悉发布订阅模式,建议读一下系列2的文章。</p>\n</blockquote>\n<h4 id=\"2-基于Object-defineProperty双向绑定的特点\"><a href=\"#2-基于Object-defineProperty双向绑定的特点\" class=\"headerlink\" title=\"2.基于Object.defineProperty双向绑定的特点\"></a>2.基于Object.defineProperty双向绑定的特点</h4><p>关于<code>Object.defineProperty</code>的文章在网络上已经汗牛充栋,我们不想花过多时间在<code>Object.defineProperty</code>上面,本节我们主要讲解<code>Object.defineProperty</code>的特点,方便接下来与<code>Proxy</code>进行对比。</p>\n<blockquote>\n<p>对<code>Object.defineProperty</code>还不了解的请阅读<a href=\"https://link.juejin.im/?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fzh-CN%2Fdocs%2FWeb%2FJavaScript%2FReference%2FGlobal_Objects%2FObject%2FdefineProperty\" target=\"_blank\" rel=\"noopener\">文档</a></p>\n</blockquote>\n<p>两年前就有人写过基于<code>Object.defineProperty</code>实现的<a href=\"https://segmentfault.com/a/1190000006599500\" target=\"_blank\" rel=\"noopener\">文章</a>,想深入理解<code>Object.defineProperty</code>实现的推荐阅读,本文也做了相关参考。</p>\n<blockquote>\n<p>上面我们推荐的文章为比较完整的实现(400行代码),我们在本节只提供一个极简版(20行)和一个简化版(150行)的实现,读者可以循序渐进地阅读。</p>\n</blockquote>\n<h5 id=\"2-1-极简版的双向绑定\"><a href=\"#2-1-极简版的双向绑定\" class=\"headerlink\" title=\"2.1 极简版的双向绑定\"></a>2.1 极简版的双向绑定</h5><p>我们都知道,<code>Object.defineProperty</code>的作用就是劫持一个对象的属性,通常我们对属性的<code>getter</code>和<code>setter</code>方法进行劫持,在对象的属性发生变化时进行特定的操作。</p>\n<p>我们就对对象<code>obj</code>的<code>text</code>属性进行劫持,在获取此属性的值时打印<code>&#39;get val&#39;</code>,在更改属性值的时候对DOM进行操作,这就是一个极简的双向绑定。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> obj = &#123;&#125;;</span><br><span class=\"line\"><span class=\"built_in\">Object</span>.defineProperty(obj, <span class=\"string\">'text'</span>, &#123;</span><br><span class=\"line\">  get: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'get val'</span>);&amp;emsp;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  set: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">newVal</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'set val:'</span> + newVal);</span><br><span class=\"line\">    <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">'input'</span>).value = newVal;</span><br><span class=\"line\">    <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">'span'</span>).innerHTML = newVal;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> input = <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">'input'</span>);</span><br><span class=\"line\">input.addEventListener(<span class=\"string\">'keyup'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">e</span>)</span>&#123;</span><br><span class=\"line\">  obj.text = e.target.value;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<p>在线示例<a href=\"https://codepen.io/experor-xxy/pen/BxJBZW\" target=\"_blank\" rel=\"noopener\">极简版双向绑定</a></p>\n<h5 id=\"2-2-升级改造\"><a href=\"#2-2-升级改造\" class=\"headerlink\" title=\"2.2 升级改造\"></a>2.2 升级改造</h5><p>我们很快会发现，这个所谓的双向绑定貌似并没有什么乱用。。。</p>\n<p>原因如下:</p>\n<ol>\n<li>我们只监听了一个属性,一个对象不可能只有一个属性,我们需要对对象每个属性进行监听。</li>\n<li>违反开放封闭原则,我们如果了解<a href=\"https://link.juejin.im/?target=https%3A%2F%2Fzh.wikipedia.org%2Fzh-hans%2F%25E5%25BC%2580%25E9%2597%25AD%25E5%258E%259F%25E5%2588%2599\" target=\"_blank\" rel=\"noopener\">开放封闭原则</a>的话,上述代码是明显违反此原则,我们每次修改都需要进入方法内部,这是需要坚决杜绝的。</li>\n<li>代码耦合严重,我们的数据、方法和DOM都是耦合在一起的，就是传说中的面条代码。</li>\n</ol>\n<p>那么如何解决上述问题？</p>\n<p>Vue的操作就是加入了<strong>发布订阅</strong>模式，结合<code>Object.defineProperty</code>的劫持能力，实现了可用性很高的双向绑定。</p>\n<p>首先，我们以<strong>发布订阅</strong>的角度看我们第一部分写的那一坨代码,会发现它的监听、发布和订阅都是写在一起的,我们首先要做的就是解耦。</p>\n<p>我们先实现一个订阅发布中心，即消息管理员（Dep）,它负责储存订阅者和消息的分发,不管是订阅者还是发布者都需要依赖于它。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> uid = <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"comment\">// 用于储存订阅者并发布消息</span></span><br><span class=\"line\">  <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Dep</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">constructor</span>() &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 设置id,用于区分新Watcher和只改变属性值后新产生的Watcher</span></span><br><span class=\"line\">      <span class=\"keyword\">this</span>.id = uid++;</span><br><span class=\"line\">      <span class=\"comment\">// 储存订阅者的数组</span></span><br><span class=\"line\">      <span class=\"keyword\">this</span>.subs = [];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 触发target上的Watcher中的addDep方法,参数为dep的实例本身</span></span><br><span class=\"line\">    depend() &#123;</span><br><span class=\"line\">      Dep.target.addDep(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 添加订阅者</span></span><br><span class=\"line\">    addSub(sub) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">this</span>.subs.push(sub);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    notify() &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 通知所有的订阅者(Watcher)，触发订阅者的相应逻辑处理</span></span><br><span class=\"line\">      <span class=\"keyword\">this</span>.subs.forEach(<span class=\"function\"><span class=\"params\">sub</span> =&gt;</span> sub.update());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 为Dep类设置一个静态属性,默认为null,工作时指向当前的Watcher</span></span><br><span class=\"line\">  Dep.target = <span class=\"literal\">null</span>;</span><br></pre></td></tr></table></figure>\n<p>现在我们需要实现监听者(Observer),用于监听属性值的变化。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 监听者,监听对象属性值的变化</span></span><br><span class=\"line\">  <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Observer</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">constructor</span>(value) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">this</span>.value = value;</span><br><span class=\"line\">      <span class=\"keyword\">this</span>.walk(value);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 遍历属性值并监听</span></span><br><span class=\"line\">    walk(value) &#123;</span><br><span class=\"line\">      <span class=\"built_in\">Object</span>.keys(value).forEach(<span class=\"function\"><span class=\"params\">key</span> =&gt;</span> <span class=\"keyword\">this</span>.convert(key, value[key]));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 执行监听的具体方法</span></span><br><span class=\"line\">    convert(key, val) &#123;</span><br><span class=\"line\">      defineReactive(<span class=\"keyword\">this</span>.value, key, val);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">defineReactive</span>(<span class=\"params\">obj, key, val</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> dep = <span class=\"keyword\">new</span> Dep();</span><br><span class=\"line\">    <span class=\"comment\">// 给当前属性的值添加监听</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> chlidOb = observe(val);</span><br><span class=\"line\">    <span class=\"built_in\">Object</span>.defineProperty(obj, key, &#123;</span><br><span class=\"line\">      enumerable: <span class=\"literal\">true</span>,</span><br><span class=\"line\">      configurable: <span class=\"literal\">true</span>,</span><br><span class=\"line\">      get: <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 如果Dep类存在target属性，将其添加到dep实例的subs数组中</span></span><br><span class=\"line\">        <span class=\"comment\">// target指向一个Watcher实例，每个Watcher都是一个订阅者</span></span><br><span class=\"line\">        <span class=\"comment\">// Watcher实例在实例化过程中，会读取data中的某个属性，从而触发当前get方法</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (Dep.target) &#123;</span><br><span class=\"line\">          dep.depend();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> val;</span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">      set: <span class=\"function\"><span class=\"params\">newVal</span> =&gt;</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (val === newVal) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        val = newVal;</span><br><span class=\"line\">        <span class=\"comment\">// 对新值进行监听</span></span><br><span class=\"line\">        chlidOb = observe(newVal);</span><br><span class=\"line\">        <span class=\"comment\">// 通知所有订阅者，数值被改变了</span></span><br><span class=\"line\">        dep.notify();</span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">observe</span>(<span class=\"params\">value</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 当值不存在，或者不是复杂数据类型时，不再需要继续深入监听</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!value || <span class=\"keyword\">typeof</span> value !== <span class=\"string\">'object'</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Observer(value);</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure></p>\n<p>那么接下来就简单了,我们需要实现一个订阅者(Watcher)。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Watcher</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">constructor</span>(vm, expOrFn, cb) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">this</span>.depIds = &#123;&#125;; <span class=\"comment\">// hash储存订阅者的id,避免重复的订阅者</span></span><br><span class=\"line\">      <span class=\"keyword\">this</span>.vm = vm; <span class=\"comment\">// 被订阅的数据一定来自于当前Vue实例</span></span><br><span class=\"line\">      <span class=\"keyword\">this</span>.cb = cb; <span class=\"comment\">// 当数据更新时想要做的事情</span></span><br><span class=\"line\">      <span class=\"keyword\">this</span>.expOrFn = expOrFn; <span class=\"comment\">// 被订阅的数据</span></span><br><span class=\"line\">      <span class=\"keyword\">this</span>.val = <span class=\"keyword\">this</span>.get(); <span class=\"comment\">// 维护更新之前的数据</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 对外暴露的接口，用于在订阅的数据被更新时，由订阅者管理员(Dep)调用</span></span><br><span class=\"line\">    update() &#123;</span><br><span class=\"line\">      <span class=\"keyword\">this</span>.run();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    addDep(dep) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 如果在depIds的hash中没有当前的id,可以判断是新Watcher,因此可以添加到dep的数组中储存</span></span><br><span class=\"line\">      <span class=\"comment\">// 此判断是避免同id的Watcher被多次储存</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (!<span class=\"keyword\">this</span>.depIds.hasOwnProperty(dep.id)) &#123;</span><br><span class=\"line\">        dep.addSub(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.depIds[dep.id] = dep;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    run() &#123;</span><br><span class=\"line\">      <span class=\"keyword\">const</span> val = <span class=\"keyword\">this</span>.get();</span><br><span class=\"line\">      <span class=\"built_in\">console</span>.log(val);</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (val !== <span class=\"keyword\">this</span>.val) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.val = val;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.cb.call(<span class=\"keyword\">this</span>.vm, val);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    get() &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 当前订阅者(Watcher)读取被订阅数据的最新更新后的值时，通知订阅者管理员收集当前订阅者</span></span><br><span class=\"line\">      Dep.target = <span class=\"keyword\">this</span>;</span><br><span class=\"line\">      <span class=\"keyword\">const</span> val = <span class=\"keyword\">this</span>.vm._data[<span class=\"keyword\">this</span>.expOrFn];</span><br><span class=\"line\">      <span class=\"comment\">// 置空，用于下一个Watcher使用</span></span><br><span class=\"line\">      Dep.target = <span class=\"literal\">null</span>;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> val;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure></p>\n<p>那么我们最后完成Vue,将上述方法挂载在Vue上。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Vue</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">constructor</span>(options = &#123;&#125;) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 简化了$options的处理</span></span><br><span class=\"line\">      <span class=\"keyword\">this</span>.$options = options;</span><br><span class=\"line\">      <span class=\"comment\">// 简化了对data的处理</span></span><br><span class=\"line\">      <span class=\"keyword\">let</span> data = (<span class=\"keyword\">this</span>._data = <span class=\"keyword\">this</span>.$options.data);</span><br><span class=\"line\">      <span class=\"comment\">// 将所有data最外层属性代理到Vue实例上</span></span><br><span class=\"line\">      <span class=\"built_in\">Object</span>.keys(data).forEach(<span class=\"function\"><span class=\"params\">key</span> =&gt;</span> <span class=\"keyword\">this</span>._proxy(key));</span><br><span class=\"line\">      <span class=\"comment\">// 监听数据</span></span><br><span class=\"line\">      observe(data);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 对外暴露调用订阅者的接口，内部主要在指令中使用订阅者</span></span><br><span class=\"line\">    $watch(expOrFn, cb) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">new</span> Watcher(<span class=\"keyword\">this</span>, expOrFn, cb);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    _proxy(key) &#123;</span><br><span class=\"line\">      <span class=\"built_in\">Object</span>.defineProperty(<span class=\"keyword\">this</span>, key, &#123;</span><br><span class=\"line\">        configurable: <span class=\"literal\">true</span>,</span><br><span class=\"line\">        enumerable: <span class=\"literal\">true</span>,</span><br><span class=\"line\">        get: <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> <span class=\"keyword\">this</span>._data[key],</span><br><span class=\"line\">        set: <span class=\"function\"><span class=\"params\">val</span> =&gt;</span> &#123;</span><br><span class=\"line\">          <span class=\"keyword\">this</span>._data[key] = val;</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">      &#125;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure></p>\n<p>看下效果：<br>&emsp;&emsp;&emsp;&emsp;<img src=\"https://user-gold-cdn.xitu.io/2018/5/1/1631c5aa9c52493e?imageslim\" alt=\"\"></p>\n<p>在线示例<a href=\"https://codepen.io/experor-xxy/pen/gzoYXL\" target=\"_blank\" rel=\"noopener\">双向绑定实现—无漏洞版</a></p>\n<p>至此,一个简单的双向绑定算是被我们实现了。</p>\n<h5 id=\"2-3-Object-defineProperty的缺陷\"><a href=\"#2-3-Object-defineProperty的缺陷\" class=\"headerlink\" title=\"2.3 Object.defineProperty的缺陷\"></a>2.3 Object.defineProperty的缺陷</h5><p>其实我们升级版的双向绑定依然存在漏洞,比如我们将属性值改为数组。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> demo = <span class=\"keyword\">new</span> Vue(&#123;</span><br><span class=\"line\">  data: &#123;</span><br><span class=\"line\">    list: [<span class=\"number\">1</span>],</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> list = <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">'list'</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> btn = <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">'btn'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">btn.addEventListener(<span class=\"string\">'click'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  demo.list.push(<span class=\"number\">1</span>);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> render = <span class=\"function\"><span class=\"params\">arr</span> =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> fragment = <span class=\"built_in\">document</span>.createDocumentFragment();</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> li = <span class=\"built_in\">document</span>.createElement(<span class=\"string\">'li'</span>);</span><br><span class=\"line\">    li.textContent = arr[i];</span><br><span class=\"line\">    fragment.appendChild(li);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  list.appendChild(fragment);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 监听数组,每次数组变化则触发渲染函数,然而...无法监听</span></span><br><span class=\"line\">demo.$watch(<span class=\"string\">'list'</span>, list =&gt; render(list));</span><br><span class=\"line\"></span><br><span class=\"line\">setTimeout(</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    alert(demo.list);</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  <span class=\"number\">5000</span>,</span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure></p>\n<p>在线示例 <a href=\"https://codepen.io/experor-xxy/pen/VxyZXv\" target=\"_blank\" rel=\"noopener\">双向绑定-数组漏洞</a></p>\n<p>是的,<code>Object.defineProperty</code>的第一个缺陷,无法监听数组变化。 然而Vue的文档提到了Vue是可以检测到数组变化的，但是只有以下八种方法,<code>vm.items[indexOfItem] = newValue</code>这种是无法检测的。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">push()</span><br><span class=\"line\">pop()</span><br><span class=\"line\">shift()</span><br><span class=\"line\">unshift()</span><br><span class=\"line\">splice()</span><br><span class=\"line\">sort()</span><br><span class=\"line\">reverse()</span><br></pre></td></tr></table></figure>\n<p>其实作者在这里用了一些奇技淫巧,把无法监听数组的情况hack掉了,以下是方法示例。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> aryMethods = [<span class=\"string\">'push'</span>, <span class=\"string\">'pop'</span>, <span class=\"string\">'shift'</span>, <span class=\"string\">'unshift'</span>, <span class=\"string\">'splice'</span>, <span class=\"string\">'sort'</span>, <span class=\"string\">'reverse'</span>];</span><br><span class=\"line\"><span class=\"keyword\">const</span> arrayAugmentations = [];</span><br><span class=\"line\"></span><br><span class=\"line\">aryMethods.forEach(<span class=\"function\">(<span class=\"params\">method</span>)=&gt;</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 这里是原生Array的原型方法</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> original = <span class=\"built_in\">Array</span>.prototype[method];</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"comment\">// 将push, pop等封装好的方法定义在对象arrayAugmentations的属性上</span></span><br><span class=\"line\">   <span class=\"comment\">// 注意：是属性而非原型属性</span></span><br><span class=\"line\">    arrayAugmentations[method] = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">'我被改变啦!'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 调用对应的原生方法并返回结果</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> original.apply(<span class=\"keyword\">this</span>, <span class=\"built_in\">arguments</span>);</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> list = [<span class=\"string\">'a'</span>, <span class=\"string\">'b'</span>, <span class=\"string\">'c'</span>];</span><br><span class=\"line\"><span class=\"comment\">// 将我们要监听的数组的原型指针指向上面定义的空数组对象</span></span><br><span class=\"line\"><span class=\"comment\">// 别忘了这个空数组的属性上定义了我们封装好的push等方法</span></span><br><span class=\"line\">list.__proto__ = arrayAugmentations;</span><br><span class=\"line\">list.push(<span class=\"string\">'d'</span>);  <span class=\"comment\">// 我被改变啦！ 4</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 这里的list2没有被重新定义原型指针，所以就正常输出</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> list2 = [<span class=\"string\">'a'</span>, <span class=\"string\">'b'</span>, <span class=\"string\">'c'</span>];</span><br><span class=\"line\">list2.push(<span class=\"string\">'d'</span>);  <span class=\"comment\">// 4</span></span><br></pre></td></tr></table></figure></p>\n<p>由于只针对了八种方法进行了hack,所以其他数组的属性也是检测不到的,其中的坑很多,可以阅读上面提到的文档。</p>\n<p>我们应该注意到在上文中的实现里,我们多次用遍历方法遍历对象的属性，这就引出了<code>Object.defineProperty</code>的第二个缺陷,只能劫持对象的属性,因此我们需要对每个对象的每个属性进行遍历，如果属性值也是对象那么需要深度遍历,显然能劫持一个完整的对象是更好的选择。</p>\n<pre><code>Object.keys(value).forEach(key =&gt; this.convert(key, value[key]));\n</code></pre><hr>\n<p>####3.Proxy实现的双向绑定的特点<br><code>Proxy</code>在ES2015规范中被正式发布,它在目标对象之前架设一层“拦截”，外界对该对象的访问，都必须先通过这层拦截，因此提供了一种机制，可以对外界的访问进行过滤和改写,我们可以这样认为,<code>Proxy</code>是<code>Object.defineProperty</code>的全方位加强版,具体的文档可以查看<a href=\"http://es6.ruanyifeng.com/#docs/proxy\" target=\"_blank\" rel=\"noopener\">此处</a>;</p>\n<h5 id=\"3-1-Proxy可以直接监听对象而非属性\"><a href=\"#3-1-Proxy可以直接监听对象而非属性\" class=\"headerlink\" title=\"3.1 Proxy可以直接监听对象而非属性\"></a>3.1 Proxy可以直接监听对象而非属性</h5><p>我们还是以上文中用<code>Object.defineProperty</code>实现的极简版双向绑定为例,用<code>Proxy</code>进行改写。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> input = <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">'input'</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> p = <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">'p'</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> obj = &#123;&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> newObj = <span class=\"keyword\">new</span> <span class=\"built_in\">Proxy</span>(obj, &#123;</span><br><span class=\"line\">  get: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">target, key, receiver</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">`getting <span class=\"subst\">$&#123;key&#125;</span>!`</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">Reflect</span>.get(target, key, receiver);</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  set: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">target, key, value, receiver</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(target, key, value, receiver);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (key === <span class=\"string\">'text'</span>) &#123;</span><br><span class=\"line\">      input.value = value;</span><br><span class=\"line\">      p.innerHTML = value;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">Reflect</span>.set(target, key, value, receiver);</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">input.addEventListener(<span class=\"string\">'keyup'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">e</span>) </span>&#123;</span><br><span class=\"line\">  newObj.text = e.target.value;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></p>\n<p>在线示例 <a href=\"https://codepen.io/experor-xxy/pen/pVpvjg\" target=\"_blank\" rel=\"noopener\">Proxy版</a></p>\n<p>我们可以看到,<code>Proxy</code>直接可以劫持整个对象,并返回一个新对象,不管是操作便利程度还是底层功能上都远强于<code>Object.defineProperty</code>。</p>\n<h5 id=\"3-2-Proxy可以直接监听数组的变化\"><a href=\"#3-2-Proxy可以直接监听数组的变化\" class=\"headerlink\" title=\"3.2 Proxy可以直接监听数组的变化\"></a>3.2 Proxy可以直接监听数组的变化</h5><p>当我们对数组进行操作(<code>push</code>、<code>shift</code>、<code>splice</code>等)时，会触发对应的方法名称和<code>length</code>的变化，我们可以借此进行操作,以上文中<code>Object.defineProperty</code>无法生效的列表渲染为例。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> list = <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">'list'</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> btn = <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">'btn'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 渲染列表</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> Render = &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 初始化</span></span><br><span class=\"line\">  init: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">arr</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> fragment = <span class=\"built_in\">document</span>.createDocumentFragment();</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">const</span> li = <span class=\"built_in\">document</span>.createElement(<span class=\"string\">'li'</span>);</span><br><span class=\"line\">      li.textContent = arr[i];</span><br><span class=\"line\">      fragment.appendChild(li);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    list.appendChild(fragment);</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  <span class=\"comment\">// 我们只考虑了增加的情况,仅作为示例</span></span><br><span class=\"line\">  change: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">val</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> li = <span class=\"built_in\">document</span>.createElement(<span class=\"string\">'li'</span>);</span><br><span class=\"line\">    li.textContent = val;</span><br><span class=\"line\">    list.appendChild(li);</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 初始数组</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> arr = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 监听数组</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> newArr = <span class=\"keyword\">new</span> <span class=\"built_in\">Proxy</span>(arr, &#123;</span><br><span class=\"line\">  get: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">target, key, receiver</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(key);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">Reflect</span>.get(target, key, receiver);</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  set: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">target, key, value, receiver</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(target, key, value, receiver);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (key !== <span class=\"string\">'length'</span>) &#123;</span><br><span class=\"line\">      Render.change(value);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">Reflect</span>.set(target, key, value, receiver);</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 初始化</span></span><br><span class=\"line\"><span class=\"built_in\">window</span>.onload = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    Render.init(arr);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// push数字</span></span><br><span class=\"line\">btn.addEventListener(<span class=\"string\">'click'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  newArr.push(<span class=\"number\">6</span>);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>在线示例 <a href=\"https://codepen.io/experor-xxy/pen/qYpEbx\" target=\"_blank\" rel=\"noopener\">Proxy列表渲染</a></p>\n<p>很显然,Proxy不需要那么多hack（即使hack也无法完美实现监听）就可以无压力监听数组的变化,我们都知道,标准永远优先于hack。</p>\n<h5 id=\"3-3-Proxy的其他优势\"><a href=\"#3-3-Proxy的其他优势\" class=\"headerlink\" title=\"3.3 Proxy的其他优势\"></a>3.3 Proxy的其他优势</h5><p>Proxy有多达13种拦截方法,不限于<code>apply</code>、<code>ownKeys</code>、<code>deleteProperty</code>、<code>has</code>等等是<code>Object.defineProperty</code>不具备的。</p>\n<p>Proxy返回的是一个新对象,我们可以只操作新的对象达到目的,而<code>Object.defineProperty</code>只能遍历对象属性直接修改。</p>\n<p>Proxy作为新标准将受到浏览器厂商重点持续的性能优化，也就是传说中的新标准的性能红利。</p>\n<p>当然,Proxy的劣势就是兼容性问题,而且无法用polyfill磨平,因此Vue的作者才声明需要等到下个大版本(3.0)才能用Proxy重写。</p>"},{"layout":"既然react/vue可以用event","title":"Bus进行组件通信,你可以实现下吗?","date":"2018-04-23T08:19:11.000Z","_content":"#### 前言\n本文标题的题目是由其他问题延伸而来,面试中面试官的常用套路,揪住一个问题一直深挖,在产生这个问题之前一定是这个问题.\n\n> React/Vue不同组件之间是怎么通信的?\n\n<!-- more -->\n\n**Vue**\n1. 父子组件用`Props`通信\n2. 非父子组件用`Event Bus`通信\n3. 如果项目够复杂,可能需要`Vuex`等全局状态管理库通信\n4. `$dispatch`(已经废除)和`$broadcast`(已经废除)\n\n**React**\n1. 父子组件,父->子直接用`Props`,子->父用`callback`回调\n2. 非父子组件,用发布订阅模式的`Event`模块\n3. 项目复杂的话用`Redux`、`Mobx`等全局状态管理管库\n4. 用新的[Context Api](https://juejin.im/post/5a7b41605188257a6310fbec)\n\n我们大体上都会有以上回答,接下来很可能会问到如何实现`Event(Bus)`,因为这个东西太重要了,几乎所有的模块通信都是基于类似的模式,包括安卓开发中的`Event Bus`,Node.js中的`Event`模块(Node中几乎所有的模块都依赖于`Event`,包括不限于`http`、`stream`、`buffer`、`fs`等).\n\n我们仿照`Node`中[Event API](http://nodejs.cn/api/events.html)实现一个简单的`Event`库,他是发布订阅模式的典型应用.\n\n> 提前声明: 我们没有对传入的参数进行及时判断而规避错误,仅仅对核心方法进行了实现.\n\n#### 1.基本构造\n##### 1.1初始化class\n我们利用ES6的`class`关键字对`Event`进行初始化,包括`Event`的事件清单和监听者上限.\n\n我们选择了`Map`作为储存事件的结构,因为作为键值对的储存方式`Map`比一般对象更加适合,我们操作起来也更加简洁,可以先看一下[Map的基本用法与特点](http://es6.ruanyifeng.com/#docs/set-map#Map).\n\n```javascript\nclass EventEmeitter {\n  constructor() {\n    this._events = this._events || new Map(); // 储存事件/回调键值对\n    this._maxListeners = this._maxListeners || 10; // 设立监听上限\n  }\n}\n```\n##### 1.2 监听与触发\n触发监听函数我们可以用`apply`与`call`两种方法,在少数参数时`call`的性能更好,多个参数时`apply`性能更好,当年`Node`的`Event`模块就在三个参数以下用`call`否则用`apply`.\n\n当然当Node全面拥抱ES6+之后,相应的`call/apply`操作用`Reflect`新关键字重写了,但是我们不想写的那么复杂,就做了一个简化版.\n\n```javascript\n// 触发名为type的事件\nEventEmeitter.prototype.emit = function(type, ...args) {\n  let handler;\n  // 从储存事件键值对的this._events中获取对应事件回调函数\n  handler = this._events.get(type);\n  if (args.length > 0) {\n    handler.apply(this, args);\n  } else {\n    handler.call(this);\n  }\n  return true;\n};\n\n// 监听名为type的事件\nEventEmeitter.prototype.addListener = function(type, fn) {\n  // 将type事件以及对应的fn函数放入this._events中储存\n  if (!this._events.get(type)) {\n    this._events.set(type, fn);\n  }\n};\n```\n\n我们实现了触发事件的`emit`方法和监听事件的`addListener`方法,至此我们就可以进行简单的实践了.\n\n```javascript\n// 实例化\nconst emitter = new EventEmeitter();\n\n// 监听一个名为arson的事件对应一个回调函数\nemitter.addListener('arson', man => {\n  console.log(`expel ${man}`);\n});\n\n// 我们触发arson事件,发现回调成功执行\nemitter.emit('arson', 'low-end'); // expel low-end\n```\n似乎不错,我们实现了基本的触发/监听,但是如果有多个监听者呢?\n```javascript\n// 重复监听同一个事件名\nemitter.addListener('arson', man => {\n  console.log(`expel ${man}`);\n});\nemitter.addListener('arson', man => {\n  console.log(`save ${man}`);\n});\n\nemitter.emit('arson', 'low-end'); // expel low-end\n```\n是的,只会触发第一个,因此我们需要进行改造.\n\n***\n#### 2.升级改造\n##### 2.1 监听/触发器升级\n我们的`addListener`实现方法还不够健全,在绑定第一个监听者之后,我们就无法对后续监听者进行绑定了,因此我们需要将后续监听者与第一个监听者函数放到一个数组里.\n```javascript\n// 触发名为type的事件\nEventEmeitter.prototype.emit = function(type, ...args) {\n  let handler;\n  handler = this._events.get(type);\n  if (Array.isArray(handler)) {\n    // 如果是一个数组说明有多个监听者,需要依次此触发里面的函数\n    for (let i = 0; i < handler.length; i++) {\n      if (args.length > 0) {\n        handler[i].apply(this, args);\n      } else {\n        handler[i].call(this);\n      }\n    }\n  } else { // 单个函数的情况我们直接触发即可\n    if (args.length > 0) {\n      handler.apply(this, args);\n    } else {\n      handler.call(this);\n    }\n  }\n\n  return true;\n};\n\n// 监听名为type的事件\nEventEmeitter.prototype.addListener = function(type, fn) {\n  const handler = this._events.get(type); // 获取对应事件名称的函数清单\n  if (!handler) {\n    this._events.set(type, fn);\n  } else if (handler && typeof handler === 'function') {\n    // 如果handler是函数说明只有一个监听者\n    this._events.set(type, [handler, fn]); // 多个监听者我们需要用数组储存\n  } else {\n    handler.push(fn); // 已经有多个监听者,那么直接往数组里push函数即可\n  }\n};\n```\n是的,从此以后可以愉快的触发多个监听者的函数了.\n```javascript\n// 监听同一个事件名\nemitter.addListener('arson', man => {\n  console.log(`expel ${man}`);\n});\nemitter.addListener('arson', man => {\n  console.log(`save ${man}`);\n});\n\nemitter.addListener('arson', man => {\n  console.log(`kill ${man}`);\n});\n\n// 触发事件\nemitter.emit('arson', 'low-end');\n//expel low-end\n//save low-end\n//kill low-end\n```\n##### 2.2 移除监听\n我们会用`removeListener`函数移除监听函数,但是匿名函数是无法移除的.\n```javascript\nEventEmeitter.prototype.removeListener = function(type, fn) {\n  const handler = this._events.get(type); // 获取对应事件名称的函数清单\n\n  // 如果是函数,说明只被监听了一次\n  if (handler && typeof handler === 'function') {\n    this._events.delete(type, fn);\n  } else {\n    let postion;\n    // 如果handler是数组,说明被监听多次要找到对应的函数\n    for (let i = 0; i < handler.length; i++) {\n      if (handler[i] === fn) {\n        postion = i;\n      } else {\n        postion = -1;\n      }\n    }\n    // 如果找到匹配的函数,从数组中清除\n    if (postion !== -1) {\n      // 找到数组对应的位置,直接清除此回调\n      handler.splice(postion, 1);\n      // 如果清除后只有一个函数,那么取消数组,以函数形式保存\n      if (handler.length === 1) {\n        this._events.set(type, handler[0]);\n      }\n    } else {\n      return this;\n    }\n  }\n};\n```\n\n***\n#### 3.发现问题\n我们已经基本完成了`Event`最重要的几个方法,也完成了升级改造,可以说一个`Event`的骨架是被我们开发出来了,但是它仍然有不足和需要补充的地方.\n\n> 1.我们没有对参数进行充分的判断,没有完善的报错机制.\n> 2.模拟不够充分: 除了`removeAllListeners`这些方法没有实现以外,例如监听时间后会触发`newListener`事件,我们也没有实现,另外最开始的监听者上限我们也没有利用到.\n\n当然,这在面试中现场写一个`Event`已经是很够意思了,主要是体现出来对发布-订阅模式的理解,以及针对多个监听状况下的处理,不可能现场撸几百行写一个完整`Event`.\n\n索性[Event](https://github.com/Gozala/events/blob/master/events.js)库帮我们实现了完整的特性,整个代码量有300多行,很适合阅读,你可以花十分钟的时间通读一下,见识一下完整的Event实现.\n","source":"_posts/vue-react-EventBus.md","raw":"---\nlayout: 既然react/vue可以用event\ntitle: 'Bus进行组件通信,你可以实现下吗?'\ndate: 2018-04-23 16:19:11\ntags:\n    - Event Bus\ncategories:\n    - 面试题\n    - vue\n    - react\n---\n#### 前言\n本文标题的题目是由其他问题延伸而来,面试中面试官的常用套路,揪住一个问题一直深挖,在产生这个问题之前一定是这个问题.\n\n> React/Vue不同组件之间是怎么通信的?\n\n<!-- more -->\n\n**Vue**\n1. 父子组件用`Props`通信\n2. 非父子组件用`Event Bus`通信\n3. 如果项目够复杂,可能需要`Vuex`等全局状态管理库通信\n4. `$dispatch`(已经废除)和`$broadcast`(已经废除)\n\n**React**\n1. 父子组件,父->子直接用`Props`,子->父用`callback`回调\n2. 非父子组件,用发布订阅模式的`Event`模块\n3. 项目复杂的话用`Redux`、`Mobx`等全局状态管理管库\n4. 用新的[Context Api](https://juejin.im/post/5a7b41605188257a6310fbec)\n\n我们大体上都会有以上回答,接下来很可能会问到如何实现`Event(Bus)`,因为这个东西太重要了,几乎所有的模块通信都是基于类似的模式,包括安卓开发中的`Event Bus`,Node.js中的`Event`模块(Node中几乎所有的模块都依赖于`Event`,包括不限于`http`、`stream`、`buffer`、`fs`等).\n\n我们仿照`Node`中[Event API](http://nodejs.cn/api/events.html)实现一个简单的`Event`库,他是发布订阅模式的典型应用.\n\n> 提前声明: 我们没有对传入的参数进行及时判断而规避错误,仅仅对核心方法进行了实现.\n\n#### 1.基本构造\n##### 1.1初始化class\n我们利用ES6的`class`关键字对`Event`进行初始化,包括`Event`的事件清单和监听者上限.\n\n我们选择了`Map`作为储存事件的结构,因为作为键值对的储存方式`Map`比一般对象更加适合,我们操作起来也更加简洁,可以先看一下[Map的基本用法与特点](http://es6.ruanyifeng.com/#docs/set-map#Map).\n\n```javascript\nclass EventEmeitter {\n  constructor() {\n    this._events = this._events || new Map(); // 储存事件/回调键值对\n    this._maxListeners = this._maxListeners || 10; // 设立监听上限\n  }\n}\n```\n##### 1.2 监听与触发\n触发监听函数我们可以用`apply`与`call`两种方法,在少数参数时`call`的性能更好,多个参数时`apply`性能更好,当年`Node`的`Event`模块就在三个参数以下用`call`否则用`apply`.\n\n当然当Node全面拥抱ES6+之后,相应的`call/apply`操作用`Reflect`新关键字重写了,但是我们不想写的那么复杂,就做了一个简化版.\n\n```javascript\n// 触发名为type的事件\nEventEmeitter.prototype.emit = function(type, ...args) {\n  let handler;\n  // 从储存事件键值对的this._events中获取对应事件回调函数\n  handler = this._events.get(type);\n  if (args.length > 0) {\n    handler.apply(this, args);\n  } else {\n    handler.call(this);\n  }\n  return true;\n};\n\n// 监听名为type的事件\nEventEmeitter.prototype.addListener = function(type, fn) {\n  // 将type事件以及对应的fn函数放入this._events中储存\n  if (!this._events.get(type)) {\n    this._events.set(type, fn);\n  }\n};\n```\n\n我们实现了触发事件的`emit`方法和监听事件的`addListener`方法,至此我们就可以进行简单的实践了.\n\n```javascript\n// 实例化\nconst emitter = new EventEmeitter();\n\n// 监听一个名为arson的事件对应一个回调函数\nemitter.addListener('arson', man => {\n  console.log(`expel ${man}`);\n});\n\n// 我们触发arson事件,发现回调成功执行\nemitter.emit('arson', 'low-end'); // expel low-end\n```\n似乎不错,我们实现了基本的触发/监听,但是如果有多个监听者呢?\n```javascript\n// 重复监听同一个事件名\nemitter.addListener('arson', man => {\n  console.log(`expel ${man}`);\n});\nemitter.addListener('arson', man => {\n  console.log(`save ${man}`);\n});\n\nemitter.emit('arson', 'low-end'); // expel low-end\n```\n是的,只会触发第一个,因此我们需要进行改造.\n\n***\n#### 2.升级改造\n##### 2.1 监听/触发器升级\n我们的`addListener`实现方法还不够健全,在绑定第一个监听者之后,我们就无法对后续监听者进行绑定了,因此我们需要将后续监听者与第一个监听者函数放到一个数组里.\n```javascript\n// 触发名为type的事件\nEventEmeitter.prototype.emit = function(type, ...args) {\n  let handler;\n  handler = this._events.get(type);\n  if (Array.isArray(handler)) {\n    // 如果是一个数组说明有多个监听者,需要依次此触发里面的函数\n    for (let i = 0; i < handler.length; i++) {\n      if (args.length > 0) {\n        handler[i].apply(this, args);\n      } else {\n        handler[i].call(this);\n      }\n    }\n  } else { // 单个函数的情况我们直接触发即可\n    if (args.length > 0) {\n      handler.apply(this, args);\n    } else {\n      handler.call(this);\n    }\n  }\n\n  return true;\n};\n\n// 监听名为type的事件\nEventEmeitter.prototype.addListener = function(type, fn) {\n  const handler = this._events.get(type); // 获取对应事件名称的函数清单\n  if (!handler) {\n    this._events.set(type, fn);\n  } else if (handler && typeof handler === 'function') {\n    // 如果handler是函数说明只有一个监听者\n    this._events.set(type, [handler, fn]); // 多个监听者我们需要用数组储存\n  } else {\n    handler.push(fn); // 已经有多个监听者,那么直接往数组里push函数即可\n  }\n};\n```\n是的,从此以后可以愉快的触发多个监听者的函数了.\n```javascript\n// 监听同一个事件名\nemitter.addListener('arson', man => {\n  console.log(`expel ${man}`);\n});\nemitter.addListener('arson', man => {\n  console.log(`save ${man}`);\n});\n\nemitter.addListener('arson', man => {\n  console.log(`kill ${man}`);\n});\n\n// 触发事件\nemitter.emit('arson', 'low-end');\n//expel low-end\n//save low-end\n//kill low-end\n```\n##### 2.2 移除监听\n我们会用`removeListener`函数移除监听函数,但是匿名函数是无法移除的.\n```javascript\nEventEmeitter.prototype.removeListener = function(type, fn) {\n  const handler = this._events.get(type); // 获取对应事件名称的函数清单\n\n  // 如果是函数,说明只被监听了一次\n  if (handler && typeof handler === 'function') {\n    this._events.delete(type, fn);\n  } else {\n    let postion;\n    // 如果handler是数组,说明被监听多次要找到对应的函数\n    for (let i = 0; i < handler.length; i++) {\n      if (handler[i] === fn) {\n        postion = i;\n      } else {\n        postion = -1;\n      }\n    }\n    // 如果找到匹配的函数,从数组中清除\n    if (postion !== -1) {\n      // 找到数组对应的位置,直接清除此回调\n      handler.splice(postion, 1);\n      // 如果清除后只有一个函数,那么取消数组,以函数形式保存\n      if (handler.length === 1) {\n        this._events.set(type, handler[0]);\n      }\n    } else {\n      return this;\n    }\n  }\n};\n```\n\n***\n#### 3.发现问题\n我们已经基本完成了`Event`最重要的几个方法,也完成了升级改造,可以说一个`Event`的骨架是被我们开发出来了,但是它仍然有不足和需要补充的地方.\n\n> 1.我们没有对参数进行充分的判断,没有完善的报错机制.\n> 2.模拟不够充分: 除了`removeAllListeners`这些方法没有实现以外,例如监听时间后会触发`newListener`事件,我们也没有实现,另外最开始的监听者上限我们也没有利用到.\n\n当然,这在面试中现场写一个`Event`已经是很够意思了,主要是体现出来对发布-订阅模式的理解,以及针对多个监听状况下的处理,不可能现场撸几百行写一个完整`Event`.\n\n索性[Event](https://github.com/Gozala/events/blob/master/events.js)库帮我们实现了完整的特性,整个代码量有300多行,很适合阅读,你可以花十分钟的时间通读一下,见识一下完整的Event实现.\n","slug":"vue-react-EventBus","published":1,"updated":"2018-05-08T02:59:03.159Z","comments":1,"photos":[],"link":"","_id":"cjhbjw6qs000ofx9maji0i8cm","content":"<h4 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h4><p>本文标题的题目是由其他问题延伸而来,面试中面试官的常用套路,揪住一个问题一直深挖,在产生这个问题之前一定是这个问题.</p>\n<blockquote>\n<p>React/Vue不同组件之间是怎么通信的?</p>\n</blockquote>\n<a id=\"more\"></a>\n<p><strong>Vue</strong></p>\n<ol>\n<li>父子组件用<code>Props</code>通信</li>\n<li>非父子组件用<code>Event Bus</code>通信</li>\n<li>如果项目够复杂,可能需要<code>Vuex</code>等全局状态管理库通信</li>\n<li><code>$dispatch</code>(已经废除)和<code>$broadcast</code>(已经废除)</li>\n</ol>\n<p><strong>React</strong></p>\n<ol>\n<li>父子组件,父-&gt;子直接用<code>Props</code>,子-&gt;父用<code>callback</code>回调</li>\n<li>非父子组件,用发布订阅模式的<code>Event</code>模块</li>\n<li>项目复杂的话用<code>Redux</code>、<code>Mobx</code>等全局状态管理管库</li>\n<li>用新的<a href=\"https://juejin.im/post/5a7b41605188257a6310fbec\" target=\"_blank\" rel=\"noopener\">Context Api</a></li>\n</ol>\n<p>我们大体上都会有以上回答,接下来很可能会问到如何实现<code>Event(Bus)</code>,因为这个东西太重要了,几乎所有的模块通信都是基于类似的模式,包括安卓开发中的<code>Event Bus</code>,Node.js中的<code>Event</code>模块(Node中几乎所有的模块都依赖于<code>Event</code>,包括不限于<code>http</code>、<code>stream</code>、<code>buffer</code>、<code>fs</code>等).</p>\n<p>我们仿照<code>Node</code>中<a href=\"http://nodejs.cn/api/events.html\" target=\"_blank\" rel=\"noopener\">Event API</a>实现一个简单的<code>Event</code>库,他是发布订阅模式的典型应用.</p>\n<blockquote>\n<p>提前声明: 我们没有对传入的参数进行及时判断而规避错误,仅仅对核心方法进行了实现.</p>\n</blockquote>\n<h4 id=\"1-基本构造\"><a href=\"#1-基本构造\" class=\"headerlink\" title=\"1.基本构造\"></a>1.基本构造</h4><h5 id=\"1-1初始化class\"><a href=\"#1-1初始化class\" class=\"headerlink\" title=\"1.1初始化class\"></a>1.1初始化class</h5><p>我们利用ES6的<code>class</code>关键字对<code>Event</code>进行初始化,包括<code>Event</code>的事件清单和监听者上限.</p>\n<p>我们选择了<code>Map</code>作为储存事件的结构,因为作为键值对的储存方式<code>Map</code>比一般对象更加适合,我们操作起来也更加简洁,可以先看一下<a href=\"http://es6.ruanyifeng.com/#docs/set-map#Map\" target=\"_blank\" rel=\"noopener\">Map的基本用法与特点</a>.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">EventEmeitter</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">constructor</span>() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>._events = <span class=\"keyword\">this</span>._events || <span class=\"keyword\">new</span> <span class=\"built_in\">Map</span>(); <span class=\"comment\">// 储存事件/回调键值对</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>._maxListeners = <span class=\"keyword\">this</span>._maxListeners || <span class=\"number\">10</span>; <span class=\"comment\">// 设立监听上限</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h5 id=\"1-2-监听与触发\"><a href=\"#1-2-监听与触发\" class=\"headerlink\" title=\"1.2 监听与触发\"></a>1.2 监听与触发</h5><p>触发监听函数我们可以用<code>apply</code>与<code>call</code>两种方法,在少数参数时<code>call</code>的性能更好,多个参数时<code>apply</code>性能更好,当年<code>Node</code>的<code>Event</code>模块就在三个参数以下用<code>call</code>否则用<code>apply</code>.</p>\n<p>当然当Node全面拥抱ES6+之后,相应的<code>call/apply</code>操作用<code>Reflect</code>新关键字重写了,但是我们不想写的那么复杂,就做了一个简化版.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 触发名为type的事件</span></span><br><span class=\"line\">EventEmeitter.prototype.emit = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">type, ...args</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> handler;</span><br><span class=\"line\">  <span class=\"comment\">// 从储存事件键值对的this._events中获取对应事件回调函数</span></span><br><span class=\"line\">  handler = <span class=\"keyword\">this</span>._events.get(type);</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (args.length &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">    handler.apply(<span class=\"keyword\">this</span>, args);</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    handler.call(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 监听名为type的事件</span></span><br><span class=\"line\">EventEmeitter.prototype.addListener = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">type, fn</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 将type事件以及对应的fn函数放入this._events中储存</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!<span class=\"keyword\">this</span>._events.get(type)) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>._events.set(type, fn);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>我们实现了触发事件的<code>emit</code>方法和监听事件的<code>addListener</code>方法,至此我们就可以进行简单的实践了.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 实例化</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> emitter = <span class=\"keyword\">new</span> EventEmeitter();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 监听一个名为arson的事件对应一个回调函数</span></span><br><span class=\"line\">emitter.addListener(<span class=\"string\">'arson'</span>, man =&gt; &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">`expel <span class=\"subst\">$&#123;man&#125;</span>`</span>);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 我们触发arson事件,发现回调成功执行</span></span><br><span class=\"line\">emitter.emit(<span class=\"string\">'arson'</span>, <span class=\"string\">'low-end'</span>); <span class=\"comment\">// expel low-end</span></span><br></pre></td></tr></table></figure>\n<p>似乎不错,我们实现了基本的触发/监听,但是如果有多个监听者呢?<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 重复监听同一个事件名</span></span><br><span class=\"line\">emitter.addListener(<span class=\"string\">'arson'</span>, man =&gt; &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">`expel <span class=\"subst\">$&#123;man&#125;</span>`</span>);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">emitter.addListener(<span class=\"string\">'arson'</span>, man =&gt; &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">`save <span class=\"subst\">$&#123;man&#125;</span>`</span>);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">emitter.emit(<span class=\"string\">'arson'</span>, <span class=\"string\">'low-end'</span>); <span class=\"comment\">// expel low-end</span></span><br></pre></td></tr></table></figure></p>\n<p>是的,只会触发第一个,因此我们需要进行改造.</p>\n<hr>\n<h4 id=\"2-升级改造\"><a href=\"#2-升级改造\" class=\"headerlink\" title=\"2.升级改造\"></a>2.升级改造</h4><h5 id=\"2-1-监听-触发器升级\"><a href=\"#2-1-监听-触发器升级\" class=\"headerlink\" title=\"2.1 监听/触发器升级\"></a>2.1 监听/触发器升级</h5><p>我们的<code>addListener</code>实现方法还不够健全,在绑定第一个监听者之后,我们就无法对后续监听者进行绑定了,因此我们需要将后续监听者与第一个监听者函数放到一个数组里.<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 触发名为type的事件</span></span><br><span class=\"line\">EventEmeitter.prototype.emit = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">type, ...args</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> handler;</span><br><span class=\"line\">  handler = <span class=\"keyword\">this</span>._events.get(type);</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"built_in\">Array</span>.isArray(handler)) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 如果是一个数组说明有多个监听者,需要依次此触发里面的函数</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; handler.length; i++) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (args.length &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        handler[i].apply(<span class=\"keyword\">this</span>, args);</span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        handler[i].call(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123; <span class=\"comment\">// 单个函数的情况我们直接触发即可</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (args.length &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">      handler.apply(<span class=\"keyword\">this</span>, args);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      handler.call(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 监听名为type的事件</span></span><br><span class=\"line\">EventEmeitter.prototype.addListener = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">type, fn</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> handler = <span class=\"keyword\">this</span>._events.get(type); <span class=\"comment\">// 获取对应事件名称的函数清单</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!handler) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>._events.set(type, fn);</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (handler &amp;&amp; <span class=\"keyword\">typeof</span> handler === <span class=\"string\">'function'</span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 如果handler是函数说明只有一个监听者</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>._events.set(type, [handler, fn]); <span class=\"comment\">// 多个监听者我们需要用数组储存</span></span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    handler.push(fn); <span class=\"comment\">// 已经有多个监听者,那么直接往数组里push函数即可</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<p>是的,从此以后可以愉快的触发多个监听者的函数了.<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 监听同一个事件名</span></span><br><span class=\"line\">emitter.addListener(<span class=\"string\">'arson'</span>, man =&gt; &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">`expel <span class=\"subst\">$&#123;man&#125;</span>`</span>);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">emitter.addListener(<span class=\"string\">'arson'</span>, man =&gt; &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">`save <span class=\"subst\">$&#123;man&#125;</span>`</span>);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">emitter.addListener(<span class=\"string\">'arson'</span>, man =&gt; &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">`kill <span class=\"subst\">$&#123;man&#125;</span>`</span>);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 触发事件</span></span><br><span class=\"line\">emitter.emit(<span class=\"string\">'arson'</span>, <span class=\"string\">'low-end'</span>);</span><br><span class=\"line\"><span class=\"comment\">//expel low-end</span></span><br><span class=\"line\"><span class=\"comment\">//save low-end</span></span><br><span class=\"line\"><span class=\"comment\">//kill low-end</span></span><br></pre></td></tr></table></figure></p>\n<h5 id=\"2-2-移除监听\"><a href=\"#2-2-移除监听\" class=\"headerlink\" title=\"2.2 移除监听\"></a>2.2 移除监听</h5><p>我们会用<code>removeListener</code>函数移除监听函数,但是匿名函数是无法移除的.<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">EventEmeitter.prototype.removeListener = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">type, fn</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> handler = <span class=\"keyword\">this</span>._events.get(type); <span class=\"comment\">// 获取对应事件名称的函数清单</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 如果是函数,说明只被监听了一次</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (handler &amp;&amp; <span class=\"keyword\">typeof</span> handler === <span class=\"string\">'function'</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>._events.delete(type, fn);</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> postion;</span><br><span class=\"line\">    <span class=\"comment\">// 如果handler是数组,说明被监听多次要找到对应的函数</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; handler.length; i++) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (handler[i] === fn) &#123;</span><br><span class=\"line\">        postion = i;</span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        postion = <span class=\"number\">-1</span>;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 如果找到匹配的函数,从数组中清除</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (postion !== <span class=\"number\">-1</span>) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 找到数组对应的位置,直接清除此回调</span></span><br><span class=\"line\">      handler.splice(postion, <span class=\"number\">1</span>);</span><br><span class=\"line\">      <span class=\"comment\">// 如果清除后只有一个函数,那么取消数组,以函数形式保存</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (handler.length === <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>._events.set(type, handler[<span class=\"number\">0</span>]);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<hr>\n<h4 id=\"3-发现问题\"><a href=\"#3-发现问题\" class=\"headerlink\" title=\"3.发现问题\"></a>3.发现问题</h4><p>我们已经基本完成了<code>Event</code>最重要的几个方法,也完成了升级改造,可以说一个<code>Event</code>的骨架是被我们开发出来了,但是它仍然有不足和需要补充的地方.</p>\n<blockquote>\n<p>1.我们没有对参数进行充分的判断,没有完善的报错机制.<br>2.模拟不够充分: 除了<code>removeAllListeners</code>这些方法没有实现以外,例如监听时间后会触发<code>newListener</code>事件,我们也没有实现,另外最开始的监听者上限我们也没有利用到.</p>\n</blockquote>\n<p>当然,这在面试中现场写一个<code>Event</code>已经是很够意思了,主要是体现出来对发布-订阅模式的理解,以及针对多个监听状况下的处理,不可能现场撸几百行写一个完整<code>Event</code>.</p>\n<p>索性<a href=\"https://github.com/Gozala/events/blob/master/events.js\" target=\"_blank\" rel=\"noopener\">Event</a>库帮我们实现了完整的特性,整个代码量有300多行,很适合阅读,你可以花十分钟的时间通读一下,见识一下完整的Event实现.</p>\n","site":{"data":{}},"excerpt":"<h4 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h4><p>本文标题的题目是由其他问题延伸而来,面试中面试官的常用套路,揪住一个问题一直深挖,在产生这个问题之前一定是这个问题.</p>\n<blockquote>\n<p>React/Vue不同组件之间是怎么通信的?</p>\n</blockquote>","more":"<p><strong>Vue</strong></p>\n<ol>\n<li>父子组件用<code>Props</code>通信</li>\n<li>非父子组件用<code>Event Bus</code>通信</li>\n<li>如果项目够复杂,可能需要<code>Vuex</code>等全局状态管理库通信</li>\n<li><code>$dispatch</code>(已经废除)和<code>$broadcast</code>(已经废除)</li>\n</ol>\n<p><strong>React</strong></p>\n<ol>\n<li>父子组件,父-&gt;子直接用<code>Props</code>,子-&gt;父用<code>callback</code>回调</li>\n<li>非父子组件,用发布订阅模式的<code>Event</code>模块</li>\n<li>项目复杂的话用<code>Redux</code>、<code>Mobx</code>等全局状态管理管库</li>\n<li>用新的<a href=\"https://juejin.im/post/5a7b41605188257a6310fbec\" target=\"_blank\" rel=\"noopener\">Context Api</a></li>\n</ol>\n<p>我们大体上都会有以上回答,接下来很可能会问到如何实现<code>Event(Bus)</code>,因为这个东西太重要了,几乎所有的模块通信都是基于类似的模式,包括安卓开发中的<code>Event Bus</code>,Node.js中的<code>Event</code>模块(Node中几乎所有的模块都依赖于<code>Event</code>,包括不限于<code>http</code>、<code>stream</code>、<code>buffer</code>、<code>fs</code>等).</p>\n<p>我们仿照<code>Node</code>中<a href=\"http://nodejs.cn/api/events.html\" target=\"_blank\" rel=\"noopener\">Event API</a>实现一个简单的<code>Event</code>库,他是发布订阅模式的典型应用.</p>\n<blockquote>\n<p>提前声明: 我们没有对传入的参数进行及时判断而规避错误,仅仅对核心方法进行了实现.</p>\n</blockquote>\n<h4 id=\"1-基本构造\"><a href=\"#1-基本构造\" class=\"headerlink\" title=\"1.基本构造\"></a>1.基本构造</h4><h5 id=\"1-1初始化class\"><a href=\"#1-1初始化class\" class=\"headerlink\" title=\"1.1初始化class\"></a>1.1初始化class</h5><p>我们利用ES6的<code>class</code>关键字对<code>Event</code>进行初始化,包括<code>Event</code>的事件清单和监听者上限.</p>\n<p>我们选择了<code>Map</code>作为储存事件的结构,因为作为键值对的储存方式<code>Map</code>比一般对象更加适合,我们操作起来也更加简洁,可以先看一下<a href=\"http://es6.ruanyifeng.com/#docs/set-map#Map\" target=\"_blank\" rel=\"noopener\">Map的基本用法与特点</a>.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">EventEmeitter</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">constructor</span>() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>._events = <span class=\"keyword\">this</span>._events || <span class=\"keyword\">new</span> <span class=\"built_in\">Map</span>(); <span class=\"comment\">// 储存事件/回调键值对</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>._maxListeners = <span class=\"keyword\">this</span>._maxListeners || <span class=\"number\">10</span>; <span class=\"comment\">// 设立监听上限</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h5 id=\"1-2-监听与触发\"><a href=\"#1-2-监听与触发\" class=\"headerlink\" title=\"1.2 监听与触发\"></a>1.2 监听与触发</h5><p>触发监听函数我们可以用<code>apply</code>与<code>call</code>两种方法,在少数参数时<code>call</code>的性能更好,多个参数时<code>apply</code>性能更好,当年<code>Node</code>的<code>Event</code>模块就在三个参数以下用<code>call</code>否则用<code>apply</code>.</p>\n<p>当然当Node全面拥抱ES6+之后,相应的<code>call/apply</code>操作用<code>Reflect</code>新关键字重写了,但是我们不想写的那么复杂,就做了一个简化版.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 触发名为type的事件</span></span><br><span class=\"line\">EventEmeitter.prototype.emit = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">type, ...args</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> handler;</span><br><span class=\"line\">  <span class=\"comment\">// 从储存事件键值对的this._events中获取对应事件回调函数</span></span><br><span class=\"line\">  handler = <span class=\"keyword\">this</span>._events.get(type);</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (args.length &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">    handler.apply(<span class=\"keyword\">this</span>, args);</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    handler.call(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 监听名为type的事件</span></span><br><span class=\"line\">EventEmeitter.prototype.addListener = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">type, fn</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 将type事件以及对应的fn函数放入this._events中储存</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!<span class=\"keyword\">this</span>._events.get(type)) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>._events.set(type, fn);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>我们实现了触发事件的<code>emit</code>方法和监听事件的<code>addListener</code>方法,至此我们就可以进行简单的实践了.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 实例化</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> emitter = <span class=\"keyword\">new</span> EventEmeitter();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 监听一个名为arson的事件对应一个回调函数</span></span><br><span class=\"line\">emitter.addListener(<span class=\"string\">'arson'</span>, man =&gt; &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">`expel <span class=\"subst\">$&#123;man&#125;</span>`</span>);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 我们触发arson事件,发现回调成功执行</span></span><br><span class=\"line\">emitter.emit(<span class=\"string\">'arson'</span>, <span class=\"string\">'low-end'</span>); <span class=\"comment\">// expel low-end</span></span><br></pre></td></tr></table></figure>\n<p>似乎不错,我们实现了基本的触发/监听,但是如果有多个监听者呢?<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 重复监听同一个事件名</span></span><br><span class=\"line\">emitter.addListener(<span class=\"string\">'arson'</span>, man =&gt; &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">`expel <span class=\"subst\">$&#123;man&#125;</span>`</span>);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">emitter.addListener(<span class=\"string\">'arson'</span>, man =&gt; &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">`save <span class=\"subst\">$&#123;man&#125;</span>`</span>);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">emitter.emit(<span class=\"string\">'arson'</span>, <span class=\"string\">'low-end'</span>); <span class=\"comment\">// expel low-end</span></span><br></pre></td></tr></table></figure></p>\n<p>是的,只会触发第一个,因此我们需要进行改造.</p>\n<hr>\n<h4 id=\"2-升级改造\"><a href=\"#2-升级改造\" class=\"headerlink\" title=\"2.升级改造\"></a>2.升级改造</h4><h5 id=\"2-1-监听-触发器升级\"><a href=\"#2-1-监听-触发器升级\" class=\"headerlink\" title=\"2.1 监听/触发器升级\"></a>2.1 监听/触发器升级</h5><p>我们的<code>addListener</code>实现方法还不够健全,在绑定第一个监听者之后,我们就无法对后续监听者进行绑定了,因此我们需要将后续监听者与第一个监听者函数放到一个数组里.<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 触发名为type的事件</span></span><br><span class=\"line\">EventEmeitter.prototype.emit = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">type, ...args</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> handler;</span><br><span class=\"line\">  handler = <span class=\"keyword\">this</span>._events.get(type);</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"built_in\">Array</span>.isArray(handler)) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 如果是一个数组说明有多个监听者,需要依次此触发里面的函数</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; handler.length; i++) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (args.length &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        handler[i].apply(<span class=\"keyword\">this</span>, args);</span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        handler[i].call(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123; <span class=\"comment\">// 单个函数的情况我们直接触发即可</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (args.length &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">      handler.apply(<span class=\"keyword\">this</span>, args);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      handler.call(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 监听名为type的事件</span></span><br><span class=\"line\">EventEmeitter.prototype.addListener = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">type, fn</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> handler = <span class=\"keyword\">this</span>._events.get(type); <span class=\"comment\">// 获取对应事件名称的函数清单</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!handler) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>._events.set(type, fn);</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (handler &amp;&amp; <span class=\"keyword\">typeof</span> handler === <span class=\"string\">'function'</span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 如果handler是函数说明只有一个监听者</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>._events.set(type, [handler, fn]); <span class=\"comment\">// 多个监听者我们需要用数组储存</span></span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    handler.push(fn); <span class=\"comment\">// 已经有多个监听者,那么直接往数组里push函数即可</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<p>是的,从此以后可以愉快的触发多个监听者的函数了.<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 监听同一个事件名</span></span><br><span class=\"line\">emitter.addListener(<span class=\"string\">'arson'</span>, man =&gt; &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">`expel <span class=\"subst\">$&#123;man&#125;</span>`</span>);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">emitter.addListener(<span class=\"string\">'arson'</span>, man =&gt; &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">`save <span class=\"subst\">$&#123;man&#125;</span>`</span>);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">emitter.addListener(<span class=\"string\">'arson'</span>, man =&gt; &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">`kill <span class=\"subst\">$&#123;man&#125;</span>`</span>);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 触发事件</span></span><br><span class=\"line\">emitter.emit(<span class=\"string\">'arson'</span>, <span class=\"string\">'low-end'</span>);</span><br><span class=\"line\"><span class=\"comment\">//expel low-end</span></span><br><span class=\"line\"><span class=\"comment\">//save low-end</span></span><br><span class=\"line\"><span class=\"comment\">//kill low-end</span></span><br></pre></td></tr></table></figure></p>\n<h5 id=\"2-2-移除监听\"><a href=\"#2-2-移除监听\" class=\"headerlink\" title=\"2.2 移除监听\"></a>2.2 移除监听</h5><p>我们会用<code>removeListener</code>函数移除监听函数,但是匿名函数是无法移除的.<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">EventEmeitter.prototype.removeListener = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">type, fn</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> handler = <span class=\"keyword\">this</span>._events.get(type); <span class=\"comment\">// 获取对应事件名称的函数清单</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 如果是函数,说明只被监听了一次</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (handler &amp;&amp; <span class=\"keyword\">typeof</span> handler === <span class=\"string\">'function'</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>._events.delete(type, fn);</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> postion;</span><br><span class=\"line\">    <span class=\"comment\">// 如果handler是数组,说明被监听多次要找到对应的函数</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; handler.length; i++) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (handler[i] === fn) &#123;</span><br><span class=\"line\">        postion = i;</span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        postion = <span class=\"number\">-1</span>;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 如果找到匹配的函数,从数组中清除</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (postion !== <span class=\"number\">-1</span>) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 找到数组对应的位置,直接清除此回调</span></span><br><span class=\"line\">      handler.splice(postion, <span class=\"number\">1</span>);</span><br><span class=\"line\">      <span class=\"comment\">// 如果清除后只有一个函数,那么取消数组,以函数形式保存</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (handler.length === <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>._events.set(type, handler[<span class=\"number\">0</span>]);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<hr>\n<h4 id=\"3-发现问题\"><a href=\"#3-发现问题\" class=\"headerlink\" title=\"3.发现问题\"></a>3.发现问题</h4><p>我们已经基本完成了<code>Event</code>最重要的几个方法,也完成了升级改造,可以说一个<code>Event</code>的骨架是被我们开发出来了,但是它仍然有不足和需要补充的地方.</p>\n<blockquote>\n<p>1.我们没有对参数进行充分的判断,没有完善的报错机制.<br>2.模拟不够充分: 除了<code>removeAllListeners</code>这些方法没有实现以外,例如监听时间后会触发<code>newListener</code>事件,我们也没有实现,另外最开始的监听者上限我们也没有利用到.</p>\n</blockquote>\n<p>当然,这在面试中现场写一个<code>Event</code>已经是很够意思了,主要是体现出来对发布-订阅模式的理解,以及针对多个监听状况下的处理,不可能现场撸几百行写一个完整<code>Event</code>.</p>\n<p>索性<a href=\"https://github.com/Gozala/events/blob/master/events.js\" target=\"_blank\" rel=\"noopener\">Event</a>库帮我们实现了完整的特性,整个代码量有300多行,很适合阅读,你可以花十分钟的时间通读一下,见识一下完整的Event实现.</p>"},{"title":"js 数组排序和算法排序","date":"2019-04-12T02:19:40.000Z","_content":"### 概述\n对所有的排序算法进行综合整理\n\n<!--more-->\n####  1.插入排序\n##### 原理\n>它的原理是每插入一个数都要将它和之前的已经完成排序的序列进行重新排序，也就是要找到新插入的数对应原序列中的位置。那么也就是说，每次插入一个数都要对原来排序好的那部分序列进行重新的排序，时间复杂度同样为O（n²）。 这种算法是稳定的排序方法。\n\n##### 图解\n![](http://www.leqikeji.cn/blogImg/charupaixu.gif)\n```javascript\nvar arr = [23,34,3,4,23,44,333,444];\n\nvar arrShow = (function insertionSort(array){\n    if(Object.prototype.toString.call(array).slice(8,-1) ==='Array'){\n\n    for (var i = 1; i < array.length; i++) {\n        var key = array[i];\n        var j = i - 1;\n        while (j >= 0 && array[j] > key) {\n            array[j + 1] = array[j];\n            j--;\n        }\n        array[j + 1] = key;\n    }\n        return array;\n    }else{\n        return 'array is not an Array!';\n    }\n})(arr);\n\nconsole.log(arrShow);//[3, 4, 23, 23, 34, 44, 333, 444]\n\n```\n\n#### 2.二分插入排序\n##### 算法思想\n>1.二分插入排序的基本思想和插入排序一致；都是将某个元素插入到已经有序的序列的正确的位置；\n\n>2.和直接插入排序的最大区别是，元素A[i]的位置的方法不一样；直接插入排序是从A[i-1]往前一个个比较，从而找到正确的位置；而二分插入排序，利用前i-1个元素已经是有序的特点结合二分查找的特点，找到正确的位置，从而将A[i]插入，并保持新的序列依旧有序；\n\n>3.时间复杂度：T(n) = O(n);\n```javascript\nfunction binaryInsertionSort(array) {\n    if (Object.prototype.toString.call(array).slice(8, -1) === 'Array') {\n    for (var i = 1; i < array.length; i++) {\n        var key = array[i], left = 0, right = i - 1;\n        while (left <= right) {\n            var middle = parseInt((left + right) / 2);\n            if (key < array[middle]) {\n                right = middle - 1;\n            } else {\n                left = middle + 1;\n            }\n        }\n        for (var j = i - 1; j >= left; j--) {\n            array[j + 1] = array[j];\n        }\n        array[left] = key;\n    }\n        return array;\n    } else {\n        return 'array is not an Array!';\n    }\n}\n```\n\n#### 3.选择排序\n##### 工作原理\n>它的工作原理是每一次从待排序的数据元素中选出最小（或最大）的一个元素，存放在序列的起始位置，直到全部待排序的数据元素排完。\n\n##### 图解\n![](http://www.leqikeji.cn/blogImg/xuanzepaixu.jpeg)\n选择排序就是对数组中的元素进行比较选择，然后直接放置在排序后的位置。 \n首先指针K先指向数组0号位置，K相当于指明一个目标位置。然后另一个指针min从K开始，往后一次比较，找到最小的值，并存储在min中，比较了一轮后，min中存储的数就是整个数组中最小的数字。这是直接将min中的数字和K指向的数字交换即可。然后找到数组中第二小的数，让他跟数组中第二个元素交换一下值，以此类推。\n```javascript\nfunction selectionSort(array) {\n    if (Object.prototype.toString.call(array).slice(8, -1) === 'Array') {\n        var len = array.length, temp;\n        for (var i = 0; i < len - 1; i++) {\n            var min = array[i];\n            for (var j = i + 1; j < len; j++) {\n                if (array[j] < min) {\n                    temp = min;\n                    min = array[j];\n                    array[j] = temp;\n                }\n            }\n            array[i] = min;\n        }\n        return array;\n    } else {\n        return 'array is not an Array!';\n    }\n}\n```\n\n#### 4.冒泡排序\n\n>原理：比较两个相邻的元素，将值大的元素交换至右端。\n\n>思路：依次比较相邻的两个数，将小数放在前面，大数放在后面。即在第一趟：首先比较第1个和第2个数，将小数放前，大数放后。然后比较第2个数和第3个数，将小数放前，大数放后，如此继续，直至比较最后两个数，将小数放前，大数放后。重复第一趟步骤，直至全部排序完成。\n```javascript\nfunction bubbleSort(array) {\n    if (Object.prototype.toString.call(array).slice(8, -1) === 'Array') {\n        var len = array.length, temp;\n        for (var i = 0; i < len - 1; i++) {\n            for (var j = len - 1; j >= i; j--) {\n                if (array[j] < array[j - 1]) {\n                    temp = array[j];\n                    array[j] = array[j - 1];\n                    array[j - 1] = temp;\n                }\n            }\n        }\n        return array;\n    } else {\n        return 'array is not an Array!';\n    }\n}\n```\n\n#### 5.快速排序\n##### 基本思想\n>基本思想是：通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列。\n\n##### 算法介绍\n![](https://gss1.bdstatic.com/-vo3dSag_xI4khGkpoWK1HF6hhy/baike/s%3D220/sign=2785ee7e918fa0ec7bc7630f1696594a/b7003af33a87e950707fdf2110385343fbf2b416.jpg)\n设要排序的数组是A[0]……A[N-1]，首先任意选取一个数据（通常选用数组的第一个数）作为关键数据，然后将所有比它小的数都放到它左边，所有比它大的数都放到它右边，这个过程称为一趟快速排序。值得注意的是，快速排序不是一种稳定的排序算法，也就是说，多个相同的值的相对位置也许会在算法结束时产生变动。\n一趟快速排序的算法是：\n1）设置两个变量i、j，排序开始的时候：i=0，j=N-1；\n2）以第一个数组元素作为关键数据，赋值给key，即key=A[0]；\n3）从j开始向前搜索，即由后开始向前搜索(j--)，找到第一个小于key的值A[j]，将A[j]和A[i]的值交换；\n4）从i开始向后搜索，即由前开始向后搜索(i++)，找到第一个大于key的A[i]，将A[i]和A[j]的值交换；\n5）重复第3、4步，直到i=j； (3,4步中，没找到符合条件的值，即3中A[j]不小于key,4中A[i]不大于key的时候改变j、i的值，使得j=j-1，i=i+1，直至找到为止。找到符合条件的值，进行交换的时候i， j指针位置不变。另外，i==j这一过程一定正好是i+或j-完成的时候，此时令循环结束）。\n```javascript\n//方法一\nfunction quickSort(array, left, right) {\n    if (Object.prototype.toString.call(array).slice(8, -1) === 'Array' && typeof left === 'number' && typeof right === 'number') {\n        if (left < right) {\n            var x = array[right], i = left - 1, temp;\n            for (var j = left; j <= right; j++) {\n                if (array[j] <= x) {\n                    i++;\n                    temp = array[i];\n                    array[i] = array[j];\n                    array[j] = temp;\n                }\n            }\n            quickSort(array, left, i - 1);\n            quickSort(array, i + 1, right);\n        };\n    } else {\n        return 'array is not an Array or left or right is not a number!';\n    }\n}\nvar aaa = [3, 5, 2, 9, 1];\nquickSort(aaa, 0, aaa.length - 1);\nconsole.log(aaa);\n    \n    \n//方法二\nvar quickSort = function(arr) {\n　　if (arr.length <= 1) { return arr; }\n　　var pivotIndex = Math.floor(arr.length / 2);\n　　var pivot = arr.splice(pivotIndex, 1)[0];\n　　var left = [];\n　　var right = [];\n　　for (var i = 0; i < arr.length; i++){\n　　　　if (arr[i] < pivot) {\n　　　　　　left.push(arr[i]);\n　　　　} else {\n　　　　　　right.push(arr[i]);\n　　　　}\n　　}\n　　return quickSort(left).concat([pivot], quickSort(right));\n};\n```\n\n#### 6.堆排序\n```javascript\n/*方法说明：堆排序\n@param array 待排序数组*/\nfunction heapSort(array) {\n    if (Object.prototype.toString.call(array).slice(8, -1) === 'Array') {\n        //建堆\n        var heapSize = array.length, temp;\n        for (var i = Math.floor(heapSize / 2); i >= 0; i--) {\n            heapify(array, i, heapSize);\n        }\n        \n        //堆排序\n        for (var j = heapSize - 1; j >= 1; j--) {\n            temp = array[0];\n            array[0] = array[j];\n            array[j] = temp;\n            heapify(array, 0, --heapSize);\n        }\n    } else {\n        return 'array is not an Array!';\n    }\n}\n/*方法说明：维护堆的性质\n@param arr 数组\n@param x 数组下标\n@param len 堆大小*/\nfunction heapify(arr, x, len) {\n    if (Object.prototype.toString.call(arr).slice(8, -1) === 'Array' && typeof x === 'number') {\n        var l = 2 * x, r = 2 * x + 1, largest = x, temp;\n        if (l < len && arr[l] > arr[largest]) {\n            largest = l;\n        }\n        if (r < len && arr[r] > arr[largest]) {\n            largest = r;\n        }\n        if (largest != x) {\n            temp = arr[x];\n            arr[x] = arr[largest];\n            arr[largest] = temp;\n            heapify(arr, largest, len);\n        }\n    } else {\n        return 'arr is not an Array or x is not a number!';\n    }\n}\n```\n\n#### 7.归并排序\n```javascript\nfunction mergeSort(array, p, r) {\n    if (p < r) {\n        var q = Math.floor((p + r) / 2);\n        mergeSort(array, p, q);\n        mergeSort(array, q + 1, r);\n        merge(array, p, q, r);\n    }\n}\nfunction merge(array, p, q, r) {\n    var n1 = q - p + 1, n2 = r - q, left = [], right = [], m = n = 0;\n    for (var i = 0; i < n1; i++) {\n        left[i] = array[p + i];\n    }\n    for (var j = 0; j < n2; j++) {\n        right[j] = array[q + 1 + j];\n    }\n    left[n1] = right[n2] = Number.MAX_VALUE;\n    for (var k = p; k <= r; k++) {\n        if (left[m] <= right[n]) {\n            array[k] = left[m];\n            m++;\n        } else {\n            array[k] = right[n];\n            n++;\n        }\n    }\n}\n```\n\n#### 8.桶排序\n```javascript\n/*方法说明：桶排序\n@param array 数组\n@param num 桶的数量*/\nfunction bucketSort(array, num) {\n    if (array.length <= 1) {\n        return array;\n    }\n    var len = array.length, buckets = [], result = [], min = max = array[0], regex = '/^[1-9]+[0-9]*$/', space, n = 0;\n    num = num || ((num > 1 && regex.test(num)) ? num : 10);\n    for (var i = 1; i < len; i++) {\n        min = min <= array[i] ? min : array[i];\n        max = max >= array[i] ? max : array[i];\n    }\n    space = (max - min + 1) / num;\n    for (var j = 0; j < len; j++) {\n        var index = Math.floor((array[j] - min) / space);\n        if (buckets[index]) { // 非空桶，插入排序\n            var k = buckets[index].length - 1;\n            while (k >= 0 && buckets[index][k] > array[j]) {\n                buckets[index][k + 1] = buckets[index][k];\n                k--;\n            }\n            buckets[index][k + 1] = array[j];\n        } else { //空桶，初始化\n            buckets[index] = [];\n            buckets[index].push(array[j]);\n        }\n    }\n    while (n < num) {\n        result = result.concat(buckets[n]);\n        n++;\n    }\n    return result;\n}\n```\n\n#### 9.计数排序\n```javascript\nfunction countingSort(array) {\n    var len = array.length, B = [], C = [], min = max = array[0];\n    for (var i = 0; i < len; i++) {\n        min = min <= array[i] ? min : array[i];\n        max = max >= array[i] ? max : array[i];\n        C[array[i]] = C[array[i]] ? C[array[i]] + 1 : 1;\n    }\n    for (var j = min; j < max; j++) {\n        C[j + 1] = (C[j + 1] || 0) + (C[j] || 0);\n    }\n    for (var k = len - 1; k >=0; k--) {\n        B[C[array[k]] - 1] = array[k];\n        C[array[k]]--;\n    }\n    return B;\n}\n```\n","source":"_posts/js数组排序和算法排序.md","raw":"---\ntitle: js 数组排序和算法排序\ndate: 2019-04-12 10:19:40\ntags:\n    -排序\ncategories:\n    - 技术分享\n---\n### 概述\n对所有的排序算法进行综合整理\n\n<!--more-->\n####  1.插入排序\n##### 原理\n>它的原理是每插入一个数都要将它和之前的已经完成排序的序列进行重新排序，也就是要找到新插入的数对应原序列中的位置。那么也就是说，每次插入一个数都要对原来排序好的那部分序列进行重新的排序，时间复杂度同样为O（n²）。 这种算法是稳定的排序方法。\n\n##### 图解\n![](http://www.leqikeji.cn/blogImg/charupaixu.gif)\n```javascript\nvar arr = [23,34,3,4,23,44,333,444];\n\nvar arrShow = (function insertionSort(array){\n    if(Object.prototype.toString.call(array).slice(8,-1) ==='Array'){\n\n    for (var i = 1; i < array.length; i++) {\n        var key = array[i];\n        var j = i - 1;\n        while (j >= 0 && array[j] > key) {\n            array[j + 1] = array[j];\n            j--;\n        }\n        array[j + 1] = key;\n    }\n        return array;\n    }else{\n        return 'array is not an Array!';\n    }\n})(arr);\n\nconsole.log(arrShow);//[3, 4, 23, 23, 34, 44, 333, 444]\n\n```\n\n#### 2.二分插入排序\n##### 算法思想\n>1.二分插入排序的基本思想和插入排序一致；都是将某个元素插入到已经有序的序列的正确的位置；\n\n>2.和直接插入排序的最大区别是，元素A[i]的位置的方法不一样；直接插入排序是从A[i-1]往前一个个比较，从而找到正确的位置；而二分插入排序，利用前i-1个元素已经是有序的特点结合二分查找的特点，找到正确的位置，从而将A[i]插入，并保持新的序列依旧有序；\n\n>3.时间复杂度：T(n) = O(n);\n```javascript\nfunction binaryInsertionSort(array) {\n    if (Object.prototype.toString.call(array).slice(8, -1) === 'Array') {\n    for (var i = 1; i < array.length; i++) {\n        var key = array[i], left = 0, right = i - 1;\n        while (left <= right) {\n            var middle = parseInt((left + right) / 2);\n            if (key < array[middle]) {\n                right = middle - 1;\n            } else {\n                left = middle + 1;\n            }\n        }\n        for (var j = i - 1; j >= left; j--) {\n            array[j + 1] = array[j];\n        }\n        array[left] = key;\n    }\n        return array;\n    } else {\n        return 'array is not an Array!';\n    }\n}\n```\n\n#### 3.选择排序\n##### 工作原理\n>它的工作原理是每一次从待排序的数据元素中选出最小（或最大）的一个元素，存放在序列的起始位置，直到全部待排序的数据元素排完。\n\n##### 图解\n![](http://www.leqikeji.cn/blogImg/xuanzepaixu.jpeg)\n选择排序就是对数组中的元素进行比较选择，然后直接放置在排序后的位置。 \n首先指针K先指向数组0号位置，K相当于指明一个目标位置。然后另一个指针min从K开始，往后一次比较，找到最小的值，并存储在min中，比较了一轮后，min中存储的数就是整个数组中最小的数字。这是直接将min中的数字和K指向的数字交换即可。然后找到数组中第二小的数，让他跟数组中第二个元素交换一下值，以此类推。\n```javascript\nfunction selectionSort(array) {\n    if (Object.prototype.toString.call(array).slice(8, -1) === 'Array') {\n        var len = array.length, temp;\n        for (var i = 0; i < len - 1; i++) {\n            var min = array[i];\n            for (var j = i + 1; j < len; j++) {\n                if (array[j] < min) {\n                    temp = min;\n                    min = array[j];\n                    array[j] = temp;\n                }\n            }\n            array[i] = min;\n        }\n        return array;\n    } else {\n        return 'array is not an Array!';\n    }\n}\n```\n\n#### 4.冒泡排序\n\n>原理：比较两个相邻的元素，将值大的元素交换至右端。\n\n>思路：依次比较相邻的两个数，将小数放在前面，大数放在后面。即在第一趟：首先比较第1个和第2个数，将小数放前，大数放后。然后比较第2个数和第3个数，将小数放前，大数放后，如此继续，直至比较最后两个数，将小数放前，大数放后。重复第一趟步骤，直至全部排序完成。\n```javascript\nfunction bubbleSort(array) {\n    if (Object.prototype.toString.call(array).slice(8, -1) === 'Array') {\n        var len = array.length, temp;\n        for (var i = 0; i < len - 1; i++) {\n            for (var j = len - 1; j >= i; j--) {\n                if (array[j] < array[j - 1]) {\n                    temp = array[j];\n                    array[j] = array[j - 1];\n                    array[j - 1] = temp;\n                }\n            }\n        }\n        return array;\n    } else {\n        return 'array is not an Array!';\n    }\n}\n```\n\n#### 5.快速排序\n##### 基本思想\n>基本思想是：通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列。\n\n##### 算法介绍\n![](https://gss1.bdstatic.com/-vo3dSag_xI4khGkpoWK1HF6hhy/baike/s%3D220/sign=2785ee7e918fa0ec7bc7630f1696594a/b7003af33a87e950707fdf2110385343fbf2b416.jpg)\n设要排序的数组是A[0]……A[N-1]，首先任意选取一个数据（通常选用数组的第一个数）作为关键数据，然后将所有比它小的数都放到它左边，所有比它大的数都放到它右边，这个过程称为一趟快速排序。值得注意的是，快速排序不是一种稳定的排序算法，也就是说，多个相同的值的相对位置也许会在算法结束时产生变动。\n一趟快速排序的算法是：\n1）设置两个变量i、j，排序开始的时候：i=0，j=N-1；\n2）以第一个数组元素作为关键数据，赋值给key，即key=A[0]；\n3）从j开始向前搜索，即由后开始向前搜索(j--)，找到第一个小于key的值A[j]，将A[j]和A[i]的值交换；\n4）从i开始向后搜索，即由前开始向后搜索(i++)，找到第一个大于key的A[i]，将A[i]和A[j]的值交换；\n5）重复第3、4步，直到i=j； (3,4步中，没找到符合条件的值，即3中A[j]不小于key,4中A[i]不大于key的时候改变j、i的值，使得j=j-1，i=i+1，直至找到为止。找到符合条件的值，进行交换的时候i， j指针位置不变。另外，i==j这一过程一定正好是i+或j-完成的时候，此时令循环结束）。\n```javascript\n//方法一\nfunction quickSort(array, left, right) {\n    if (Object.prototype.toString.call(array).slice(8, -1) === 'Array' && typeof left === 'number' && typeof right === 'number') {\n        if (left < right) {\n            var x = array[right], i = left - 1, temp;\n            for (var j = left; j <= right; j++) {\n                if (array[j] <= x) {\n                    i++;\n                    temp = array[i];\n                    array[i] = array[j];\n                    array[j] = temp;\n                }\n            }\n            quickSort(array, left, i - 1);\n            quickSort(array, i + 1, right);\n        };\n    } else {\n        return 'array is not an Array or left or right is not a number!';\n    }\n}\nvar aaa = [3, 5, 2, 9, 1];\nquickSort(aaa, 0, aaa.length - 1);\nconsole.log(aaa);\n    \n    \n//方法二\nvar quickSort = function(arr) {\n　　if (arr.length <= 1) { return arr; }\n　　var pivotIndex = Math.floor(arr.length / 2);\n　　var pivot = arr.splice(pivotIndex, 1)[0];\n　　var left = [];\n　　var right = [];\n　　for (var i = 0; i < arr.length; i++){\n　　　　if (arr[i] < pivot) {\n　　　　　　left.push(arr[i]);\n　　　　} else {\n　　　　　　right.push(arr[i]);\n　　　　}\n　　}\n　　return quickSort(left).concat([pivot], quickSort(right));\n};\n```\n\n#### 6.堆排序\n```javascript\n/*方法说明：堆排序\n@param array 待排序数组*/\nfunction heapSort(array) {\n    if (Object.prototype.toString.call(array).slice(8, -1) === 'Array') {\n        //建堆\n        var heapSize = array.length, temp;\n        for (var i = Math.floor(heapSize / 2); i >= 0; i--) {\n            heapify(array, i, heapSize);\n        }\n        \n        //堆排序\n        for (var j = heapSize - 1; j >= 1; j--) {\n            temp = array[0];\n            array[0] = array[j];\n            array[j] = temp;\n            heapify(array, 0, --heapSize);\n        }\n    } else {\n        return 'array is not an Array!';\n    }\n}\n/*方法说明：维护堆的性质\n@param arr 数组\n@param x 数组下标\n@param len 堆大小*/\nfunction heapify(arr, x, len) {\n    if (Object.prototype.toString.call(arr).slice(8, -1) === 'Array' && typeof x === 'number') {\n        var l = 2 * x, r = 2 * x + 1, largest = x, temp;\n        if (l < len && arr[l] > arr[largest]) {\n            largest = l;\n        }\n        if (r < len && arr[r] > arr[largest]) {\n            largest = r;\n        }\n        if (largest != x) {\n            temp = arr[x];\n            arr[x] = arr[largest];\n            arr[largest] = temp;\n            heapify(arr, largest, len);\n        }\n    } else {\n        return 'arr is not an Array or x is not a number!';\n    }\n}\n```\n\n#### 7.归并排序\n```javascript\nfunction mergeSort(array, p, r) {\n    if (p < r) {\n        var q = Math.floor((p + r) / 2);\n        mergeSort(array, p, q);\n        mergeSort(array, q + 1, r);\n        merge(array, p, q, r);\n    }\n}\nfunction merge(array, p, q, r) {\n    var n1 = q - p + 1, n2 = r - q, left = [], right = [], m = n = 0;\n    for (var i = 0; i < n1; i++) {\n        left[i] = array[p + i];\n    }\n    for (var j = 0; j < n2; j++) {\n        right[j] = array[q + 1 + j];\n    }\n    left[n1] = right[n2] = Number.MAX_VALUE;\n    for (var k = p; k <= r; k++) {\n        if (left[m] <= right[n]) {\n            array[k] = left[m];\n            m++;\n        } else {\n            array[k] = right[n];\n            n++;\n        }\n    }\n}\n```\n\n#### 8.桶排序\n```javascript\n/*方法说明：桶排序\n@param array 数组\n@param num 桶的数量*/\nfunction bucketSort(array, num) {\n    if (array.length <= 1) {\n        return array;\n    }\n    var len = array.length, buckets = [], result = [], min = max = array[0], regex = '/^[1-9]+[0-9]*$/', space, n = 0;\n    num = num || ((num > 1 && regex.test(num)) ? num : 10);\n    for (var i = 1; i < len; i++) {\n        min = min <= array[i] ? min : array[i];\n        max = max >= array[i] ? max : array[i];\n    }\n    space = (max - min + 1) / num;\n    for (var j = 0; j < len; j++) {\n        var index = Math.floor((array[j] - min) / space);\n        if (buckets[index]) { // 非空桶，插入排序\n            var k = buckets[index].length - 1;\n            while (k >= 0 && buckets[index][k] > array[j]) {\n                buckets[index][k + 1] = buckets[index][k];\n                k--;\n            }\n            buckets[index][k + 1] = array[j];\n        } else { //空桶，初始化\n            buckets[index] = [];\n            buckets[index].push(array[j]);\n        }\n    }\n    while (n < num) {\n        result = result.concat(buckets[n]);\n        n++;\n    }\n    return result;\n}\n```\n\n#### 9.计数排序\n```javascript\nfunction countingSort(array) {\n    var len = array.length, B = [], C = [], min = max = array[0];\n    for (var i = 0; i < len; i++) {\n        min = min <= array[i] ? min : array[i];\n        max = max >= array[i] ? max : array[i];\n        C[array[i]] = C[array[i]] ? C[array[i]] + 1 : 1;\n    }\n    for (var j = min; j < max; j++) {\n        C[j + 1] = (C[j + 1] || 0) + (C[j] || 0);\n    }\n    for (var k = len - 1; k >=0; k--) {\n        B[C[array[k]] - 1] = array[k];\n        C[array[k]]--;\n    }\n    return B;\n}\n```\n","slug":"js数组排序和算法排序","published":1,"updated":"2019-12-25T06:07:54.676Z","_id":"cjwssormh0000eg9m5ntsej3k","comments":1,"layout":"post","photos":[],"link":"","content":"<h3 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h3><p>对所有的排序算法进行综合整理</p>\n<a id=\"more\"></a>\n<h4 id=\"1-插入排序\"><a href=\"#1-插入排序\" class=\"headerlink\" title=\"1.插入排序\"></a>1.插入排序</h4><h5 id=\"原理\"><a href=\"#原理\" class=\"headerlink\" title=\"原理\"></a>原理</h5><blockquote>\n<p>它的原理是每插入一个数都要将它和之前的已经完成排序的序列进行重新排序，也就是要找到新插入的数对应原序列中的位置。那么也就是说，每次插入一个数都要对原来排序好的那部分序列进行重新的排序，时间复杂度同样为O（n²）。 这种算法是稳定的排序方法。</p>\n</blockquote>\n<h5 id=\"图解\"><a href=\"#图解\" class=\"headerlink\" title=\"图解\"></a>图解</h5><p><img src=\"http://www.leqikeji.cn/blogImg/charupaixu.gif\" alt=\"\"><br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> arr = [<span class=\"number\">23</span>,<span class=\"number\">34</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">23</span>,<span class=\"number\">44</span>,<span class=\"number\">333</span>,<span class=\"number\">444</span>];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> arrShow = (<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">insertionSort</span>(<span class=\"params\">array</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(<span class=\"built_in\">Object</span>.prototype.toString.call(array).slice(<span class=\"number\">8</span>,<span class=\"number\">-1</span>) ===<span class=\"string\">'Array'</span>)&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">1</span>; i &lt; array.length; i++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> key = array[i];</span><br><span class=\"line\">        <span class=\"keyword\">var</span> j = i - <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (j &gt;= <span class=\"number\">0</span> &amp;&amp; array[j] &gt; key) &#123;</span><br><span class=\"line\">            array[j + <span class=\"number\">1</span>] = array[j];</span><br><span class=\"line\">            j--;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        array[j + <span class=\"number\">1</span>] = key;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> array;</span><br><span class=\"line\">    &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">'array is not an Array!'</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;)(arr);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(arrShow);<span class=\"comment\">//[3, 4, 23, 23, 34, 44, 333, 444]</span></span><br></pre></td></tr></table></figure></p>\n<h4 id=\"2-二分插入排序\"><a href=\"#2-二分插入排序\" class=\"headerlink\" title=\"2.二分插入排序\"></a>2.二分插入排序</h4><h5 id=\"算法思想\"><a href=\"#算法思想\" class=\"headerlink\" title=\"算法思想\"></a>算法思想</h5><blockquote>\n<p>1.二分插入排序的基本思想和插入排序一致；都是将某个元素插入到已经有序的序列的正确的位置；</p>\n</blockquote>\n<blockquote>\n<p>2.和直接插入排序的最大区别是，元素A[i]的位置的方法不一样；直接插入排序是从A[i-1]往前一个个比较，从而找到正确的位置；而二分插入排序，利用前i-1个元素已经是有序的特点结合二分查找的特点，找到正确的位置，从而将A[i]插入，并保持新的序列依旧有序；</p>\n</blockquote>\n<blockquote>\n<p>3.时间复杂度：T(n) = O(n);<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">binaryInsertionSort</span>(<span class=\"params\">array</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"built_in\">Object</span>.prototype.toString.call(array).slice(<span class=\"number\">8</span>, <span class=\"number\">-1</span>) === <span class=\"string\">'Array'</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">1</span>; i &lt; array.length; i++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> key = array[i], left = <span class=\"number\">0</span>, right = i - <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (left &lt;= right) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">var</span> middle = <span class=\"built_in\">parseInt</span>((left + right) / <span class=\"number\">2</span>);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (key &lt; array[middle]) &#123;</span><br><span class=\"line\">                right = middle - <span class=\"number\">1</span>;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                left = middle + <span class=\"number\">1</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> j = i - <span class=\"number\">1</span>; j &gt;= left; j--) &#123;</span><br><span class=\"line\">            array[j + <span class=\"number\">1</span>] = array[j];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        array[left] = key;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> array;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">'array is not an Array!'</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n</blockquote>\n<h4 id=\"3-选择排序\"><a href=\"#3-选择排序\" class=\"headerlink\" title=\"3.选择排序\"></a>3.选择排序</h4><h5 id=\"工作原理\"><a href=\"#工作原理\" class=\"headerlink\" title=\"工作原理\"></a>工作原理</h5><blockquote>\n<p>它的工作原理是每一次从待排序的数据元素中选出最小（或最大）的一个元素，存放在序列的起始位置，直到全部待排序的数据元素排完。</p>\n</blockquote>\n<h5 id=\"图解-1\"><a href=\"#图解-1\" class=\"headerlink\" title=\"图解\"></a>图解</h5><p><img src=\"http://www.leqikeji.cn/blogImg/xuanzepaixu.jpeg\" alt=\"\"><br>选择排序就是对数组中的元素进行比较选择，然后直接放置在排序后的位置。<br>首先指针K先指向数组0号位置，K相当于指明一个目标位置。然后另一个指针min从K开始，往后一次比较，找到最小的值，并存储在min中，比较了一轮后，min中存储的数就是整个数组中最小的数字。这是直接将min中的数字和K指向的数字交换即可。然后找到数组中第二小的数，让他跟数组中第二个元素交换一下值，以此类推。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">selectionSort</span>(<span class=\"params\">array</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"built_in\">Object</span>.prototype.toString.call(array).slice(<span class=\"number\">8</span>, <span class=\"number\">-1</span>) === <span class=\"string\">'Array'</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> len = array.length, temp;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; len - <span class=\"number\">1</span>; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">var</span> min = array[i];</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> j = i + <span class=\"number\">1</span>; j &lt; len; j++) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (array[j] &lt; min) &#123;</span><br><span class=\"line\">                    temp = min;</span><br><span class=\"line\">                    min = array[j];</span><br><span class=\"line\">                    array[j] = temp;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            array[i] = min;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> array;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">'array is not an Array!'</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"4-冒泡排序\"><a href=\"#4-冒泡排序\" class=\"headerlink\" title=\"4.冒泡排序\"></a>4.冒泡排序</h4><blockquote>\n<p>原理：比较两个相邻的元素，将值大的元素交换至右端。</p>\n</blockquote>\n<blockquote>\n<p>思路：依次比较相邻的两个数，将小数放在前面，大数放在后面。即在第一趟：首先比较第1个和第2个数，将小数放前，大数放后。然后比较第2个数和第3个数，将小数放前，大数放后，如此继续，直至比较最后两个数，将小数放前，大数放后。重复第一趟步骤，直至全部排序完成。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">bubbleSort</span>(<span class=\"params\">array</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"built_in\">Object</span>.prototype.toString.call(array).slice(<span class=\"number\">8</span>, <span class=\"number\">-1</span>) === <span class=\"string\">'Array'</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> len = array.length, temp;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; len - <span class=\"number\">1</span>; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> j = len - <span class=\"number\">1</span>; j &gt;= i; j--) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (array[j] &lt; array[j - <span class=\"number\">1</span>]) &#123;</span><br><span class=\"line\">                    temp = array[j];</span><br><span class=\"line\">                    array[j] = array[j - <span class=\"number\">1</span>];</span><br><span class=\"line\">                    array[j - <span class=\"number\">1</span>] = temp;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> array;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">'array is not an Array!'</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n</blockquote>\n<h4 id=\"5-快速排序\"><a href=\"#5-快速排序\" class=\"headerlink\" title=\"5.快速排序\"></a>5.快速排序</h4><h5 id=\"基本思想\"><a href=\"#基本思想\" class=\"headerlink\" title=\"基本思想\"></a>基本思想</h5><blockquote>\n<p>基本思想是：通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列。</p>\n</blockquote>\n<h5 id=\"算法介绍\"><a href=\"#算法介绍\" class=\"headerlink\" title=\"算法介绍\"></a>算法介绍</h5><p><img src=\"https://gss1.bdstatic.com/-vo3dSag_xI4khGkpoWK1HF6hhy/baike/s%3D220/sign=2785ee7e918fa0ec7bc7630f1696594a/b7003af33a87e950707fdf2110385343fbf2b416.jpg\" alt=\"\"><br>设要排序的数组是A[0]……A[N-1]，首先任意选取一个数据（通常选用数组的第一个数）作为关键数据，然后将所有比它小的数都放到它左边，所有比它大的数都放到它右边，这个过程称为一趟快速排序。值得注意的是，快速排序不是一种稳定的排序算法，也就是说，多个相同的值的相对位置也许会在算法结束时产生变动。<br>一趟快速排序的算法是：<br>1）设置两个变量i、j，排序开始的时候：i=0，j=N-1；<br>2）以第一个数组元素作为关键数据，赋值给key，即key=A[0]；<br>3）从j开始向前搜索，即由后开始向前搜索(j–)，找到第一个小于key的值A[j]，将A[j]和A[i]的值交换；<br>4）从i开始向后搜索，即由前开始向后搜索(i++)，找到第一个大于key的A[i]，将A[i]和A[j]的值交换；<br>5）重复第3、4步，直到i=j； (3,4步中，没找到符合条件的值，即3中A[j]不小于key,4中A[i]不大于key的时候改变j、i的值，使得j=j-1，i=i+1，直至找到为止。找到符合条件的值，进行交换的时候i， j指针位置不变。另外，i==j这一过程一定正好是i+或j-完成的时候，此时令循环结束）。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//方法一</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">quickSort</span>(<span class=\"params\">array, left, right</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"built_in\">Object</span>.prototype.toString.call(array).slice(<span class=\"number\">8</span>, <span class=\"number\">-1</span>) === <span class=\"string\">'Array'</span> &amp;&amp; <span class=\"keyword\">typeof</span> left === <span class=\"string\">'number'</span> &amp;&amp; <span class=\"keyword\">typeof</span> right === <span class=\"string\">'number'</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (left &lt; right) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">var</span> x = array[right], i = left - <span class=\"number\">1</span>, temp;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> j = left; j &lt;= right; j++) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (array[j] &lt;= x) &#123;</span><br><span class=\"line\">                    i++;</span><br><span class=\"line\">                    temp = array[i];</span><br><span class=\"line\">                    array[i] = array[j];</span><br><span class=\"line\">                    array[j] = temp;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            quickSort(array, left, i - <span class=\"number\">1</span>);</span><br><span class=\"line\">            quickSort(array, i + <span class=\"number\">1</span>, right);</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">'array is not an Array or left or right is not a number!'</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> aaa = [<span class=\"number\">3</span>, <span class=\"number\">5</span>, <span class=\"number\">2</span>, <span class=\"number\">9</span>, <span class=\"number\">1</span>];</span><br><span class=\"line\">quickSort(aaa, <span class=\"number\">0</span>, aaa.length - <span class=\"number\">1</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(aaa);</span><br><span class=\"line\">    </span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"comment\">//方法二</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> quickSort = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">arr</span>) </span>&#123;</span><br><span class=\"line\">　　<span class=\"keyword\">if</span> (arr.length &lt;= <span class=\"number\">1</span>) &#123; <span class=\"keyword\">return</span> arr; &#125;</span><br><span class=\"line\">　　<span class=\"keyword\">var</span> pivotIndex = <span class=\"built_in\">Math</span>.floor(arr.length / <span class=\"number\">2</span>);</span><br><span class=\"line\">　　<span class=\"keyword\">var</span> pivot = arr.splice(pivotIndex, <span class=\"number\">1</span>)[<span class=\"number\">0</span>];</span><br><span class=\"line\">　　<span class=\"keyword\">var</span> left = [];</span><br><span class=\"line\">　　<span class=\"keyword\">var</span> right = [];</span><br><span class=\"line\">　　<span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; arr.length; i++)&#123;</span><br><span class=\"line\">　　　　<span class=\"keyword\">if</span> (arr[i] &lt; pivot) &#123;</span><br><span class=\"line\">　　　　　　left.push(arr[i]);</span><br><span class=\"line\">　　　　&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">　　　　　　right.push(arr[i]);</span><br><span class=\"line\">　　　　&#125;</span><br><span class=\"line\">　　&#125;</span><br><span class=\"line\">　　<span class=\"keyword\">return</span> quickSort(left).concat([pivot], quickSort(right));</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"6-堆排序\"><a href=\"#6-堆排序\" class=\"headerlink\" title=\"6.堆排序\"></a>6.堆排序</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*方法说明：堆排序</span></span><br><span class=\"line\"><span class=\"comment\">@param array 待排序数组*/</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">heapSort</span>(<span class=\"params\">array</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"built_in\">Object</span>.prototype.toString.call(array).slice(<span class=\"number\">8</span>, <span class=\"number\">-1</span>) === <span class=\"string\">'Array'</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">//建堆</span></span><br><span class=\"line\">        <span class=\"keyword\">var</span> heapSize = array.length, temp;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"built_in\">Math</span>.floor(heapSize / <span class=\"number\">2</span>); i &gt;= <span class=\"number\">0</span>; i--) &#123;</span><br><span class=\"line\">            heapify(array, i, heapSize);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">//堆排序</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> j = heapSize - <span class=\"number\">1</span>; j &gt;= <span class=\"number\">1</span>; j--) &#123;</span><br><span class=\"line\">            temp = array[<span class=\"number\">0</span>];</span><br><span class=\"line\">            array[<span class=\"number\">0</span>] = array[j];</span><br><span class=\"line\">            array[j] = temp;</span><br><span class=\"line\">            heapify(array, <span class=\"number\">0</span>, --heapSize);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">'array is not an Array!'</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">/*方法说明：维护堆的性质</span></span><br><span class=\"line\"><span class=\"comment\">@param arr 数组</span></span><br><span class=\"line\"><span class=\"comment\">@param x 数组下标</span></span><br><span class=\"line\"><span class=\"comment\">@param len 堆大小*/</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">heapify</span>(<span class=\"params\">arr, x, len</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"built_in\">Object</span>.prototype.toString.call(arr).slice(<span class=\"number\">8</span>, <span class=\"number\">-1</span>) === <span class=\"string\">'Array'</span> &amp;&amp; <span class=\"keyword\">typeof</span> x === <span class=\"string\">'number'</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> l = <span class=\"number\">2</span> * x, r = <span class=\"number\">2</span> * x + <span class=\"number\">1</span>, largest = x, temp;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (l &lt; len &amp;&amp; arr[l] &gt; arr[largest]) &#123;</span><br><span class=\"line\">            largest = l;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (r &lt; len &amp;&amp; arr[r] &gt; arr[largest]) &#123;</span><br><span class=\"line\">            largest = r;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (largest != x) &#123;</span><br><span class=\"line\">            temp = arr[x];</span><br><span class=\"line\">            arr[x] = arr[largest];</span><br><span class=\"line\">            arr[largest] = temp;</span><br><span class=\"line\">            heapify(arr, largest, len);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">'arr is not an Array or x is not a number!'</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"7-归并排序\"><a href=\"#7-归并排序\" class=\"headerlink\" title=\"7.归并排序\"></a>7.归并排序</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">mergeSort</span>(<span class=\"params\">array, p, r</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (p &lt; r) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> q = <span class=\"built_in\">Math</span>.floor((p + r) / <span class=\"number\">2</span>);</span><br><span class=\"line\">        mergeSort(array, p, q);</span><br><span class=\"line\">        mergeSort(array, q + <span class=\"number\">1</span>, r);</span><br><span class=\"line\">        merge(array, p, q, r);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">merge</span>(<span class=\"params\">array, p, q, r</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> n1 = q - p + <span class=\"number\">1</span>, n2 = r - q, left = [], right = [], m = n = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; n1; i++) &#123;</span><br><span class=\"line\">        left[i] = array[p + i];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> j = <span class=\"number\">0</span>; j &lt; n2; j++) &#123;</span><br><span class=\"line\">        right[j] = array[q + <span class=\"number\">1</span> + j];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    left[n1] = right[n2] = <span class=\"built_in\">Number</span>.MAX_VALUE;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> k = p; k &lt;= r; k++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (left[m] &lt;= right[n]) &#123;</span><br><span class=\"line\">            array[k] = left[m];</span><br><span class=\"line\">            m++;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            array[k] = right[n];</span><br><span class=\"line\">            n++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"8-桶排序\"><a href=\"#8-桶排序\" class=\"headerlink\" title=\"8.桶排序\"></a>8.桶排序</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*方法说明：桶排序</span></span><br><span class=\"line\"><span class=\"comment\">@param array 数组</span></span><br><span class=\"line\"><span class=\"comment\">@param num 桶的数量*/</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">bucketSort</span>(<span class=\"params\">array, num</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (array.length &lt;= <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> array;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> len = array.length, buckets = [], result = [], min = max = array[<span class=\"number\">0</span>], regex = <span class=\"string\">'/^[1-9]+[0-9]*$/'</span>, space, n = <span class=\"number\">0</span>;</span><br><span class=\"line\">    num = num || ((num &gt; <span class=\"number\">1</span> &amp;&amp; regex.test(num)) ? num : <span class=\"number\">10</span>);</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">1</span>; i &lt; len; i++) &#123;</span><br><span class=\"line\">        min = min &lt;= array[i] ? min : array[i];</span><br><span class=\"line\">        max = max &gt;= array[i] ? max : array[i];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    space = (max - min + <span class=\"number\">1</span>) / num;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> j = <span class=\"number\">0</span>; j &lt; len; j++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> index = <span class=\"built_in\">Math</span>.floor((array[j] - min) / space);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (buckets[index]) &#123; <span class=\"comment\">// 非空桶，插入排序</span></span><br><span class=\"line\">            <span class=\"keyword\">var</span> k = buckets[index].length - <span class=\"number\">1</span>;</span><br><span class=\"line\">            <span class=\"keyword\">while</span> (k &gt;= <span class=\"number\">0</span> &amp;&amp; buckets[index][k] &gt; array[j]) &#123;</span><br><span class=\"line\">                buckets[index][k + <span class=\"number\">1</span>] = buckets[index][k];</span><br><span class=\"line\">                k--;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            buckets[index][k + <span class=\"number\">1</span>] = array[j];</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123; <span class=\"comment\">//空桶，初始化</span></span><br><span class=\"line\">            buckets[index] = [];</span><br><span class=\"line\">            buckets[index].push(array[j]);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (n &lt; num) &#123;</span><br><span class=\"line\">        result = result.concat(buckets[n]);</span><br><span class=\"line\">        n++;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"9-计数排序\"><a href=\"#9-计数排序\" class=\"headerlink\" title=\"9.计数排序\"></a>9.计数排序</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">countingSort</span>(<span class=\"params\">array</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> len = array.length, B = [], C = [], min = max = array[<span class=\"number\">0</span>];</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; len; i++) &#123;</span><br><span class=\"line\">        min = min &lt;= array[i] ? min : array[i];</span><br><span class=\"line\">        max = max &gt;= array[i] ? max : array[i];</span><br><span class=\"line\">        C[array[i]] = C[array[i]] ? C[array[i]] + <span class=\"number\">1</span> : <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> j = min; j &lt; max; j++) &#123;</span><br><span class=\"line\">        C[j + <span class=\"number\">1</span>] = (C[j + <span class=\"number\">1</span>] || <span class=\"number\">0</span>) + (C[j] || <span class=\"number\">0</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> k = len - <span class=\"number\">1</span>; k &gt;=<span class=\"number\">0</span>; k--) &#123;</span><br><span class=\"line\">        B[C[array[k]] - <span class=\"number\">1</span>] = array[k];</span><br><span class=\"line\">        C[array[k]]--;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> B;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"<h3 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h3><p>对所有的排序算法进行综合整理</p>","more":"<h4 id=\"1-插入排序\"><a href=\"#1-插入排序\" class=\"headerlink\" title=\"1.插入排序\"></a>1.插入排序</h4><h5 id=\"原理\"><a href=\"#原理\" class=\"headerlink\" title=\"原理\"></a>原理</h5><blockquote>\n<p>它的原理是每插入一个数都要将它和之前的已经完成排序的序列进行重新排序，也就是要找到新插入的数对应原序列中的位置。那么也就是说，每次插入一个数都要对原来排序好的那部分序列进行重新的排序，时间复杂度同样为O（n²）。 这种算法是稳定的排序方法。</p>\n</blockquote>\n<h5 id=\"图解\"><a href=\"#图解\" class=\"headerlink\" title=\"图解\"></a>图解</h5><p><img src=\"http://www.leqikeji.cn/blogImg/charupaixu.gif\" alt=\"\"><br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> arr = [<span class=\"number\">23</span>,<span class=\"number\">34</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">23</span>,<span class=\"number\">44</span>,<span class=\"number\">333</span>,<span class=\"number\">444</span>];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> arrShow = (<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">insertionSort</span>(<span class=\"params\">array</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(<span class=\"built_in\">Object</span>.prototype.toString.call(array).slice(<span class=\"number\">8</span>,<span class=\"number\">-1</span>) ===<span class=\"string\">'Array'</span>)&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">1</span>; i &lt; array.length; i++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> key = array[i];</span><br><span class=\"line\">        <span class=\"keyword\">var</span> j = i - <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (j &gt;= <span class=\"number\">0</span> &amp;&amp; array[j] &gt; key) &#123;</span><br><span class=\"line\">            array[j + <span class=\"number\">1</span>] = array[j];</span><br><span class=\"line\">            j--;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        array[j + <span class=\"number\">1</span>] = key;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> array;</span><br><span class=\"line\">    &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">'array is not an Array!'</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;)(arr);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(arrShow);<span class=\"comment\">//[3, 4, 23, 23, 34, 44, 333, 444]</span></span><br></pre></td></tr></table></figure></p>\n<h4 id=\"2-二分插入排序\"><a href=\"#2-二分插入排序\" class=\"headerlink\" title=\"2.二分插入排序\"></a>2.二分插入排序</h4><h5 id=\"算法思想\"><a href=\"#算法思想\" class=\"headerlink\" title=\"算法思想\"></a>算法思想</h5><blockquote>\n<p>1.二分插入排序的基本思想和插入排序一致；都是将某个元素插入到已经有序的序列的正确的位置；</p>\n</blockquote>\n<blockquote>\n<p>2.和直接插入排序的最大区别是，元素A[i]的位置的方法不一样；直接插入排序是从A[i-1]往前一个个比较，从而找到正确的位置；而二分插入排序，利用前i-1个元素已经是有序的特点结合二分查找的特点，找到正确的位置，从而将A[i]插入，并保持新的序列依旧有序；</p>\n</blockquote>\n<blockquote>\n<p>3.时间复杂度：T(n) = O(n);<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">binaryInsertionSort</span>(<span class=\"params\">array</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"built_in\">Object</span>.prototype.toString.call(array).slice(<span class=\"number\">8</span>, <span class=\"number\">-1</span>) === <span class=\"string\">'Array'</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">1</span>; i &lt; array.length; i++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> key = array[i], left = <span class=\"number\">0</span>, right = i - <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (left &lt;= right) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">var</span> middle = <span class=\"built_in\">parseInt</span>((left + right) / <span class=\"number\">2</span>);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (key &lt; array[middle]) &#123;</span><br><span class=\"line\">                right = middle - <span class=\"number\">1</span>;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                left = middle + <span class=\"number\">1</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> j = i - <span class=\"number\">1</span>; j &gt;= left; j--) &#123;</span><br><span class=\"line\">            array[j + <span class=\"number\">1</span>] = array[j];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        array[left] = key;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> array;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">'array is not an Array!'</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n</blockquote>\n<h4 id=\"3-选择排序\"><a href=\"#3-选择排序\" class=\"headerlink\" title=\"3.选择排序\"></a>3.选择排序</h4><h5 id=\"工作原理\"><a href=\"#工作原理\" class=\"headerlink\" title=\"工作原理\"></a>工作原理</h5><blockquote>\n<p>它的工作原理是每一次从待排序的数据元素中选出最小（或最大）的一个元素，存放在序列的起始位置，直到全部待排序的数据元素排完。</p>\n</blockquote>\n<h5 id=\"图解-1\"><a href=\"#图解-1\" class=\"headerlink\" title=\"图解\"></a>图解</h5><p><img src=\"http://www.leqikeji.cn/blogImg/xuanzepaixu.jpeg\" alt=\"\"><br>选择排序就是对数组中的元素进行比较选择，然后直接放置在排序后的位置。<br>首先指针K先指向数组0号位置，K相当于指明一个目标位置。然后另一个指针min从K开始，往后一次比较，找到最小的值，并存储在min中，比较了一轮后，min中存储的数就是整个数组中最小的数字。这是直接将min中的数字和K指向的数字交换即可。然后找到数组中第二小的数，让他跟数组中第二个元素交换一下值，以此类推。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">selectionSort</span>(<span class=\"params\">array</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"built_in\">Object</span>.prototype.toString.call(array).slice(<span class=\"number\">8</span>, <span class=\"number\">-1</span>) === <span class=\"string\">'Array'</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> len = array.length, temp;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; len - <span class=\"number\">1</span>; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">var</span> min = array[i];</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> j = i + <span class=\"number\">1</span>; j &lt; len; j++) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (array[j] &lt; min) &#123;</span><br><span class=\"line\">                    temp = min;</span><br><span class=\"line\">                    min = array[j];</span><br><span class=\"line\">                    array[j] = temp;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            array[i] = min;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> array;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">'array is not an Array!'</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"4-冒泡排序\"><a href=\"#4-冒泡排序\" class=\"headerlink\" title=\"4.冒泡排序\"></a>4.冒泡排序</h4><blockquote>\n<p>原理：比较两个相邻的元素，将值大的元素交换至右端。</p>\n</blockquote>\n<blockquote>\n<p>思路：依次比较相邻的两个数，将小数放在前面，大数放在后面。即在第一趟：首先比较第1个和第2个数，将小数放前，大数放后。然后比较第2个数和第3个数，将小数放前，大数放后，如此继续，直至比较最后两个数，将小数放前，大数放后。重复第一趟步骤，直至全部排序完成。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">bubbleSort</span>(<span class=\"params\">array</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"built_in\">Object</span>.prototype.toString.call(array).slice(<span class=\"number\">8</span>, <span class=\"number\">-1</span>) === <span class=\"string\">'Array'</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> len = array.length, temp;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; len - <span class=\"number\">1</span>; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> j = len - <span class=\"number\">1</span>; j &gt;= i; j--) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (array[j] &lt; array[j - <span class=\"number\">1</span>]) &#123;</span><br><span class=\"line\">                    temp = array[j];</span><br><span class=\"line\">                    array[j] = array[j - <span class=\"number\">1</span>];</span><br><span class=\"line\">                    array[j - <span class=\"number\">1</span>] = temp;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> array;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">'array is not an Array!'</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n</blockquote>\n<h4 id=\"5-快速排序\"><a href=\"#5-快速排序\" class=\"headerlink\" title=\"5.快速排序\"></a>5.快速排序</h4><h5 id=\"基本思想\"><a href=\"#基本思想\" class=\"headerlink\" title=\"基本思想\"></a>基本思想</h5><blockquote>\n<p>基本思想是：通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列。</p>\n</blockquote>\n<h5 id=\"算法介绍\"><a href=\"#算法介绍\" class=\"headerlink\" title=\"算法介绍\"></a>算法介绍</h5><p><img src=\"https://gss1.bdstatic.com/-vo3dSag_xI4khGkpoWK1HF6hhy/baike/s%3D220/sign=2785ee7e918fa0ec7bc7630f1696594a/b7003af33a87e950707fdf2110385343fbf2b416.jpg\" alt=\"\"><br>设要排序的数组是A[0]……A[N-1]，首先任意选取一个数据（通常选用数组的第一个数）作为关键数据，然后将所有比它小的数都放到它左边，所有比它大的数都放到它右边，这个过程称为一趟快速排序。值得注意的是，快速排序不是一种稳定的排序算法，也就是说，多个相同的值的相对位置也许会在算法结束时产生变动。<br>一趟快速排序的算法是：<br>1）设置两个变量i、j，排序开始的时候：i=0，j=N-1；<br>2）以第一个数组元素作为关键数据，赋值给key，即key=A[0]；<br>3）从j开始向前搜索，即由后开始向前搜索(j–)，找到第一个小于key的值A[j]，将A[j]和A[i]的值交换；<br>4）从i开始向后搜索，即由前开始向后搜索(i++)，找到第一个大于key的A[i]，将A[i]和A[j]的值交换；<br>5）重复第3、4步，直到i=j； (3,4步中，没找到符合条件的值，即3中A[j]不小于key,4中A[i]不大于key的时候改变j、i的值，使得j=j-1，i=i+1，直至找到为止。找到符合条件的值，进行交换的时候i， j指针位置不变。另外，i==j这一过程一定正好是i+或j-完成的时候，此时令循环结束）。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//方法一</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">quickSort</span>(<span class=\"params\">array, left, right</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"built_in\">Object</span>.prototype.toString.call(array).slice(<span class=\"number\">8</span>, <span class=\"number\">-1</span>) === <span class=\"string\">'Array'</span> &amp;&amp; <span class=\"keyword\">typeof</span> left === <span class=\"string\">'number'</span> &amp;&amp; <span class=\"keyword\">typeof</span> right === <span class=\"string\">'number'</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (left &lt; right) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">var</span> x = array[right], i = left - <span class=\"number\">1</span>, temp;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> j = left; j &lt;= right; j++) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (array[j] &lt;= x) &#123;</span><br><span class=\"line\">                    i++;</span><br><span class=\"line\">                    temp = array[i];</span><br><span class=\"line\">                    array[i] = array[j];</span><br><span class=\"line\">                    array[j] = temp;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            quickSort(array, left, i - <span class=\"number\">1</span>);</span><br><span class=\"line\">            quickSort(array, i + <span class=\"number\">1</span>, right);</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">'array is not an Array or left or right is not a number!'</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> aaa = [<span class=\"number\">3</span>, <span class=\"number\">5</span>, <span class=\"number\">2</span>, <span class=\"number\">9</span>, <span class=\"number\">1</span>];</span><br><span class=\"line\">quickSort(aaa, <span class=\"number\">0</span>, aaa.length - <span class=\"number\">1</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(aaa);</span><br><span class=\"line\">    </span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"comment\">//方法二</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> quickSort = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">arr</span>) </span>&#123;</span><br><span class=\"line\">　　<span class=\"keyword\">if</span> (arr.length &lt;= <span class=\"number\">1</span>) &#123; <span class=\"keyword\">return</span> arr; &#125;</span><br><span class=\"line\">　　<span class=\"keyword\">var</span> pivotIndex = <span class=\"built_in\">Math</span>.floor(arr.length / <span class=\"number\">2</span>);</span><br><span class=\"line\">　　<span class=\"keyword\">var</span> pivot = arr.splice(pivotIndex, <span class=\"number\">1</span>)[<span class=\"number\">0</span>];</span><br><span class=\"line\">　　<span class=\"keyword\">var</span> left = [];</span><br><span class=\"line\">　　<span class=\"keyword\">var</span> right = [];</span><br><span class=\"line\">　　<span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; arr.length; i++)&#123;</span><br><span class=\"line\">　　　　<span class=\"keyword\">if</span> (arr[i] &lt; pivot) &#123;</span><br><span class=\"line\">　　　　　　left.push(arr[i]);</span><br><span class=\"line\">　　　　&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">　　　　　　right.push(arr[i]);</span><br><span class=\"line\">　　　　&#125;</span><br><span class=\"line\">　　&#125;</span><br><span class=\"line\">　　<span class=\"keyword\">return</span> quickSort(left).concat([pivot], quickSort(right));</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"6-堆排序\"><a href=\"#6-堆排序\" class=\"headerlink\" title=\"6.堆排序\"></a>6.堆排序</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*方法说明：堆排序</span></span><br><span class=\"line\"><span class=\"comment\">@param array 待排序数组*/</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">heapSort</span>(<span class=\"params\">array</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"built_in\">Object</span>.prototype.toString.call(array).slice(<span class=\"number\">8</span>, <span class=\"number\">-1</span>) === <span class=\"string\">'Array'</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">//建堆</span></span><br><span class=\"line\">        <span class=\"keyword\">var</span> heapSize = array.length, temp;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"built_in\">Math</span>.floor(heapSize / <span class=\"number\">2</span>); i &gt;= <span class=\"number\">0</span>; i--) &#123;</span><br><span class=\"line\">            heapify(array, i, heapSize);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">//堆排序</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> j = heapSize - <span class=\"number\">1</span>; j &gt;= <span class=\"number\">1</span>; j--) &#123;</span><br><span class=\"line\">            temp = array[<span class=\"number\">0</span>];</span><br><span class=\"line\">            array[<span class=\"number\">0</span>] = array[j];</span><br><span class=\"line\">            array[j] = temp;</span><br><span class=\"line\">            heapify(array, <span class=\"number\">0</span>, --heapSize);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">'array is not an Array!'</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">/*方法说明：维护堆的性质</span></span><br><span class=\"line\"><span class=\"comment\">@param arr 数组</span></span><br><span class=\"line\"><span class=\"comment\">@param x 数组下标</span></span><br><span class=\"line\"><span class=\"comment\">@param len 堆大小*/</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">heapify</span>(<span class=\"params\">arr, x, len</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"built_in\">Object</span>.prototype.toString.call(arr).slice(<span class=\"number\">8</span>, <span class=\"number\">-1</span>) === <span class=\"string\">'Array'</span> &amp;&amp; <span class=\"keyword\">typeof</span> x === <span class=\"string\">'number'</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> l = <span class=\"number\">2</span> * x, r = <span class=\"number\">2</span> * x + <span class=\"number\">1</span>, largest = x, temp;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (l &lt; len &amp;&amp; arr[l] &gt; arr[largest]) &#123;</span><br><span class=\"line\">            largest = l;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (r &lt; len &amp;&amp; arr[r] &gt; arr[largest]) &#123;</span><br><span class=\"line\">            largest = r;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (largest != x) &#123;</span><br><span class=\"line\">            temp = arr[x];</span><br><span class=\"line\">            arr[x] = arr[largest];</span><br><span class=\"line\">            arr[largest] = temp;</span><br><span class=\"line\">            heapify(arr, largest, len);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">'arr is not an Array or x is not a number!'</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"7-归并排序\"><a href=\"#7-归并排序\" class=\"headerlink\" title=\"7.归并排序\"></a>7.归并排序</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">mergeSort</span>(<span class=\"params\">array, p, r</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (p &lt; r) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> q = <span class=\"built_in\">Math</span>.floor((p + r) / <span class=\"number\">2</span>);</span><br><span class=\"line\">        mergeSort(array, p, q);</span><br><span class=\"line\">        mergeSort(array, q + <span class=\"number\">1</span>, r);</span><br><span class=\"line\">        merge(array, p, q, r);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">merge</span>(<span class=\"params\">array, p, q, r</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> n1 = q - p + <span class=\"number\">1</span>, n2 = r - q, left = [], right = [], m = n = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; n1; i++) &#123;</span><br><span class=\"line\">        left[i] = array[p + i];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> j = <span class=\"number\">0</span>; j &lt; n2; j++) &#123;</span><br><span class=\"line\">        right[j] = array[q + <span class=\"number\">1</span> + j];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    left[n1] = right[n2] = <span class=\"built_in\">Number</span>.MAX_VALUE;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> k = p; k &lt;= r; k++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (left[m] &lt;= right[n]) &#123;</span><br><span class=\"line\">            array[k] = left[m];</span><br><span class=\"line\">            m++;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            array[k] = right[n];</span><br><span class=\"line\">            n++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"8-桶排序\"><a href=\"#8-桶排序\" class=\"headerlink\" title=\"8.桶排序\"></a>8.桶排序</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*方法说明：桶排序</span></span><br><span class=\"line\"><span class=\"comment\">@param array 数组</span></span><br><span class=\"line\"><span class=\"comment\">@param num 桶的数量*/</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">bucketSort</span>(<span class=\"params\">array, num</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (array.length &lt;= <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> array;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> len = array.length, buckets = [], result = [], min = max = array[<span class=\"number\">0</span>], regex = <span class=\"string\">'/^[1-9]+[0-9]*$/'</span>, space, n = <span class=\"number\">0</span>;</span><br><span class=\"line\">    num = num || ((num &gt; <span class=\"number\">1</span> &amp;&amp; regex.test(num)) ? num : <span class=\"number\">10</span>);</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">1</span>; i &lt; len; i++) &#123;</span><br><span class=\"line\">        min = min &lt;= array[i] ? min : array[i];</span><br><span class=\"line\">        max = max &gt;= array[i] ? max : array[i];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    space = (max - min + <span class=\"number\">1</span>) / num;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> j = <span class=\"number\">0</span>; j &lt; len; j++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> index = <span class=\"built_in\">Math</span>.floor((array[j] - min) / space);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (buckets[index]) &#123; <span class=\"comment\">// 非空桶，插入排序</span></span><br><span class=\"line\">            <span class=\"keyword\">var</span> k = buckets[index].length - <span class=\"number\">1</span>;</span><br><span class=\"line\">            <span class=\"keyword\">while</span> (k &gt;= <span class=\"number\">0</span> &amp;&amp; buckets[index][k] &gt; array[j]) &#123;</span><br><span class=\"line\">                buckets[index][k + <span class=\"number\">1</span>] = buckets[index][k];</span><br><span class=\"line\">                k--;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            buckets[index][k + <span class=\"number\">1</span>] = array[j];</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123; <span class=\"comment\">//空桶，初始化</span></span><br><span class=\"line\">            buckets[index] = [];</span><br><span class=\"line\">            buckets[index].push(array[j]);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (n &lt; num) &#123;</span><br><span class=\"line\">        result = result.concat(buckets[n]);</span><br><span class=\"line\">        n++;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"9-计数排序\"><a href=\"#9-计数排序\" class=\"headerlink\" title=\"9.计数排序\"></a>9.计数排序</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">countingSort</span>(<span class=\"params\">array</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> len = array.length, B = [], C = [], min = max = array[<span class=\"number\">0</span>];</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; len; i++) &#123;</span><br><span class=\"line\">        min = min &lt;= array[i] ? min : array[i];</span><br><span class=\"line\">        max = max &gt;= array[i] ? max : array[i];</span><br><span class=\"line\">        C[array[i]] = C[array[i]] ? C[array[i]] + <span class=\"number\">1</span> : <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> j = min; j &lt; max; j++) &#123;</span><br><span class=\"line\">        C[j + <span class=\"number\">1</span>] = (C[j + <span class=\"number\">1</span>] || <span class=\"number\">0</span>) + (C[j] || <span class=\"number\">0</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> k = len - <span class=\"number\">1</span>; k &gt;=<span class=\"number\">0</span>; k--) &#123;</span><br><span class=\"line\">        B[C[array[k]] - <span class=\"number\">1</span>] = array[k];</span><br><span class=\"line\">        C[array[k]]--;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> B;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>"},{"title":"3分钟了解BFC","date":"2018-07-11T10:56:40.000Z","_content":"\n### 一、常见定位方案\n\n在讲 BFC 之前，我们先来了解一下常见的定位方案，定位方案是控制元素的布局，有三种常见方案:\n\n- 普通流 (normal flow)\n\n> 在普通流中，元素按照其在 HTML 中的先后位置至上而下布局，在这个过程中，行内元素水平排列，直到当行被占满然后换行，块级元素则会被渲染为完整的一个新行，除非另外指定，否则所有元素默认都是普通流定位，也可以说，普通流中元素的位置由该元素在 HTML 文档中的位置决定。\n\n- 浮动 (float)\n\n> 在浮动布局中，元素首先按照普通流的位置出现，然后根据浮动的方向尽可能的向左边或右边偏移，其效果与印刷排版中的文本环绕相似。\n\n- 绝对定位 (absolute positioning)\n\n> 在绝对定位布局中，元素会整体脱离普通流，因此绝对定位元素不会对其兄弟元素造成影响，而元素具体的位置由绝对定位的坐标决定。\n<!-- more -->\n### 二、BFC 概念\n\nFormatting context(格式化上下文) 是 W3C CSS2.1 规范中的一个概念。它是页面中的一块渲染区域，并且有一套渲染规则，它决定了其子元素将如何定位，以及和其他元素的关系和相互作用。\n\n\n\n那么 BFC 是什么呢？\n\nBFC 即 Block Formatting Contexts (块级格式化上下文)，它属于上述定位方案的普通流。\n\n**具有 BFC 特性的元素可以看作是隔离了的独立容器，容器里面的元素不会在布局上影响到外面的元素，并且 BFC 具有普通容器所没有的一些特性。**\n\n通俗一点来讲，可以把 BFC 理解为一个封闭的大箱子，箱子内部的元素无论如何翻江倒海，都不会影响到外部。\n\n### 三、触发 BFC\n\n只要元素满足下面任一条件即可触发 BFC 特性：\n\n- body 根元素\n- 浮动元素：float 除 none 以外的值\n- 绝对定位元素：position (absolute、fixed)\n- display 为 inline-block、table-cells、flex\n- overflow 除了 visible 以外的值 (hidden、auto、scroll)\n\n### 四、BFC 特性及应用\n\n**1. 同一个 BFC 下外边距会发生折叠**\n\n\n\n```html\n<head>\ndiv{\n    width: 100px;\n    height: 100px;\n    background: lightblue;\n    margin: 100px;\n}\n</head>\n<body>\n    <div></div>\n    <div></div>\n</body>\n```\n\n![img](https://pic4.zhimg.com/80/v2-0a9ca8952c83141250a2d9002e6d2047_hd.png)\n\n从效果上看，因为两个 div 元素都处于同一个 BFC 容器下 (这里指 body 元素) 所以第一个 div 的下边距和第二个 div 的上边距发生了重叠，所以两个盒子之间距离只有 100px，而不是 200px。\n\n首先这不是 CSS 的 bug，我们可以理解为一种规范，**如果想要避免外边距的重叠，可以将其放在不同的 BFC 容器中。**\n\n```html\n<div class=\"container\">\n    <p></p>\n</div>\n<div class=\"container\">\n    <p></p>\n</div>\n.container {\n    overflow: hidden;\n}\np {\n    width: 100px;\n    height: 100px;\n    background: lightblue;\n    margin: 100px;\n}\n```\n\n这时候，两个盒子边距就变成了 200px \n\n\n\n![img](https://pic2.zhimg.com/80/v2-5b8d6e8b2b507352900c1ece00018855_hd.png)\n\n**2. BFC 可以包含浮动的元素（清除浮动）**\n\n\n\n我们都知道，浮动的元素会脱离普通文档流，来看下下面一个例子\n\n```html\n<div style=\"border: 1px solid #000;\">\n    <div style=\"width: 100px;height: 100px;background: #eee;float: left;\"></div>\n</div>\n```\n\n\n\n![img](https://pic4.zhimg.com/80/v2-371eb702274af831df909b2c55d6a14b_hd.png)\n\n由于容器内元素浮动，脱离了文档流，所以容器只剩下 2px 的边距高度。如果使触发容器的 BFC，那么容器将会包裹着浮动元素。\n\n\n\n```html\n<div style=\"border: 1px solid #000;overflow: hidden\">\n    <div style=\"width: 100px;height: 100px;background: #eee;float: left;\"></div>\n</div>\n```\n\n效果如图：\n\n\n\n![img](https://pic4.zhimg.com/80/v2-cc8365db5c9cc5ca003ce9afe88592e7_hd.png)\n\n**3. BFC 可以阻止元素被浮动元素覆盖**\n\n\n\n先来看一个文字环绕效果：\n\n```html\n<div style=\"height: 100px;width: 100px;float: left;background: lightblue\">我是一个左浮动的元素</div>\n<div style=\"width: 200px; height: 200px;background: #eee\">我是一个没有设置浮动, \n也没有触发 BFC 元素, width: 200px; height:200px; background: #eee;</div>\n```\n\n![img](https://pic4.zhimg.com/80/v2-dd3e636d73682140bf4a781bcd6f576b_hd.png)\n\n这时候其实第二个元素有部分被浮动元素所覆盖，(但是文本信息不会被浮动元素所覆盖) 如果想避免元素被覆盖，可触第二个元素的 BFC 特性，在第二个元素中加入 **overflow: hidden**，就会变成：\n\n\n\n![img](https://pic3.zhimg.com/80/v2-5ebd48f09fac875f0bd25823c76ba7fa_hd.png)\n\n这个方法可以用来实现两列自适应布局，效果不错，这时候左边的宽度固定，右边的内容自适应宽度(去掉上面右边内容的宽度)。","source":"_posts/3分钟了解BFC.md","raw":"---\ntitle: 3分钟了解BFC\ndate: 2018-07-11 18:56:40\ntags:\n    -bfc\ncategories:\n    - 技术分享\n---\n\n### 一、常见定位方案\n\n在讲 BFC 之前，我们先来了解一下常见的定位方案，定位方案是控制元素的布局，有三种常见方案:\n\n- 普通流 (normal flow)\n\n> 在普通流中，元素按照其在 HTML 中的先后位置至上而下布局，在这个过程中，行内元素水平排列，直到当行被占满然后换行，块级元素则会被渲染为完整的一个新行，除非另外指定，否则所有元素默认都是普通流定位，也可以说，普通流中元素的位置由该元素在 HTML 文档中的位置决定。\n\n- 浮动 (float)\n\n> 在浮动布局中，元素首先按照普通流的位置出现，然后根据浮动的方向尽可能的向左边或右边偏移，其效果与印刷排版中的文本环绕相似。\n\n- 绝对定位 (absolute positioning)\n\n> 在绝对定位布局中，元素会整体脱离普通流，因此绝对定位元素不会对其兄弟元素造成影响，而元素具体的位置由绝对定位的坐标决定。\n<!-- more -->\n### 二、BFC 概念\n\nFormatting context(格式化上下文) 是 W3C CSS2.1 规范中的一个概念。它是页面中的一块渲染区域，并且有一套渲染规则，它决定了其子元素将如何定位，以及和其他元素的关系和相互作用。\n\n\n\n那么 BFC 是什么呢？\n\nBFC 即 Block Formatting Contexts (块级格式化上下文)，它属于上述定位方案的普通流。\n\n**具有 BFC 特性的元素可以看作是隔离了的独立容器，容器里面的元素不会在布局上影响到外面的元素，并且 BFC 具有普通容器所没有的一些特性。**\n\n通俗一点来讲，可以把 BFC 理解为一个封闭的大箱子，箱子内部的元素无论如何翻江倒海，都不会影响到外部。\n\n### 三、触发 BFC\n\n只要元素满足下面任一条件即可触发 BFC 特性：\n\n- body 根元素\n- 浮动元素：float 除 none 以外的值\n- 绝对定位元素：position (absolute、fixed)\n- display 为 inline-block、table-cells、flex\n- overflow 除了 visible 以外的值 (hidden、auto、scroll)\n\n### 四、BFC 特性及应用\n\n**1. 同一个 BFC 下外边距会发生折叠**\n\n\n\n```html\n<head>\ndiv{\n    width: 100px;\n    height: 100px;\n    background: lightblue;\n    margin: 100px;\n}\n</head>\n<body>\n    <div></div>\n    <div></div>\n</body>\n```\n\n![img](https://pic4.zhimg.com/80/v2-0a9ca8952c83141250a2d9002e6d2047_hd.png)\n\n从效果上看，因为两个 div 元素都处于同一个 BFC 容器下 (这里指 body 元素) 所以第一个 div 的下边距和第二个 div 的上边距发生了重叠，所以两个盒子之间距离只有 100px，而不是 200px。\n\n首先这不是 CSS 的 bug，我们可以理解为一种规范，**如果想要避免外边距的重叠，可以将其放在不同的 BFC 容器中。**\n\n```html\n<div class=\"container\">\n    <p></p>\n</div>\n<div class=\"container\">\n    <p></p>\n</div>\n.container {\n    overflow: hidden;\n}\np {\n    width: 100px;\n    height: 100px;\n    background: lightblue;\n    margin: 100px;\n}\n```\n\n这时候，两个盒子边距就变成了 200px \n\n\n\n![img](https://pic2.zhimg.com/80/v2-5b8d6e8b2b507352900c1ece00018855_hd.png)\n\n**2. BFC 可以包含浮动的元素（清除浮动）**\n\n\n\n我们都知道，浮动的元素会脱离普通文档流，来看下下面一个例子\n\n```html\n<div style=\"border: 1px solid #000;\">\n    <div style=\"width: 100px;height: 100px;background: #eee;float: left;\"></div>\n</div>\n```\n\n\n\n![img](https://pic4.zhimg.com/80/v2-371eb702274af831df909b2c55d6a14b_hd.png)\n\n由于容器内元素浮动，脱离了文档流，所以容器只剩下 2px 的边距高度。如果使触发容器的 BFC，那么容器将会包裹着浮动元素。\n\n\n\n```html\n<div style=\"border: 1px solid #000;overflow: hidden\">\n    <div style=\"width: 100px;height: 100px;background: #eee;float: left;\"></div>\n</div>\n```\n\n效果如图：\n\n\n\n![img](https://pic4.zhimg.com/80/v2-cc8365db5c9cc5ca003ce9afe88592e7_hd.png)\n\n**3. BFC 可以阻止元素被浮动元素覆盖**\n\n\n\n先来看一个文字环绕效果：\n\n```html\n<div style=\"height: 100px;width: 100px;float: left;background: lightblue\">我是一个左浮动的元素</div>\n<div style=\"width: 200px; height: 200px;background: #eee\">我是一个没有设置浮动, \n也没有触发 BFC 元素, width: 200px; height:200px; background: #eee;</div>\n```\n\n![img](https://pic4.zhimg.com/80/v2-dd3e636d73682140bf4a781bcd6f576b_hd.png)\n\n这时候其实第二个元素有部分被浮动元素所覆盖，(但是文本信息不会被浮动元素所覆盖) 如果想避免元素被覆盖，可触第二个元素的 BFC 特性，在第二个元素中加入 **overflow: hidden**，就会变成：\n\n\n\n![img](https://pic3.zhimg.com/80/v2-5ebd48f09fac875f0bd25823c76ba7fa_hd.png)\n\n这个方法可以用来实现两列自适应布局，效果不错，这时候左边的宽度固定，右边的内容自适应宽度(去掉上面右边内容的宽度)。","slug":"3分钟了解BFC","published":1,"updated":"2019-12-25T06:08:32.280Z","_id":"ck4kqm42200000w9mpunh8jr8","comments":1,"layout":"post","photos":[],"link":"","content":"<h3 id=\"一、常见定位方案\"><a href=\"#一、常见定位方案\" class=\"headerlink\" title=\"一、常见定位方案\"></a>一、常见定位方案</h3><p>在讲 BFC 之前，我们先来了解一下常见的定位方案，定位方案是控制元素的布局，有三种常见方案:</p>\n<ul>\n<li>普通流 (normal flow)</li>\n</ul>\n<blockquote>\n<p>在普通流中，元素按照其在 HTML 中的先后位置至上而下布局，在这个过程中，行内元素水平排列，直到当行被占满然后换行，块级元素则会被渲染为完整的一个新行，除非另外指定，否则所有元素默认都是普通流定位，也可以说，普通流中元素的位置由该元素在 HTML 文档中的位置决定。</p>\n</blockquote>\n<ul>\n<li>浮动 (float)</li>\n</ul>\n<blockquote>\n<p>在浮动布局中，元素首先按照普通流的位置出现，然后根据浮动的方向尽可能的向左边或右边偏移，其效果与印刷排版中的文本环绕相似。</p>\n</blockquote>\n<ul>\n<li>绝对定位 (absolute positioning)</li>\n</ul>\n<blockquote>\n<p>在绝对定位布局中，元素会整体脱离普通流，因此绝对定位元素不会对其兄弟元素造成影响，而元素具体的位置由绝对定位的坐标决定。<br><a id=\"more\"></a></p>\n</blockquote>\n<h3 id=\"二、BFC-概念\"><a href=\"#二、BFC-概念\" class=\"headerlink\" title=\"二、BFC 概念\"></a>二、BFC 概念</h3><p>Formatting context(格式化上下文) 是 W3C CSS2.1 规范中的一个概念。它是页面中的一块渲染区域，并且有一套渲染规则，它决定了其子元素将如何定位，以及和其他元素的关系和相互作用。</p>\n<p>那么 BFC 是什么呢？</p>\n<p>BFC 即 Block Formatting Contexts (块级格式化上下文)，它属于上述定位方案的普通流。</p>\n<p><strong>具有 BFC 特性的元素可以看作是隔离了的独立容器，容器里面的元素不会在布局上影响到外面的元素，并且 BFC 具有普通容器所没有的一些特性。</strong></p>\n<p>通俗一点来讲，可以把 BFC 理解为一个封闭的大箱子，箱子内部的元素无论如何翻江倒海，都不会影响到外部。</p>\n<h3 id=\"三、触发-BFC\"><a href=\"#三、触发-BFC\" class=\"headerlink\" title=\"三、触发 BFC\"></a>三、触发 BFC</h3><p>只要元素满足下面任一条件即可触发 BFC 特性：</p>\n<ul>\n<li>body 根元素</li>\n<li>浮动元素：float 除 none 以外的值</li>\n<li>绝对定位元素：position (absolute、fixed)</li>\n<li>display 为 inline-block、table-cells、flex</li>\n<li>overflow 除了 visible 以外的值 (hidden、auto、scroll)</li>\n</ul>\n<h3 id=\"四、BFC-特性及应用\"><a href=\"#四、BFC-特性及应用\" class=\"headerlink\" title=\"四、BFC 特性及应用\"></a>四、BFC 特性及应用</h3><p><strong>1. 同一个 BFC 下外边距会发生折叠</strong></p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\">div&#123;</span><br><span class=\"line\">    width: 100px;</span><br><span class=\"line\">    height: 100px;</span><br><span class=\"line\">    background: lightblue;</span><br><span class=\"line\">    margin: 100px;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p><img src=\"https://pic4.zhimg.com/80/v2-0a9ca8952c83141250a2d9002e6d2047_hd.png\" alt=\"img\"></p>\n<p>从效果上看，因为两个 div 元素都处于同一个 BFC 容器下 (这里指 body 元素) 所以第一个 div 的下边距和第二个 div 的上边距发生了重叠，所以两个盒子之间距离只有 100px，而不是 200px。</p>\n<p>首先这不是 CSS 的 bug，我们可以理解为一种规范，<strong>如果想要避免外边距的重叠，可以将其放在不同的 BFC 容器中。</strong></p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"container\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"container\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">.container &#123;</span><br><span class=\"line\">    overflow: hidden;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">p &#123;</span><br><span class=\"line\">    width: 100px;</span><br><span class=\"line\">    height: 100px;</span><br><span class=\"line\">    background: lightblue;</span><br><span class=\"line\">    margin: 100px;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这时候，两个盒子边距就变成了 200px </p>\n<p><img src=\"https://pic2.zhimg.com/80/v2-5b8d6e8b2b507352900c1ece00018855_hd.png\" alt=\"img\"></p>\n<p><strong>2. BFC 可以包含浮动的元素（清除浮动）</strong></p>\n<p>我们都知道，浮动的元素会脱离普通文档流，来看下下面一个例子</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">style</span>=<span class=\"string\">\"border: 1px solid #000;\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">style</span>=<span class=\"string\">\"width: 100px;height: 100px;background: #eee;float: left;\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p><img src=\"https://pic4.zhimg.com/80/v2-371eb702274af831df909b2c55d6a14b_hd.png\" alt=\"img\"></p>\n<p>由于容器内元素浮动，脱离了文档流，所以容器只剩下 2px 的边距高度。如果使触发容器的 BFC，那么容器将会包裹着浮动元素。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">style</span>=<span class=\"string\">\"border: 1px solid #000;overflow: hidden\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">style</span>=<span class=\"string\">\"width: 100px;height: 100px;background: #eee;float: left;\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>效果如图：</p>\n<p><img src=\"https://pic4.zhimg.com/80/v2-cc8365db5c9cc5ca003ce9afe88592e7_hd.png\" alt=\"img\"></p>\n<p><strong>3. BFC 可以阻止元素被浮动元素覆盖</strong></p>\n<p>先来看一个文字环绕效果：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">style</span>=<span class=\"string\">\"height: 100px;width: 100px;float: left;background: lightblue\"</span>&gt;</span>我是一个左浮动的元素<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">style</span>=<span class=\"string\">\"width: 200px; height: 200px;background: #eee\"</span>&gt;</span>我是一个没有设置浮动, </span><br><span class=\"line\">也没有触发 BFC 元素, width: 200px; height:200px; background: #eee;<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p><img src=\"https://pic4.zhimg.com/80/v2-dd3e636d73682140bf4a781bcd6f576b_hd.png\" alt=\"img\"></p>\n<p>这时候其实第二个元素有部分被浮动元素所覆盖，(但是文本信息不会被浮动元素所覆盖) 如果想避免元素被覆盖，可触第二个元素的 BFC 特性，在第二个元素中加入 <strong>overflow: hidden</strong>，就会变成：</p>\n<p><img src=\"https://pic3.zhimg.com/80/v2-5ebd48f09fac875f0bd25823c76ba7fa_hd.png\" alt=\"img\"></p>\n<p>这个方法可以用来实现两列自适应布局，效果不错，这时候左边的宽度固定，右边的内容自适应宽度(去掉上面右边内容的宽度)。</p>\n","site":{"data":{}},"excerpt":"<h3 id=\"一、常见定位方案\"><a href=\"#一、常见定位方案\" class=\"headerlink\" title=\"一、常见定位方案\"></a>一、常见定位方案</h3><p>在讲 BFC 之前，我们先来了解一下常见的定位方案，定位方案是控制元素的布局，有三种常见方案:</p>\n<ul>\n<li>普通流 (normal flow)</li>\n</ul>\n<blockquote>\n<p>在普通流中，元素按照其在 HTML 中的先后位置至上而下布局，在这个过程中，行内元素水平排列，直到当行被占满然后换行，块级元素则会被渲染为完整的一个新行，除非另外指定，否则所有元素默认都是普通流定位，也可以说，普通流中元素的位置由该元素在 HTML 文档中的位置决定。</p>\n</blockquote>\n<ul>\n<li>浮动 (float)</li>\n</ul>\n<blockquote>\n<p>在浮动布局中，元素首先按照普通流的位置出现，然后根据浮动的方向尽可能的向左边或右边偏移，其效果与印刷排版中的文本环绕相似。</p>\n</blockquote>\n<ul>\n<li>绝对定位 (absolute positioning)</li>\n</ul>\n<blockquote>\n<p>在绝对定位布局中，元素会整体脱离普通流，因此绝对定位元素不会对其兄弟元素造成影响，而元素具体的位置由绝对定位的坐标决定。<br>","more":"</p>\n</blockquote>\n<h3 id=\"二、BFC-概念\"><a href=\"#二、BFC-概念\" class=\"headerlink\" title=\"二、BFC 概念\"></a>二、BFC 概念</h3><p>Formatting context(格式化上下文) 是 W3C CSS2.1 规范中的一个概念。它是页面中的一块渲染区域，并且有一套渲染规则，它决定了其子元素将如何定位，以及和其他元素的关系和相互作用。</p>\n<p>那么 BFC 是什么呢？</p>\n<p>BFC 即 Block Formatting Contexts (块级格式化上下文)，它属于上述定位方案的普通流。</p>\n<p><strong>具有 BFC 特性的元素可以看作是隔离了的独立容器，容器里面的元素不会在布局上影响到外面的元素，并且 BFC 具有普通容器所没有的一些特性。</strong></p>\n<p>通俗一点来讲，可以把 BFC 理解为一个封闭的大箱子，箱子内部的元素无论如何翻江倒海，都不会影响到外部。</p>\n<h3 id=\"三、触发-BFC\"><a href=\"#三、触发-BFC\" class=\"headerlink\" title=\"三、触发 BFC\"></a>三、触发 BFC</h3><p>只要元素满足下面任一条件即可触发 BFC 特性：</p>\n<ul>\n<li>body 根元素</li>\n<li>浮动元素：float 除 none 以外的值</li>\n<li>绝对定位元素：position (absolute、fixed)</li>\n<li>display 为 inline-block、table-cells、flex</li>\n<li>overflow 除了 visible 以外的值 (hidden、auto、scroll)</li>\n</ul>\n<h3 id=\"四、BFC-特性及应用\"><a href=\"#四、BFC-特性及应用\" class=\"headerlink\" title=\"四、BFC 特性及应用\"></a>四、BFC 特性及应用</h3><p><strong>1. 同一个 BFC 下外边距会发生折叠</strong></p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\">div&#123;</span><br><span class=\"line\">    width: 100px;</span><br><span class=\"line\">    height: 100px;</span><br><span class=\"line\">    background: lightblue;</span><br><span class=\"line\">    margin: 100px;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p><img src=\"https://pic4.zhimg.com/80/v2-0a9ca8952c83141250a2d9002e6d2047_hd.png\" alt=\"img\"></p>\n<p>从效果上看，因为两个 div 元素都处于同一个 BFC 容器下 (这里指 body 元素) 所以第一个 div 的下边距和第二个 div 的上边距发生了重叠，所以两个盒子之间距离只有 100px，而不是 200px。</p>\n<p>首先这不是 CSS 的 bug，我们可以理解为一种规范，<strong>如果想要避免外边距的重叠，可以将其放在不同的 BFC 容器中。</strong></p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"container\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"container\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">.container &#123;</span><br><span class=\"line\">    overflow: hidden;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">p &#123;</span><br><span class=\"line\">    width: 100px;</span><br><span class=\"line\">    height: 100px;</span><br><span class=\"line\">    background: lightblue;</span><br><span class=\"line\">    margin: 100px;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这时候，两个盒子边距就变成了 200px </p>\n<p><img src=\"https://pic2.zhimg.com/80/v2-5b8d6e8b2b507352900c1ece00018855_hd.png\" alt=\"img\"></p>\n<p><strong>2. BFC 可以包含浮动的元素（清除浮动）</strong></p>\n<p>我们都知道，浮动的元素会脱离普通文档流，来看下下面一个例子</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">style</span>=<span class=\"string\">\"border: 1px solid #000;\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">style</span>=<span class=\"string\">\"width: 100px;height: 100px;background: #eee;float: left;\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p><img src=\"https://pic4.zhimg.com/80/v2-371eb702274af831df909b2c55d6a14b_hd.png\" alt=\"img\"></p>\n<p>由于容器内元素浮动，脱离了文档流，所以容器只剩下 2px 的边距高度。如果使触发容器的 BFC，那么容器将会包裹着浮动元素。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">style</span>=<span class=\"string\">\"border: 1px solid #000;overflow: hidden\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">style</span>=<span class=\"string\">\"width: 100px;height: 100px;background: #eee;float: left;\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>效果如图：</p>\n<p><img src=\"https://pic4.zhimg.com/80/v2-cc8365db5c9cc5ca003ce9afe88592e7_hd.png\" alt=\"img\"></p>\n<p><strong>3. BFC 可以阻止元素被浮动元素覆盖</strong></p>\n<p>先来看一个文字环绕效果：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">style</span>=<span class=\"string\">\"height: 100px;width: 100px;float: left;background: lightblue\"</span>&gt;</span>我是一个左浮动的元素<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">style</span>=<span class=\"string\">\"width: 200px; height: 200px;background: #eee\"</span>&gt;</span>我是一个没有设置浮动, </span><br><span class=\"line\">也没有触发 BFC 元素, width: 200px; height:200px; background: #eee;<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p><img src=\"https://pic4.zhimg.com/80/v2-dd3e636d73682140bf4a781bcd6f576b_hd.png\" alt=\"img\"></p>\n<p>这时候其实第二个元素有部分被浮动元素所覆盖，(但是文本信息不会被浮动元素所覆盖) 如果想避免元素被覆盖，可触第二个元素的 BFC 特性，在第二个元素中加入 <strong>overflow: hidden</strong>，就会变成：</p>\n<p><img src=\"https://pic3.zhimg.com/80/v2-5ebd48f09fac875f0bd25823c76ba7fa_hd.png\" alt=\"img\"></p>\n<p>这个方法可以用来实现两列自适应布局，效果不错，这时候左边的宽度固定，右边的内容自适应宽度(去掉上面右边内容的宽度)。</p>"},{"title":"Hook概要","date":"2019-06-10T06:50:40.000Z","_content":"\n### 什么是hook\n\n首先我们需要了解什么是hook，拿react的介绍来看，它的定义是：\n\n> 它可以让你在不编写 class 的情况下使用 state 以及其他的 React 特性\n\n在16.8以前的版本中，我们在写react组件的时候，大部分都都是class component，因为基于class的组件react提供了更多的可操作性，比如拥有自己的state，以及一些生命周期的实现，对于复杂的逻辑来讲class的支持程度是更高的：\n<!-- more -->\n```javascript\nclass Hello extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = {date: new Date()};\n  }\n\n  componentDidMount() { // do sth... }\n\n  componentWillUnmount() { // do sth... }\n  \n  // other methods or lifecycle...\n  \n  render() {\n    return (\n      <div>\n        <h1>Hello, world!</h1>\n        <h2>It is {this.state.date.toLocaleTimeString()}.</h2>\n      </div>\n    );\n  }\n}\n```\n\n同时，对于function component来说，react也是支持的，但是function component只能拥有props，不能拥有state，也就是只能实现stateless component：\n\n```javascript\nfunction Welcome(props) {\n  return <h1>Hello, {props.name}</h1>;\n}\n```\n\nreact 并没有提供在函数组件中设置state以及生命周期的一些操作方法，所以那个时候，极少的场景下适合采用函数组件，但是16.8版本出现hook以后情况得到了改变，hook的目标就是--**让你在不编写 class 的情况下使用 state 以及其他的 React 特性**，来看个例子：\n\n```javascript\nimport React, { useState } from 'react';\n\nfunction Example() {\n  // 声明一个新的叫做 “count” 的 state 变量\n  const [count, setCount] = useState(0);\n\n  return (\n    <div>\n      <p>You clicked {count} times</p>\n      <button onClick={() => setCount(count + 1)}>\n        Click me\n      </button>\n    </div>\n  );\n}\n```\n\nuseState就是react提供的一个Hook，通过它我们就可以在function组件中设置自己想要的state了，不仅可以使用还可以很方便的去通过setState(注意不是class中的setState，这里指的是上述例子中的setCount)更改，当然，react提供了很多hook来支持不同的行为和操作，下面我们还会再简单介绍，我们在看下vue hook，这是尤大在vueconf上分享的一段代码：\n\n```javascript\nimport { value, computed, watch, onMounted } from 'vue'\n\nconst App = {\n  template: `\n    <div>\n      <span>count is {{ count }}</span>\n      <span>plusOne is {{ plusOne }}</span>\n      <button @click=\"increment\">count++</button>\n    </div>\n  `,\n  setup() {\n    // reactive state\n    const count = value(0)\n    // computed state\n    const plusOne = computed(() => count.value + 1)\n    // method\n    const increment = () => { count.value++ }\n    // watch\n    watch(() => count.value * 2, val => {\n      console.log(`count * 2 is ${val}`)\n    })\n    // lifecycle\n    onMounted(() => {\n      console.log(`mounted`)\n    })\n    // expose bindings on render context\n    return {\n      count,\n      plusOne,\n      increment\n    }\n  }\n}\n```\n\n从上面的例子中不难看出，和react hook的用法非常相似，并且尤大也有说这个RFC是借鉴了react hook的想法，但是规避了一些react的问题，然后这里解释一下为什么我把vue的这个RFC也称为是hook，因为在react hook的介绍中有这么一句话，什么是hook--Hook 是一些可以让你在函数组件里“钩入” React state 及生命周期等特性的函数，那么vue提供的这些API的作用也是类似的--可以让你在函数组件里“钩入” value(2.x中的data) 及生命周期等特性的函数，所以，暂且就叫vue-hook吧~\n\n### hook的时代意义\n\n那么，hook的时代意义是什么？我们从头来说，框架是服务于业务的，业务中很难避免的一个问题就是-- 逻辑复用，同样的功能，同样的组件，在不一样的场合下，我们有时候不得不去写2+次，为了避免耦合，后来各大框架纷纷想出了一些办法：\n\n- mixin\n- HOC\n- slot\n\n各大框架的使用情况：\n\n- react 和 vue都曾用过mixin(react 目前已经废弃),\n- Higher-Order-Components(HOC) react中用的相对多一点，vue的话，嵌套template有点。。别扭,\n- slot vue中用的多一些，react基本不需要slot这种用法,\n\n上述这些方法都可以实现逻辑上的复用，但是都有一些额外的问题:\n\n- mixin的问题：\n  - 可能会相互依赖，相互耦合，不利于代码维护；\n  - 不同的mixin中的方法可能会相互冲突;\n  - mixin非常多时，组件是可以感知到的，甚至还要为其做相关处理， 这样会给代码造成滚雪球式的复杂性\n- HOC的问题：\n  - 需要在原组件上进行包裹或者嵌套，如果大量使用HOC， 将会产生非常多的嵌套，这让调试变得非常困难；\n  - HOC可以劫持props，在不遵守约定的情况下也可能造成冲突\n  - props 也可能造成命名的冲突\n  - wrapper hell\n\n**有没有见过这样的dom结构？**\n\n![img](http://pic3.58cdn.com.cn/ecomfe/n_v2b7e58d1117054b4280b705d5952805f0.png)\n\n这就是wrapper hell的典型代表~\n\n所以，hook的出现是划时代的，它通过function抽离的方式，实现了复杂逻辑的内部封装，根据上述我们提出的问题总结了hook的一些优点：\n\n1. 逻辑代码的复用\n2. 减小了代码体积\n3. 没有this的烦恼\n\n带着这些思想，我们一起看下react和vue分别的实现：\n\n### react hook简介\n\n> Dan 讲解hook的视频在[这里](https://link.juejin.im?target=https%3A%2F%2Fwww.youtube.com%2Fwatch%3Fv%3Ddpw9EHDh2bM%26feature%3Dyoutu.be)，如果你看不了这个，可以尝试看[官网介绍](https://link.juejin.im?target=https%3A%2F%2Freact.docschina.org%2Fdocs%2Fhooks-intro.html)\n\n我们用同样功能的代码来看react hook，实现一个监听鼠标变化，并实时查看位置的功能，同时我们把位置信息挂到title上面，用class component我们要这样写：\n\n```javascript\nimport React, { Component } from 'react';\n\nexport default class MyClassApp extends Component {\n    constructor(props) {\n        super(props);\n        this.state = {\n            x: 0,\n            y: 0\n        };\n        this.handleUpdate = this.handleUpdate.bind(this);\n    }\n    componentDidMount() {\n        document.addEventListener('mousemove', this.handleUpdate);\n    }\n    componentDidUpdate() {\n        const { x, y } = this.state;\n        document.title = `(${x},${y})`;\n    }\n    componentWillUnmount() {\n        window.removeEventListener('mousemove', this.handleUpdate);\n    }\n    handleUpdate(e) {\n        this.setState({\n            x: e.clientX,\n            y: e.clientY\n        });\n    }\n    render() {\n        return (\n            <div>\n                current position x:{this.state.x}, y:{this.state.y}\n            </div>\n        );\n    }\n}\n```\n\n在线代码演示在[这里](https://link.juejin.im?target=https%3A%2F%2Fcodesandbox.io%2Fs%2Fxenodochial-butterfly-gzflh)\n\n同样的逻辑我们换用hook来实现\n\n```javascript\nimport React, { useState, useEffect } from 'react';\n\n// 自定义hook useMousePostion\nconst useMousePostion = () => {\n    // 使用hookuseState初始化一个state\n    const [postion, setPostion] = useState({ x: 0, y: 0 });\n    function handleMove(e) {\n        setPostion({ x: e.clientX, y: e.clientY });\n    }\n    // 使用useEffect处理class中生命周期可以做到的事情\n    // 注：效果一样，但是实际的原理并不同，有兴趣可以去官网仔细研究\n    useEffect(() => {\n        // 同时可以处理 componentDidMount 以及 componentDidUpdate 中的事情\n        window.addEventListener('mousemove', handleMove);\n        document.title = `(${postion.x},${postion.y})`;\n        return () => {\n            // return的function 可以相当于在组件被卸载的时候执行 类似于 componentWillUnmount\n            window.removeEventListener('mousemove', handleMove);\n        };\n        // [] 是参数，代表deps，也就是说react触发这个hook的时机会和传入的deps有关，内部利用objectIs实现\n        // 默认不给参数会在每次render的时候调用，给空数组会导致每次比较是一样的，只执行一次，这里正确的应该是给postion\n    }, [postion]);\n    // postion 可以被直接return，这样达到了逻辑的复用~，哪里需要哪里调用就可以了。\n    return postion;\n};\n\nexport default function App() {\n    const { x, y } = useMousePostion(); // 内部维护自己的postion相关的逻辑\n    return (\n        <div>\n            current position x: {x}, y: {y}\n        </div>\n    );\n}\n```\n\n在线代码演示在[这里](https://link.juejin.im?target=https%3A%2F%2Fcodesandbox.io%2Fs%2Fhookdemo-8zxh2)\n\n可以看出用了hook之后，我们把关于position的逻辑都放到一个自定义的hook--useMousePostion 中，之后复用是很方便的，而且可以在内部进行维护postion独有的逻辑而不影响外部内容，比起class组件，抽象能力更强。\n\n下面给大家安利几个不错的资源：\n\n入门：\n\n- [官网传送门](https://link.juejin.im?target=https%3A%2F%2Freact.docschina.org%2Fdocs%2Fhooks-overview.html)\n\n深入：\n\n- [Dan自己写的关于hook的文章，写的很好强烈安利，深入内部实现](https://link.juejin.im?target=https%3A%2F%2Foverreacted.io%2Fzh-hans%2Fa-complete-guide-to-useeffect%2F%23tldr)\n\n### vue hook简介\n\n> 尤大讲解的视频在[这里](https://link.juejin.im?target=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2FhBqu1A3gIwMVglb-ZWp8oA)\n\n代码因为vue3.0尚未发布，我们还是看尤大给的demo代码：\n\n```javascript\nimport { value, computed, watch, onMounted } from 'vue'\n\nfunction useMouse() {\n  const x = value(0)\n  const y = value(0)\n  const update = e => {\n    x.value = e.pageX\n    y.value = e.pageY\n  }\n  onMounted(() => {\n    window.addEventListener('mousemove', update)\n  })\n  onUnmounted(() => {\n    window.removeEventListener('mousemove', update)\n  })\n  return { x, y }\n}\n\n// 在组件中使用该函数\nconst Component = {\n  setup() {\n    const { x, y } = useMouse()\n    // 与其它函数配合使用\n    const { z } = useOtherLogic()\n    return { x, y, z }\n  },\n  template: `<div>{{ x }} {{ y }} {{ z }}</div>`\n}\n```\n\n可以看出来同样我们可以抽离一些需要复用的逻辑到一个单独的函数useMouse中，然后在这个函数里面定义的一些生命周期和value的内容会随着setup函数的调用被“钩入(hook)”到组件上，并且这个函数return出来的数据可以直接被用在模板上，更具体的玩法我们坐等3.0的出现吧。\n\n基础内容不过多介绍，毕竟真实的api还没发布，想了解具体内容的可以来看尤大的[讲解](https://link.juejin.im?target=https%3A%2F%2Fzhuanlan.zhihu.com%2Fp%2F68477600)\n\n### same & diff Point\n\n看完了2个框架关于hook的实现，我们来做个简单的对比\n\n1. Same Point:\n\n- 出现的背景，解决的问题是一样的，2个框架都是为了解决逻辑复用过乱，代码体积过大等一些问题，包括this问题，使用function函数我们很少会和this去打交道了。\n- 使用方式类似，都是把可以复用的一些单独的逻辑抽离到一个单独的函数中去，同时返回组件中需要用到的数据，并且内部会自我维护数据的更新，从而触发视图的更新\n\n1. Diff Point:\n\n**实现原理不同** react hook底层是基于链表实现，调用的条件是每次组件被render的时候都会顺序执行所有的hooks，所以下面的代码会报错\n\n```javascript\nfunction App(){\n    const [name, setName] = useState('demo');\n    if(condition){\n        const [val, setVal] = useState('');\n    }\n}\n```\n\n因为底层是链表，每一个hook的next是指向下一个hook的，if会导致顺序不正确，从而导致报错，所以react是不允许这样使用hook的。\n\nvue hook只会在setup函数被调用的时候被注册一次，react数据更改的时候，会导致重新render，重新render又会重新把hooks重新注册一次，所以react的上手难度更高一些，而vue之所以能避开这些麻烦的问题，根本原因在于它对数据的响应是基于proxy的，这种场景下，只要任何一个更改data的地方，相关的function或者template都会被重新计算，因此避开了react可能遇到的性能上的问题\n\n当然react对这些都有解决方案，想了解的同学可以去看官网有介绍，比如useCallback，useMemo等hook的作用，我们看下尤大对vue和react hook的总结对比：\n\n> 1.整体上更符合 JavaScript 的直觉；\n\n> 2.不受调用顺序的限制，可以有条件地被调用；\n\n> 3.不会在后续更新时不断产生大量的内联函数而影响引擎优化或是导致 GC 压力；\n\n> 4.不需要总是使用 useCallback 来缓存传给子组件的回调以防止过度更新；\n\n> 5.不需要担心传了错误的依赖数组给 useEffect/useMemo/useCallback 从而导致回调中使用了过期的值 —— Vue 的依赖追踪是全自动的。\n\n不得不说，青出于蓝而胜于蓝，vue虽然借鉴了react，但是天然的响应式数据，完美的避开了一些react hook遇到的短板~\n\n### 总结\n\n1. function component 将会是接下来各大框架发展的一个方向，function天然对TS的友好也是一个重要的影响;\n2. react hook的上手成本相对于vue会难一些，vue天生规避了一些react中比较难处理的地方;\n3. hook一定是大前端的一个趋势，现在才是刚刚开始的阶段：[SwiftUI-Hooks](https://link.juejin.im?target=https%3A%2F%2Fgithub.com%2Funixzii%2FSwiftUI-Hooks), [flutter_hooks](https://link.juejin.im?target=https%3A%2F%2Fgithub.com%2FrrousselGit%2Fflutter_hooks)...","source":"_posts/Hook.md","raw":"---\ntitle: Hook概要\ndate: 2019-06-10 14:50:40\ntags:\n    - hook\ncategories:\n    - 技术分享\n---\n\n### 什么是hook\n\n首先我们需要了解什么是hook，拿react的介绍来看，它的定义是：\n\n> 它可以让你在不编写 class 的情况下使用 state 以及其他的 React 特性\n\n在16.8以前的版本中，我们在写react组件的时候，大部分都都是class component，因为基于class的组件react提供了更多的可操作性，比如拥有自己的state，以及一些生命周期的实现，对于复杂的逻辑来讲class的支持程度是更高的：\n<!-- more -->\n```javascript\nclass Hello extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = {date: new Date()};\n  }\n\n  componentDidMount() { // do sth... }\n\n  componentWillUnmount() { // do sth... }\n  \n  // other methods or lifecycle...\n  \n  render() {\n    return (\n      <div>\n        <h1>Hello, world!</h1>\n        <h2>It is {this.state.date.toLocaleTimeString()}.</h2>\n      </div>\n    );\n  }\n}\n```\n\n同时，对于function component来说，react也是支持的，但是function component只能拥有props，不能拥有state，也就是只能实现stateless component：\n\n```javascript\nfunction Welcome(props) {\n  return <h1>Hello, {props.name}</h1>;\n}\n```\n\nreact 并没有提供在函数组件中设置state以及生命周期的一些操作方法，所以那个时候，极少的场景下适合采用函数组件，但是16.8版本出现hook以后情况得到了改变，hook的目标就是--**让你在不编写 class 的情况下使用 state 以及其他的 React 特性**，来看个例子：\n\n```javascript\nimport React, { useState } from 'react';\n\nfunction Example() {\n  // 声明一个新的叫做 “count” 的 state 变量\n  const [count, setCount] = useState(0);\n\n  return (\n    <div>\n      <p>You clicked {count} times</p>\n      <button onClick={() => setCount(count + 1)}>\n        Click me\n      </button>\n    </div>\n  );\n}\n```\n\nuseState就是react提供的一个Hook，通过它我们就可以在function组件中设置自己想要的state了，不仅可以使用还可以很方便的去通过setState(注意不是class中的setState，这里指的是上述例子中的setCount)更改，当然，react提供了很多hook来支持不同的行为和操作，下面我们还会再简单介绍，我们在看下vue hook，这是尤大在vueconf上分享的一段代码：\n\n```javascript\nimport { value, computed, watch, onMounted } from 'vue'\n\nconst App = {\n  template: `\n    <div>\n      <span>count is {{ count }}</span>\n      <span>plusOne is {{ plusOne }}</span>\n      <button @click=\"increment\">count++</button>\n    </div>\n  `,\n  setup() {\n    // reactive state\n    const count = value(0)\n    // computed state\n    const plusOne = computed(() => count.value + 1)\n    // method\n    const increment = () => { count.value++ }\n    // watch\n    watch(() => count.value * 2, val => {\n      console.log(`count * 2 is ${val}`)\n    })\n    // lifecycle\n    onMounted(() => {\n      console.log(`mounted`)\n    })\n    // expose bindings on render context\n    return {\n      count,\n      plusOne,\n      increment\n    }\n  }\n}\n```\n\n从上面的例子中不难看出，和react hook的用法非常相似，并且尤大也有说这个RFC是借鉴了react hook的想法，但是规避了一些react的问题，然后这里解释一下为什么我把vue的这个RFC也称为是hook，因为在react hook的介绍中有这么一句话，什么是hook--Hook 是一些可以让你在函数组件里“钩入” React state 及生命周期等特性的函数，那么vue提供的这些API的作用也是类似的--可以让你在函数组件里“钩入” value(2.x中的data) 及生命周期等特性的函数，所以，暂且就叫vue-hook吧~\n\n### hook的时代意义\n\n那么，hook的时代意义是什么？我们从头来说，框架是服务于业务的，业务中很难避免的一个问题就是-- 逻辑复用，同样的功能，同样的组件，在不一样的场合下，我们有时候不得不去写2+次，为了避免耦合，后来各大框架纷纷想出了一些办法：\n\n- mixin\n- HOC\n- slot\n\n各大框架的使用情况：\n\n- react 和 vue都曾用过mixin(react 目前已经废弃),\n- Higher-Order-Components(HOC) react中用的相对多一点，vue的话，嵌套template有点。。别扭,\n- slot vue中用的多一些，react基本不需要slot这种用法,\n\n上述这些方法都可以实现逻辑上的复用，但是都有一些额外的问题:\n\n- mixin的问题：\n  - 可能会相互依赖，相互耦合，不利于代码维护；\n  - 不同的mixin中的方法可能会相互冲突;\n  - mixin非常多时，组件是可以感知到的，甚至还要为其做相关处理， 这样会给代码造成滚雪球式的复杂性\n- HOC的问题：\n  - 需要在原组件上进行包裹或者嵌套，如果大量使用HOC， 将会产生非常多的嵌套，这让调试变得非常困难；\n  - HOC可以劫持props，在不遵守约定的情况下也可能造成冲突\n  - props 也可能造成命名的冲突\n  - wrapper hell\n\n**有没有见过这样的dom结构？**\n\n![img](http://pic3.58cdn.com.cn/ecomfe/n_v2b7e58d1117054b4280b705d5952805f0.png)\n\n这就是wrapper hell的典型代表~\n\n所以，hook的出现是划时代的，它通过function抽离的方式，实现了复杂逻辑的内部封装，根据上述我们提出的问题总结了hook的一些优点：\n\n1. 逻辑代码的复用\n2. 减小了代码体积\n3. 没有this的烦恼\n\n带着这些思想，我们一起看下react和vue分别的实现：\n\n### react hook简介\n\n> Dan 讲解hook的视频在[这里](https://link.juejin.im?target=https%3A%2F%2Fwww.youtube.com%2Fwatch%3Fv%3Ddpw9EHDh2bM%26feature%3Dyoutu.be)，如果你看不了这个，可以尝试看[官网介绍](https://link.juejin.im?target=https%3A%2F%2Freact.docschina.org%2Fdocs%2Fhooks-intro.html)\n\n我们用同样功能的代码来看react hook，实现一个监听鼠标变化，并实时查看位置的功能，同时我们把位置信息挂到title上面，用class component我们要这样写：\n\n```javascript\nimport React, { Component } from 'react';\n\nexport default class MyClassApp extends Component {\n    constructor(props) {\n        super(props);\n        this.state = {\n            x: 0,\n            y: 0\n        };\n        this.handleUpdate = this.handleUpdate.bind(this);\n    }\n    componentDidMount() {\n        document.addEventListener('mousemove', this.handleUpdate);\n    }\n    componentDidUpdate() {\n        const { x, y } = this.state;\n        document.title = `(${x},${y})`;\n    }\n    componentWillUnmount() {\n        window.removeEventListener('mousemove', this.handleUpdate);\n    }\n    handleUpdate(e) {\n        this.setState({\n            x: e.clientX,\n            y: e.clientY\n        });\n    }\n    render() {\n        return (\n            <div>\n                current position x:{this.state.x}, y:{this.state.y}\n            </div>\n        );\n    }\n}\n```\n\n在线代码演示在[这里](https://link.juejin.im?target=https%3A%2F%2Fcodesandbox.io%2Fs%2Fxenodochial-butterfly-gzflh)\n\n同样的逻辑我们换用hook来实现\n\n```javascript\nimport React, { useState, useEffect } from 'react';\n\n// 自定义hook useMousePostion\nconst useMousePostion = () => {\n    // 使用hookuseState初始化一个state\n    const [postion, setPostion] = useState({ x: 0, y: 0 });\n    function handleMove(e) {\n        setPostion({ x: e.clientX, y: e.clientY });\n    }\n    // 使用useEffect处理class中生命周期可以做到的事情\n    // 注：效果一样，但是实际的原理并不同，有兴趣可以去官网仔细研究\n    useEffect(() => {\n        // 同时可以处理 componentDidMount 以及 componentDidUpdate 中的事情\n        window.addEventListener('mousemove', handleMove);\n        document.title = `(${postion.x},${postion.y})`;\n        return () => {\n            // return的function 可以相当于在组件被卸载的时候执行 类似于 componentWillUnmount\n            window.removeEventListener('mousemove', handleMove);\n        };\n        // [] 是参数，代表deps，也就是说react触发这个hook的时机会和传入的deps有关，内部利用objectIs实现\n        // 默认不给参数会在每次render的时候调用，给空数组会导致每次比较是一样的，只执行一次，这里正确的应该是给postion\n    }, [postion]);\n    // postion 可以被直接return，这样达到了逻辑的复用~，哪里需要哪里调用就可以了。\n    return postion;\n};\n\nexport default function App() {\n    const { x, y } = useMousePostion(); // 内部维护自己的postion相关的逻辑\n    return (\n        <div>\n            current position x: {x}, y: {y}\n        </div>\n    );\n}\n```\n\n在线代码演示在[这里](https://link.juejin.im?target=https%3A%2F%2Fcodesandbox.io%2Fs%2Fhookdemo-8zxh2)\n\n可以看出用了hook之后，我们把关于position的逻辑都放到一个自定义的hook--useMousePostion 中，之后复用是很方便的，而且可以在内部进行维护postion独有的逻辑而不影响外部内容，比起class组件，抽象能力更强。\n\n下面给大家安利几个不错的资源：\n\n入门：\n\n- [官网传送门](https://link.juejin.im?target=https%3A%2F%2Freact.docschina.org%2Fdocs%2Fhooks-overview.html)\n\n深入：\n\n- [Dan自己写的关于hook的文章，写的很好强烈安利，深入内部实现](https://link.juejin.im?target=https%3A%2F%2Foverreacted.io%2Fzh-hans%2Fa-complete-guide-to-useeffect%2F%23tldr)\n\n### vue hook简介\n\n> 尤大讲解的视频在[这里](https://link.juejin.im?target=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2FhBqu1A3gIwMVglb-ZWp8oA)\n\n代码因为vue3.0尚未发布，我们还是看尤大给的demo代码：\n\n```javascript\nimport { value, computed, watch, onMounted } from 'vue'\n\nfunction useMouse() {\n  const x = value(0)\n  const y = value(0)\n  const update = e => {\n    x.value = e.pageX\n    y.value = e.pageY\n  }\n  onMounted(() => {\n    window.addEventListener('mousemove', update)\n  })\n  onUnmounted(() => {\n    window.removeEventListener('mousemove', update)\n  })\n  return { x, y }\n}\n\n// 在组件中使用该函数\nconst Component = {\n  setup() {\n    const { x, y } = useMouse()\n    // 与其它函数配合使用\n    const { z } = useOtherLogic()\n    return { x, y, z }\n  },\n  template: `<div>{{ x }} {{ y }} {{ z }}</div>`\n}\n```\n\n可以看出来同样我们可以抽离一些需要复用的逻辑到一个单独的函数useMouse中，然后在这个函数里面定义的一些生命周期和value的内容会随着setup函数的调用被“钩入(hook)”到组件上，并且这个函数return出来的数据可以直接被用在模板上，更具体的玩法我们坐等3.0的出现吧。\n\n基础内容不过多介绍，毕竟真实的api还没发布，想了解具体内容的可以来看尤大的[讲解](https://link.juejin.im?target=https%3A%2F%2Fzhuanlan.zhihu.com%2Fp%2F68477600)\n\n### same & diff Point\n\n看完了2个框架关于hook的实现，我们来做个简单的对比\n\n1. Same Point:\n\n- 出现的背景，解决的问题是一样的，2个框架都是为了解决逻辑复用过乱，代码体积过大等一些问题，包括this问题，使用function函数我们很少会和this去打交道了。\n- 使用方式类似，都是把可以复用的一些单独的逻辑抽离到一个单独的函数中去，同时返回组件中需要用到的数据，并且内部会自我维护数据的更新，从而触发视图的更新\n\n1. Diff Point:\n\n**实现原理不同** react hook底层是基于链表实现，调用的条件是每次组件被render的时候都会顺序执行所有的hooks，所以下面的代码会报错\n\n```javascript\nfunction App(){\n    const [name, setName] = useState('demo');\n    if(condition){\n        const [val, setVal] = useState('');\n    }\n}\n```\n\n因为底层是链表，每一个hook的next是指向下一个hook的，if会导致顺序不正确，从而导致报错，所以react是不允许这样使用hook的。\n\nvue hook只会在setup函数被调用的时候被注册一次，react数据更改的时候，会导致重新render，重新render又会重新把hooks重新注册一次，所以react的上手难度更高一些，而vue之所以能避开这些麻烦的问题，根本原因在于它对数据的响应是基于proxy的，这种场景下，只要任何一个更改data的地方，相关的function或者template都会被重新计算，因此避开了react可能遇到的性能上的问题\n\n当然react对这些都有解决方案，想了解的同学可以去看官网有介绍，比如useCallback，useMemo等hook的作用，我们看下尤大对vue和react hook的总结对比：\n\n> 1.整体上更符合 JavaScript 的直觉；\n\n> 2.不受调用顺序的限制，可以有条件地被调用；\n\n> 3.不会在后续更新时不断产生大量的内联函数而影响引擎优化或是导致 GC 压力；\n\n> 4.不需要总是使用 useCallback 来缓存传给子组件的回调以防止过度更新；\n\n> 5.不需要担心传了错误的依赖数组给 useEffect/useMemo/useCallback 从而导致回调中使用了过期的值 —— Vue 的依赖追踪是全自动的。\n\n不得不说，青出于蓝而胜于蓝，vue虽然借鉴了react，但是天然的响应式数据，完美的避开了一些react hook遇到的短板~\n\n### 总结\n\n1. function component 将会是接下来各大框架发展的一个方向，function天然对TS的友好也是一个重要的影响;\n2. react hook的上手成本相对于vue会难一些，vue天生规避了一些react中比较难处理的地方;\n3. hook一定是大前端的一个趋势，现在才是刚刚开始的阶段：[SwiftUI-Hooks](https://link.juejin.im?target=https%3A%2F%2Fgithub.com%2Funixzii%2FSwiftUI-Hooks), [flutter_hooks](https://link.juejin.im?target=https%3A%2F%2Fgithub.com%2FrrousselGit%2Fflutter_hooks)...","slug":"Hook","published":1,"updated":"2019-12-25T06:05:10.855Z","_id":"ck4kqm46x00040w9m8q8qpiy8","comments":1,"layout":"post","photos":[],"link":"","content":"<h3 id=\"什么是hook\"><a href=\"#什么是hook\" class=\"headerlink\" title=\"什么是hook\"></a>什么是hook</h3><p>首先我们需要了解什么是hook，拿react的介绍来看，它的定义是：</p>\n<blockquote>\n<p>它可以让你在不编写 class 的情况下使用 state 以及其他的 React 特性</p>\n</blockquote>\n<p>在16.8以前的版本中，我们在写react组件的时候，大部分都都是class component，因为基于class的组件react提供了更多的可操作性，比如拥有自己的state，以及一些生命周期的实现，对于复杂的逻辑来讲class的支持程度是更高的：<br><a id=\"more\"></a><br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Hello</span> <span class=\"keyword\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">Component</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">constructor</span>(props) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">super</span>(props);</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.state = &#123;<span class=\"attr\">date</span>: <span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>()&#125;;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  componentDidMount() &#123; <span class=\"comment\">// do sth... &#125;</span></span><br><span class=\"line\"></span><br><span class=\"line\">  componentWillUnmount() &#123; <span class=\"comment\">// do sth... &#125;</span></span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"comment\">// other methods or lifecycle...</span></span><br><span class=\"line\">  </span><br><span class=\"line\">  render() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (</span><br><span class=\"line\">      &lt;div&gt;</span><br><span class=\"line\">        &lt;h1&gt;Hello, world!<span class=\"xml\"><span class=\"tag\">&lt;/<span class=\"name\">h1</span>&gt;</span></span></span><br><span class=\"line\">        &lt;h2&gt;It is &#123;<span class=\"keyword\">this</span>.state.date.toLocaleTimeString()&#125;.&lt;<span class=\"regexp\">/h2&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">      &lt;/</span>div&gt;</span><br><span class=\"line\">    );</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>同时，对于function component来说，react也是支持的，但是function component只能拥有props，不能拥有state，也就是只能实现stateless component：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Welcome</span>(<span class=\"params\">props</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">h1</span>&gt;</span>Hello, &#123;props.name&#125;<span class=\"tag\">&lt;/<span class=\"name\">h1</span>&gt;</span></span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>react 并没有提供在函数组件中设置state以及生命周期的一些操作方法，所以那个时候，极少的场景下适合采用函数组件，但是16.8版本出现hook以后情况得到了改变，hook的目标就是–<strong>让你在不编写 class 的情况下使用 state 以及其他的 React 特性</strong>，来看个例子：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> React, &#123; useState &#125; <span class=\"keyword\">from</span> <span class=\"string\">'react'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Example</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 声明一个新的叫做 “count” 的 state 变量</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> [count, setCount] = useState(<span class=\"number\">0</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> (</span><br><span class=\"line\">    &lt;div&gt;</span><br><span class=\"line\">      &lt;p&gt;You clicked &#123;count&#125; times&lt;<span class=\"regexp\">/p&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">      &lt;button onClick=&#123;() =&gt; setCount(count + 1)&#125;&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">        Click me</span></span><br><span class=\"line\"><span class=\"regexp\">      &lt;/</span>button&gt;</span><br><span class=\"line\">    &lt;<span class=\"regexp\">/div&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">  );</span></span><br><span class=\"line\"><span class=\"regexp\">&#125;</span></span><br></pre></td></tr></table></figure>\n<p>useState就是react提供的一个Hook，通过它我们就可以在function组件中设置自己想要的state了，不仅可以使用还可以很方便的去通过setState(注意不是class中的setState，这里指的是上述例子中的setCount)更改，当然，react提供了很多hook来支持不同的行为和操作，下面我们还会再简单介绍，我们在看下vue hook，这是尤大在vueconf上分享的一段代码：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; value, computed, watch, onMounted &#125; <span class=\"keyword\">from</span> <span class=\"string\">'vue'</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> App = &#123;</span><br><span class=\"line\">  template: <span class=\"string\">`</span></span><br><span class=\"line\"><span class=\"string\">    &lt;div&gt;</span></span><br><span class=\"line\"><span class=\"string\">      &lt;span&gt;count is &#123;&#123; count &#125;&#125;&lt;/span&gt;</span></span><br><span class=\"line\"><span class=\"string\">      &lt;span&gt;plusOne is &#123;&#123; plusOne &#125;&#125;&lt;/span&gt;</span></span><br><span class=\"line\"><span class=\"string\">      &lt;button @click=\"increment\"&gt;count++&lt;/button&gt;</span></span><br><span class=\"line\"><span class=\"string\">    &lt;/div&gt;</span></span><br><span class=\"line\"><span class=\"string\">  `</span>,</span><br><span class=\"line\">  setup() &#123;</span><br><span class=\"line\">    <span class=\"comment\">// reactive state</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> count = value(<span class=\"number\">0</span>)</span><br><span class=\"line\">    <span class=\"comment\">// computed state</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> plusOne = computed(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> count.value + <span class=\"number\">1</span>)</span><br><span class=\"line\">    <span class=\"comment\">// method</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> increment = <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123; count.value++ &#125;</span><br><span class=\"line\">    <span class=\"comment\">// watch</span></span><br><span class=\"line\">    watch(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> count.value * <span class=\"number\">2</span>, val =&gt; &#123;</span><br><span class=\"line\">      <span class=\"built_in\">console</span>.log(<span class=\"string\">`count * 2 is <span class=\"subst\">$&#123;val&#125;</span>`</span>)</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">    <span class=\"comment\">// lifecycle</span></span><br><span class=\"line\">    onMounted(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">      <span class=\"built_in\">console</span>.log(<span class=\"string\">`mounted`</span>)</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">    <span class=\"comment\">// expose bindings on render context</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">      count,</span><br><span class=\"line\">      plusOne,</span><br><span class=\"line\">      increment</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>从上面的例子中不难看出，和react hook的用法非常相似，并且尤大也有说这个RFC是借鉴了react hook的想法，但是规避了一些react的问题，然后这里解释一下为什么我把vue的这个RFC也称为是hook，因为在react hook的介绍中有这么一句话，什么是hook–Hook 是一些可以让你在函数组件里“钩入” React state 及生命周期等特性的函数，那么vue提供的这些API的作用也是类似的–可以让你在函数组件里“钩入” value(2.x中的data) 及生命周期等特性的函数，所以，暂且就叫vue-hook吧~</p>\n<h3 id=\"hook的时代意义\"><a href=\"#hook的时代意义\" class=\"headerlink\" title=\"hook的时代意义\"></a>hook的时代意义</h3><p>那么，hook的时代意义是什么？我们从头来说，框架是服务于业务的，业务中很难避免的一个问题就是– 逻辑复用，同样的功能，同样的组件，在不一样的场合下，我们有时候不得不去写2+次，为了避免耦合，后来各大框架纷纷想出了一些办法：</p>\n<ul>\n<li>mixin</li>\n<li>HOC</li>\n<li>slot</li>\n</ul>\n<p>各大框架的使用情况：</p>\n<ul>\n<li>react 和 vue都曾用过mixin(react 目前已经废弃),</li>\n<li>Higher-Order-Components(HOC) react中用的相对多一点，vue的话，嵌套template有点。。别扭,</li>\n<li>slot vue中用的多一些，react基本不需要slot这种用法,</li>\n</ul>\n<p>上述这些方法都可以实现逻辑上的复用，但是都有一些额外的问题:</p>\n<ul>\n<li>mixin的问题：<ul>\n<li>可能会相互依赖，相互耦合，不利于代码维护；</li>\n<li>不同的mixin中的方法可能会相互冲突;</li>\n<li>mixin非常多时，组件是可以感知到的，甚至还要为其做相关处理， 这样会给代码造成滚雪球式的复杂性</li>\n</ul>\n</li>\n<li>HOC的问题：<ul>\n<li>需要在原组件上进行包裹或者嵌套，如果大量使用HOC， 将会产生非常多的嵌套，这让调试变得非常困难；</li>\n<li>HOC可以劫持props，在不遵守约定的情况下也可能造成冲突</li>\n<li>props 也可能造成命名的冲突</li>\n<li>wrapper hell</li>\n</ul>\n</li>\n</ul>\n<p><strong>有没有见过这样的dom结构？</strong></p>\n<p><img src=\"http://pic3.58cdn.com.cn/ecomfe/n_v2b7e58d1117054b4280b705d5952805f0.png\" alt=\"img\"></p>\n<p>这就是wrapper hell的典型代表~</p>\n<p>所以，hook的出现是划时代的，它通过function抽离的方式，实现了复杂逻辑的内部封装，根据上述我们提出的问题总结了hook的一些优点：</p>\n<ol>\n<li>逻辑代码的复用</li>\n<li>减小了代码体积</li>\n<li>没有this的烦恼</li>\n</ol>\n<p>带着这些思想，我们一起看下react和vue分别的实现：</p>\n<h3 id=\"react-hook简介\"><a href=\"#react-hook简介\" class=\"headerlink\" title=\"react hook简介\"></a>react hook简介</h3><blockquote>\n<p>Dan 讲解hook的视频在<a href=\"https://link.juejin.im?target=https%3A%2F%2Fwww.youtube.com%2Fwatch%3Fv%3Ddpw9EHDh2bM%26feature%3Dyoutu.be\" target=\"_blank\" rel=\"noopener\">这里</a>，如果你看不了这个，可以尝试看<a href=\"https://link.juejin.im?target=https%3A%2F%2Freact.docschina.org%2Fdocs%2Fhooks-intro.html\" target=\"_blank\" rel=\"noopener\">官网介绍</a></p>\n</blockquote>\n<p>我们用同样功能的代码来看react hook，实现一个监听鼠标变化，并实时查看位置的功能，同时我们把位置信息挂到title上面，用class component我们要这样写：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> React, &#123; Component &#125; <span class=\"keyword\">from</span> <span class=\"string\">'react'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyClassApp</span> <span class=\"keyword\">extends</span> <span class=\"title\">Component</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">constructor</span>(props) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>(props);</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.state = &#123;</span><br><span class=\"line\">            x: <span class=\"number\">0</span>,</span><br><span class=\"line\">            y: <span class=\"number\">0</span></span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.handleUpdate = <span class=\"keyword\">this</span>.handleUpdate.bind(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    componentDidMount() &#123;</span><br><span class=\"line\">        <span class=\"built_in\">document</span>.addEventListener(<span class=\"string\">'mousemove'</span>, <span class=\"keyword\">this</span>.handleUpdate);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    componentDidUpdate() &#123;</span><br><span class=\"line\">        <span class=\"keyword\">const</span> &#123; x, y &#125; = <span class=\"keyword\">this</span>.state;</span><br><span class=\"line\">        <span class=\"built_in\">document</span>.title = <span class=\"string\">`(<span class=\"subst\">$&#123;x&#125;</span>,<span class=\"subst\">$&#123;y&#125;</span>)`</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    componentWillUnmount() &#123;</span><br><span class=\"line\">        <span class=\"built_in\">window</span>.removeEventListener(<span class=\"string\">'mousemove'</span>, <span class=\"keyword\">this</span>.handleUpdate);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    handleUpdate(e) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.setState(&#123;</span><br><span class=\"line\">            x: e.clientX,</span><br><span class=\"line\">            y: e.clientY</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    render() &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> (</span><br><span class=\"line\">            &lt;div&gt;</span><br><span class=\"line\">                current position x:&#123;<span class=\"keyword\">this</span>.state.x&#125;, <span class=\"attr\">y</span>:&#123;<span class=\"keyword\">this</span>.state.y&#125;</span><br><span class=\"line\">            &lt;<span class=\"regexp\">/div&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">        );</span></span><br><span class=\"line\"><span class=\"regexp\">    &#125;</span></span><br><span class=\"line\"><span class=\"regexp\">&#125;</span></span><br></pre></td></tr></table></figure>\n<p>在线代码演示在<a href=\"https://link.juejin.im?target=https%3A%2F%2Fcodesandbox.io%2Fs%2Fxenodochial-butterfly-gzflh\" target=\"_blank\" rel=\"noopener\">这里</a></p>\n<p>同样的逻辑我们换用hook来实现</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> React, &#123; useState, useEffect &#125; <span class=\"keyword\">from</span> <span class=\"string\">'react'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 自定义hook useMousePostion</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> useMousePostion = <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 使用hookuseState初始化一个state</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> [postion, setPostion] = useState(&#123; <span class=\"attr\">x</span>: <span class=\"number\">0</span>, <span class=\"attr\">y</span>: <span class=\"number\">0</span> &#125;);</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">handleMove</span>(<span class=\"params\">e</span>) </span>&#123;</span><br><span class=\"line\">        setPostion(&#123; <span class=\"attr\">x</span>: e.clientX, <span class=\"attr\">y</span>: e.clientY &#125;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 使用useEffect处理class中生命周期可以做到的事情</span></span><br><span class=\"line\">    <span class=\"comment\">// 注：效果一样，但是实际的原理并不同，有兴趣可以去官网仔细研究</span></span><br><span class=\"line\">    useEffect(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 同时可以处理 componentDidMount 以及 componentDidUpdate 中的事情</span></span><br><span class=\"line\">        <span class=\"built_in\">window</span>.addEventListener(<span class=\"string\">'mousemove'</span>, handleMove);</span><br><span class=\"line\">        <span class=\"built_in\">document</span>.title = <span class=\"string\">`(<span class=\"subst\">$&#123;postion.x&#125;</span>,<span class=\"subst\">$&#123;postion.y&#125;</span>)`</span>;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// return的function 可以相当于在组件被卸载的时候执行 类似于 componentWillUnmount</span></span><br><span class=\"line\">            <span class=\"built_in\">window</span>.removeEventListener(<span class=\"string\">'mousemove'</span>, handleMove);</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">        <span class=\"comment\">// [] 是参数，代表deps，也就是说react触发这个hook的时机会和传入的deps有关，内部利用objectIs实现</span></span><br><span class=\"line\">        <span class=\"comment\">// 默认不给参数会在每次render的时候调用，给空数组会导致每次比较是一样的，只执行一次，这里正确的应该是给postion</span></span><br><span class=\"line\">    &#125;, [postion]);</span><br><span class=\"line\">    <span class=\"comment\">// postion 可以被直接return，这样达到了逻辑的复用~，哪里需要哪里调用就可以了。</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> postion;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">App</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> &#123; x, y &#125; = useMousePostion(); <span class=\"comment\">// 内部维护自己的postion相关的逻辑</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> (</span><br><span class=\"line\">        &lt;div&gt;</span><br><span class=\"line\">            current position x: &#123;x&#125;, <span class=\"attr\">y</span>: &#123;y&#125;</span><br><span class=\"line\">        &lt;<span class=\"regexp\">/div&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">    );</span></span><br><span class=\"line\"><span class=\"regexp\">&#125;</span></span><br></pre></td></tr></table></figure>\n<p>在线代码演示在<a href=\"https://link.juejin.im?target=https%3A%2F%2Fcodesandbox.io%2Fs%2Fhookdemo-8zxh2\" target=\"_blank\" rel=\"noopener\">这里</a></p>\n<p>可以看出用了hook之后，我们把关于position的逻辑都放到一个自定义的hook–useMousePostion 中，之后复用是很方便的，而且可以在内部进行维护postion独有的逻辑而不影响外部内容，比起class组件，抽象能力更强。</p>\n<p>下面给大家安利几个不错的资源：</p>\n<p>入门：</p>\n<ul>\n<li><a href=\"https://link.juejin.im?target=https%3A%2F%2Freact.docschina.org%2Fdocs%2Fhooks-overview.html\" target=\"_blank\" rel=\"noopener\">官网传送门</a></li>\n</ul>\n<p>深入：</p>\n<ul>\n<li><a href=\"https://link.juejin.im?target=https%3A%2F%2Foverreacted.io%2Fzh-hans%2Fa-complete-guide-to-useeffect%2F%23tldr\" target=\"_blank\" rel=\"noopener\">Dan自己写的关于hook的文章，写的很好强烈安利，深入内部实现</a></li>\n</ul>\n<h3 id=\"vue-hook简介\"><a href=\"#vue-hook简介\" class=\"headerlink\" title=\"vue hook简介\"></a>vue hook简介</h3><blockquote>\n<p>尤大讲解的视频在<a href=\"https://link.juejin.im?target=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2FhBqu1A3gIwMVglb-ZWp8oA\" target=\"_blank\" rel=\"noopener\">这里</a></p>\n</blockquote>\n<p>代码因为vue3.0尚未发布，我们还是看尤大给的demo代码：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; value, computed, watch, onMounted &#125; <span class=\"keyword\">from</span> <span class=\"string\">'vue'</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">useMouse</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> x = value(<span class=\"number\">0</span>)</span><br><span class=\"line\">  <span class=\"keyword\">const</span> y = value(<span class=\"number\">0</span>)</span><br><span class=\"line\">  <span class=\"keyword\">const</span> update = <span class=\"function\"><span class=\"params\">e</span> =&gt;</span> &#123;</span><br><span class=\"line\">    x.value = e.pageX</span><br><span class=\"line\">    y.value = e.pageY</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  onMounted(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">window</span>.addEventListener(<span class=\"string\">'mousemove'</span>, update)</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">  onUnmounted(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">window</span>.removeEventListener(<span class=\"string\">'mousemove'</span>, update)</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">  <span class=\"keyword\">return</span> &#123; x, y &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 在组件中使用该函数</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> Component = &#123;</span><br><span class=\"line\">  setup() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> &#123; x, y &#125; = useMouse()</span><br><span class=\"line\">    <span class=\"comment\">// 与其它函数配合使用</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> &#123; z &#125; = useOtherLogic()</span><br><span class=\"line\">    <span class=\"keyword\">return</span> &#123; x, y, z &#125;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  template: <span class=\"string\">`&lt;div&gt;&#123;&#123; x &#125;&#125; &#123;&#123; y &#125;&#125; &#123;&#123; z &#125;&#125;&lt;/div&gt;`</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>可以看出来同样我们可以抽离一些需要复用的逻辑到一个单独的函数useMouse中，然后在这个函数里面定义的一些生命周期和value的内容会随着setup函数的调用被“钩入(hook)”到组件上，并且这个函数return出来的数据可以直接被用在模板上，更具体的玩法我们坐等3.0的出现吧。</p>\n<p>基础内容不过多介绍，毕竟真实的api还没发布，想了解具体内容的可以来看尤大的<a href=\"https://link.juejin.im?target=https%3A%2F%2Fzhuanlan.zhihu.com%2Fp%2F68477600\" target=\"_blank\" rel=\"noopener\">讲解</a></p>\n<h3 id=\"same-amp-diff-Point\"><a href=\"#same-amp-diff-Point\" class=\"headerlink\" title=\"same &amp; diff Point\"></a>same &amp; diff Point</h3><p>看完了2个框架关于hook的实现，我们来做个简单的对比</p>\n<ol>\n<li>Same Point:</li>\n</ol>\n<ul>\n<li>出现的背景，解决的问题是一样的，2个框架都是为了解决逻辑复用过乱，代码体积过大等一些问题，包括this问题，使用function函数我们很少会和this去打交道了。</li>\n<li>使用方式类似，都是把可以复用的一些单独的逻辑抽离到一个单独的函数中去，同时返回组件中需要用到的数据，并且内部会自我维护数据的更新，从而触发视图的更新</li>\n</ul>\n<ol>\n<li>Diff Point:</li>\n</ol>\n<p><strong>实现原理不同</strong> react hook底层是基于链表实现，调用的条件是每次组件被render的时候都会顺序执行所有的hooks，所以下面的代码会报错</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">App</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> [name, setName] = useState(<span class=\"string\">'demo'</span>);</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(condition)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">const</span> [val, setVal] = useState(<span class=\"string\">''</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>因为底层是链表，每一个hook的next是指向下一个hook的，if会导致顺序不正确，从而导致报错，所以react是不允许这样使用hook的。</p>\n<p>vue hook只会在setup函数被调用的时候被注册一次，react数据更改的时候，会导致重新render，重新render又会重新把hooks重新注册一次，所以react的上手难度更高一些，而vue之所以能避开这些麻烦的问题，根本原因在于它对数据的响应是基于proxy的，这种场景下，只要任何一个更改data的地方，相关的function或者template都会被重新计算，因此避开了react可能遇到的性能上的问题</p>\n<p>当然react对这些都有解决方案，想了解的同学可以去看官网有介绍，比如useCallback，useMemo等hook的作用，我们看下尤大对vue和react hook的总结对比：</p>\n<blockquote>\n<p>1.整体上更符合 JavaScript 的直觉；</p>\n</blockquote>\n<blockquote>\n<p>2.不受调用顺序的限制，可以有条件地被调用；</p>\n</blockquote>\n<blockquote>\n<p>3.不会在后续更新时不断产生大量的内联函数而影响引擎优化或是导致 GC 压力；</p>\n</blockquote>\n<blockquote>\n<p>4.不需要总是使用 useCallback 来缓存传给子组件的回调以防止过度更新；</p>\n</blockquote>\n<blockquote>\n<p>5.不需要担心传了错误的依赖数组给 useEffect/useMemo/useCallback 从而导致回调中使用了过期的值 —— Vue 的依赖追踪是全自动的。</p>\n</blockquote>\n<p>不得不说，青出于蓝而胜于蓝，vue虽然借鉴了react，但是天然的响应式数据，完美的避开了一些react hook遇到的短板~</p>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><ol>\n<li>function component 将会是接下来各大框架发展的一个方向，function天然对TS的友好也是一个重要的影响;</li>\n<li>react hook的上手成本相对于vue会难一些，vue天生规避了一些react中比较难处理的地方;</li>\n<li>hook一定是大前端的一个趋势，现在才是刚刚开始的阶段：<a href=\"https://link.juejin.im?target=https%3A%2F%2Fgithub.com%2Funixzii%2FSwiftUI-Hooks\" target=\"_blank\" rel=\"noopener\">SwiftUI-Hooks</a>, <a href=\"https://link.juejin.im?target=https%3A%2F%2Fgithub.com%2FrrousselGit%2Fflutter_hooks\" target=\"_blank\" rel=\"noopener\">flutter_hooks</a>…</li>\n</ol>\n","site":{"data":{}},"excerpt":"<h3 id=\"什么是hook\"><a href=\"#什么是hook\" class=\"headerlink\" title=\"什么是hook\"></a>什么是hook</h3><p>首先我们需要了解什么是hook，拿react的介绍来看，它的定义是：</p>\n<blockquote>\n<p>它可以让你在不编写 class 的情况下使用 state 以及其他的 React 特性</p>\n</blockquote>\n<p>在16.8以前的版本中，我们在写react组件的时候，大部分都都是class component，因为基于class的组件react提供了更多的可操作性，比如拥有自己的state，以及一些生命周期的实现，对于复杂的逻辑来讲class的支持程度是更高的：<br>","more":"<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Hello</span> <span class=\"keyword\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">Component</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">constructor</span>(props) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">super</span>(props);</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.state = &#123;<span class=\"attr\">date</span>: <span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>()&#125;;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  componentDidMount() &#123; <span class=\"comment\">// do sth... &#125;</span></span><br><span class=\"line\"></span><br><span class=\"line\">  componentWillUnmount() &#123; <span class=\"comment\">// do sth... &#125;</span></span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"comment\">// other methods or lifecycle...</span></span><br><span class=\"line\">  </span><br><span class=\"line\">  render() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (</span><br><span class=\"line\">      &lt;div&gt;</span><br><span class=\"line\">        &lt;h1&gt;Hello, world!<span class=\"xml\"><span class=\"tag\">&lt;/<span class=\"name\">h1</span>&gt;</span></span></span><br><span class=\"line\">        &lt;h2&gt;It is &#123;<span class=\"keyword\">this</span>.state.date.toLocaleTimeString()&#125;.&lt;<span class=\"regexp\">/h2&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">      &lt;/</span>div&gt;</span><br><span class=\"line\">    );</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>同时，对于function component来说，react也是支持的，但是function component只能拥有props，不能拥有state，也就是只能实现stateless component：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Welcome</span>(<span class=\"params\">props</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">h1</span>&gt;</span>Hello, &#123;props.name&#125;<span class=\"tag\">&lt;/<span class=\"name\">h1</span>&gt;</span></span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>react 并没有提供在函数组件中设置state以及生命周期的一些操作方法，所以那个时候，极少的场景下适合采用函数组件，但是16.8版本出现hook以后情况得到了改变，hook的目标就是–<strong>让你在不编写 class 的情况下使用 state 以及其他的 React 特性</strong>，来看个例子：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> React, &#123; useState &#125; <span class=\"keyword\">from</span> <span class=\"string\">'react'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Example</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 声明一个新的叫做 “count” 的 state 变量</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> [count, setCount] = useState(<span class=\"number\">0</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> (</span><br><span class=\"line\">    &lt;div&gt;</span><br><span class=\"line\">      &lt;p&gt;You clicked &#123;count&#125; times&lt;<span class=\"regexp\">/p&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">      &lt;button onClick=&#123;() =&gt; setCount(count + 1)&#125;&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">        Click me</span></span><br><span class=\"line\"><span class=\"regexp\">      &lt;/</span>button&gt;</span><br><span class=\"line\">    &lt;<span class=\"regexp\">/div&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">  );</span></span><br><span class=\"line\"><span class=\"regexp\">&#125;</span></span><br></pre></td></tr></table></figure>\n<p>useState就是react提供的一个Hook，通过它我们就可以在function组件中设置自己想要的state了，不仅可以使用还可以很方便的去通过setState(注意不是class中的setState，这里指的是上述例子中的setCount)更改，当然，react提供了很多hook来支持不同的行为和操作，下面我们还会再简单介绍，我们在看下vue hook，这是尤大在vueconf上分享的一段代码：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; value, computed, watch, onMounted &#125; <span class=\"keyword\">from</span> <span class=\"string\">'vue'</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> App = &#123;</span><br><span class=\"line\">  template: <span class=\"string\">`</span></span><br><span class=\"line\"><span class=\"string\">    &lt;div&gt;</span></span><br><span class=\"line\"><span class=\"string\">      &lt;span&gt;count is &#123;&#123; count &#125;&#125;&lt;/span&gt;</span></span><br><span class=\"line\"><span class=\"string\">      &lt;span&gt;plusOne is &#123;&#123; plusOne &#125;&#125;&lt;/span&gt;</span></span><br><span class=\"line\"><span class=\"string\">      &lt;button @click=\"increment\"&gt;count++&lt;/button&gt;</span></span><br><span class=\"line\"><span class=\"string\">    &lt;/div&gt;</span></span><br><span class=\"line\"><span class=\"string\">  `</span>,</span><br><span class=\"line\">  setup() &#123;</span><br><span class=\"line\">    <span class=\"comment\">// reactive state</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> count = value(<span class=\"number\">0</span>)</span><br><span class=\"line\">    <span class=\"comment\">// computed state</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> plusOne = computed(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> count.value + <span class=\"number\">1</span>)</span><br><span class=\"line\">    <span class=\"comment\">// method</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> increment = <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123; count.value++ &#125;</span><br><span class=\"line\">    <span class=\"comment\">// watch</span></span><br><span class=\"line\">    watch(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> count.value * <span class=\"number\">2</span>, val =&gt; &#123;</span><br><span class=\"line\">      <span class=\"built_in\">console</span>.log(<span class=\"string\">`count * 2 is <span class=\"subst\">$&#123;val&#125;</span>`</span>)</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">    <span class=\"comment\">// lifecycle</span></span><br><span class=\"line\">    onMounted(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">      <span class=\"built_in\">console</span>.log(<span class=\"string\">`mounted`</span>)</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">    <span class=\"comment\">// expose bindings on render context</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">      count,</span><br><span class=\"line\">      plusOne,</span><br><span class=\"line\">      increment</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>从上面的例子中不难看出，和react hook的用法非常相似，并且尤大也有说这个RFC是借鉴了react hook的想法，但是规避了一些react的问题，然后这里解释一下为什么我把vue的这个RFC也称为是hook，因为在react hook的介绍中有这么一句话，什么是hook–Hook 是一些可以让你在函数组件里“钩入” React state 及生命周期等特性的函数，那么vue提供的这些API的作用也是类似的–可以让你在函数组件里“钩入” value(2.x中的data) 及生命周期等特性的函数，所以，暂且就叫vue-hook吧~</p>\n<h3 id=\"hook的时代意义\"><a href=\"#hook的时代意义\" class=\"headerlink\" title=\"hook的时代意义\"></a>hook的时代意义</h3><p>那么，hook的时代意义是什么？我们从头来说，框架是服务于业务的，业务中很难避免的一个问题就是– 逻辑复用，同样的功能，同样的组件，在不一样的场合下，我们有时候不得不去写2+次，为了避免耦合，后来各大框架纷纷想出了一些办法：</p>\n<ul>\n<li>mixin</li>\n<li>HOC</li>\n<li>slot</li>\n</ul>\n<p>各大框架的使用情况：</p>\n<ul>\n<li>react 和 vue都曾用过mixin(react 目前已经废弃),</li>\n<li>Higher-Order-Components(HOC) react中用的相对多一点，vue的话，嵌套template有点。。别扭,</li>\n<li>slot vue中用的多一些，react基本不需要slot这种用法,</li>\n</ul>\n<p>上述这些方法都可以实现逻辑上的复用，但是都有一些额外的问题:</p>\n<ul>\n<li>mixin的问题：<ul>\n<li>可能会相互依赖，相互耦合，不利于代码维护；</li>\n<li>不同的mixin中的方法可能会相互冲突;</li>\n<li>mixin非常多时，组件是可以感知到的，甚至还要为其做相关处理， 这样会给代码造成滚雪球式的复杂性</li>\n</ul>\n</li>\n<li>HOC的问题：<ul>\n<li>需要在原组件上进行包裹或者嵌套，如果大量使用HOC， 将会产生非常多的嵌套，这让调试变得非常困难；</li>\n<li>HOC可以劫持props，在不遵守约定的情况下也可能造成冲突</li>\n<li>props 也可能造成命名的冲突</li>\n<li>wrapper hell</li>\n</ul>\n</li>\n</ul>\n<p><strong>有没有见过这样的dom结构？</strong></p>\n<p><img src=\"http://pic3.58cdn.com.cn/ecomfe/n_v2b7e58d1117054b4280b705d5952805f0.png\" alt=\"img\"></p>\n<p>这就是wrapper hell的典型代表~</p>\n<p>所以，hook的出现是划时代的，它通过function抽离的方式，实现了复杂逻辑的内部封装，根据上述我们提出的问题总结了hook的一些优点：</p>\n<ol>\n<li>逻辑代码的复用</li>\n<li>减小了代码体积</li>\n<li>没有this的烦恼</li>\n</ol>\n<p>带着这些思想，我们一起看下react和vue分别的实现：</p>\n<h3 id=\"react-hook简介\"><a href=\"#react-hook简介\" class=\"headerlink\" title=\"react hook简介\"></a>react hook简介</h3><blockquote>\n<p>Dan 讲解hook的视频在<a href=\"https://link.juejin.im?target=https%3A%2F%2Fwww.youtube.com%2Fwatch%3Fv%3Ddpw9EHDh2bM%26feature%3Dyoutu.be\" target=\"_blank\" rel=\"noopener\">这里</a>，如果你看不了这个，可以尝试看<a href=\"https://link.juejin.im?target=https%3A%2F%2Freact.docschina.org%2Fdocs%2Fhooks-intro.html\" target=\"_blank\" rel=\"noopener\">官网介绍</a></p>\n</blockquote>\n<p>我们用同样功能的代码来看react hook，实现一个监听鼠标变化，并实时查看位置的功能，同时我们把位置信息挂到title上面，用class component我们要这样写：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> React, &#123; Component &#125; <span class=\"keyword\">from</span> <span class=\"string\">'react'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyClassApp</span> <span class=\"keyword\">extends</span> <span class=\"title\">Component</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">constructor</span>(props) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>(props);</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.state = &#123;</span><br><span class=\"line\">            x: <span class=\"number\">0</span>,</span><br><span class=\"line\">            y: <span class=\"number\">0</span></span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.handleUpdate = <span class=\"keyword\">this</span>.handleUpdate.bind(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    componentDidMount() &#123;</span><br><span class=\"line\">        <span class=\"built_in\">document</span>.addEventListener(<span class=\"string\">'mousemove'</span>, <span class=\"keyword\">this</span>.handleUpdate);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    componentDidUpdate() &#123;</span><br><span class=\"line\">        <span class=\"keyword\">const</span> &#123; x, y &#125; = <span class=\"keyword\">this</span>.state;</span><br><span class=\"line\">        <span class=\"built_in\">document</span>.title = <span class=\"string\">`(<span class=\"subst\">$&#123;x&#125;</span>,<span class=\"subst\">$&#123;y&#125;</span>)`</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    componentWillUnmount() &#123;</span><br><span class=\"line\">        <span class=\"built_in\">window</span>.removeEventListener(<span class=\"string\">'mousemove'</span>, <span class=\"keyword\">this</span>.handleUpdate);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    handleUpdate(e) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.setState(&#123;</span><br><span class=\"line\">            x: e.clientX,</span><br><span class=\"line\">            y: e.clientY</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    render() &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> (</span><br><span class=\"line\">            &lt;div&gt;</span><br><span class=\"line\">                current position x:&#123;<span class=\"keyword\">this</span>.state.x&#125;, <span class=\"attr\">y</span>:&#123;<span class=\"keyword\">this</span>.state.y&#125;</span><br><span class=\"line\">            &lt;<span class=\"regexp\">/div&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">        );</span></span><br><span class=\"line\"><span class=\"regexp\">    &#125;</span></span><br><span class=\"line\"><span class=\"regexp\">&#125;</span></span><br></pre></td></tr></table></figure>\n<p>在线代码演示在<a href=\"https://link.juejin.im?target=https%3A%2F%2Fcodesandbox.io%2Fs%2Fxenodochial-butterfly-gzflh\" target=\"_blank\" rel=\"noopener\">这里</a></p>\n<p>同样的逻辑我们换用hook来实现</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> React, &#123; useState, useEffect &#125; <span class=\"keyword\">from</span> <span class=\"string\">'react'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 自定义hook useMousePostion</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> useMousePostion = <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 使用hookuseState初始化一个state</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> [postion, setPostion] = useState(&#123; <span class=\"attr\">x</span>: <span class=\"number\">0</span>, <span class=\"attr\">y</span>: <span class=\"number\">0</span> &#125;);</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">handleMove</span>(<span class=\"params\">e</span>) </span>&#123;</span><br><span class=\"line\">        setPostion(&#123; <span class=\"attr\">x</span>: e.clientX, <span class=\"attr\">y</span>: e.clientY &#125;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 使用useEffect处理class中生命周期可以做到的事情</span></span><br><span class=\"line\">    <span class=\"comment\">// 注：效果一样，但是实际的原理并不同，有兴趣可以去官网仔细研究</span></span><br><span class=\"line\">    useEffect(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 同时可以处理 componentDidMount 以及 componentDidUpdate 中的事情</span></span><br><span class=\"line\">        <span class=\"built_in\">window</span>.addEventListener(<span class=\"string\">'mousemove'</span>, handleMove);</span><br><span class=\"line\">        <span class=\"built_in\">document</span>.title = <span class=\"string\">`(<span class=\"subst\">$&#123;postion.x&#125;</span>,<span class=\"subst\">$&#123;postion.y&#125;</span>)`</span>;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// return的function 可以相当于在组件被卸载的时候执行 类似于 componentWillUnmount</span></span><br><span class=\"line\">            <span class=\"built_in\">window</span>.removeEventListener(<span class=\"string\">'mousemove'</span>, handleMove);</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">        <span class=\"comment\">// [] 是参数，代表deps，也就是说react触发这个hook的时机会和传入的deps有关，内部利用objectIs实现</span></span><br><span class=\"line\">        <span class=\"comment\">// 默认不给参数会在每次render的时候调用，给空数组会导致每次比较是一样的，只执行一次，这里正确的应该是给postion</span></span><br><span class=\"line\">    &#125;, [postion]);</span><br><span class=\"line\">    <span class=\"comment\">// postion 可以被直接return，这样达到了逻辑的复用~，哪里需要哪里调用就可以了。</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> postion;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">App</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> &#123; x, y &#125; = useMousePostion(); <span class=\"comment\">// 内部维护自己的postion相关的逻辑</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> (</span><br><span class=\"line\">        &lt;div&gt;</span><br><span class=\"line\">            current position x: &#123;x&#125;, <span class=\"attr\">y</span>: &#123;y&#125;</span><br><span class=\"line\">        &lt;<span class=\"regexp\">/div&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">    );</span></span><br><span class=\"line\"><span class=\"regexp\">&#125;</span></span><br></pre></td></tr></table></figure>\n<p>在线代码演示在<a href=\"https://link.juejin.im?target=https%3A%2F%2Fcodesandbox.io%2Fs%2Fhookdemo-8zxh2\" target=\"_blank\" rel=\"noopener\">这里</a></p>\n<p>可以看出用了hook之后，我们把关于position的逻辑都放到一个自定义的hook–useMousePostion 中，之后复用是很方便的，而且可以在内部进行维护postion独有的逻辑而不影响外部内容，比起class组件，抽象能力更强。</p>\n<p>下面给大家安利几个不错的资源：</p>\n<p>入门：</p>\n<ul>\n<li><a href=\"https://link.juejin.im?target=https%3A%2F%2Freact.docschina.org%2Fdocs%2Fhooks-overview.html\" target=\"_blank\" rel=\"noopener\">官网传送门</a></li>\n</ul>\n<p>深入：</p>\n<ul>\n<li><a href=\"https://link.juejin.im?target=https%3A%2F%2Foverreacted.io%2Fzh-hans%2Fa-complete-guide-to-useeffect%2F%23tldr\" target=\"_blank\" rel=\"noopener\">Dan自己写的关于hook的文章，写的很好强烈安利，深入内部实现</a></li>\n</ul>\n<h3 id=\"vue-hook简介\"><a href=\"#vue-hook简介\" class=\"headerlink\" title=\"vue hook简介\"></a>vue hook简介</h3><blockquote>\n<p>尤大讲解的视频在<a href=\"https://link.juejin.im?target=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2FhBqu1A3gIwMVglb-ZWp8oA\" target=\"_blank\" rel=\"noopener\">这里</a></p>\n</blockquote>\n<p>代码因为vue3.0尚未发布，我们还是看尤大给的demo代码：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; value, computed, watch, onMounted &#125; <span class=\"keyword\">from</span> <span class=\"string\">'vue'</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">useMouse</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> x = value(<span class=\"number\">0</span>)</span><br><span class=\"line\">  <span class=\"keyword\">const</span> y = value(<span class=\"number\">0</span>)</span><br><span class=\"line\">  <span class=\"keyword\">const</span> update = <span class=\"function\"><span class=\"params\">e</span> =&gt;</span> &#123;</span><br><span class=\"line\">    x.value = e.pageX</span><br><span class=\"line\">    y.value = e.pageY</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  onMounted(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">window</span>.addEventListener(<span class=\"string\">'mousemove'</span>, update)</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">  onUnmounted(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">window</span>.removeEventListener(<span class=\"string\">'mousemove'</span>, update)</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">  <span class=\"keyword\">return</span> &#123; x, y &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 在组件中使用该函数</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> Component = &#123;</span><br><span class=\"line\">  setup() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> &#123; x, y &#125; = useMouse()</span><br><span class=\"line\">    <span class=\"comment\">// 与其它函数配合使用</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> &#123; z &#125; = useOtherLogic()</span><br><span class=\"line\">    <span class=\"keyword\">return</span> &#123; x, y, z &#125;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  template: <span class=\"string\">`&lt;div&gt;&#123;&#123; x &#125;&#125; &#123;&#123; y &#125;&#125; &#123;&#123; z &#125;&#125;&lt;/div&gt;`</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>可以看出来同样我们可以抽离一些需要复用的逻辑到一个单独的函数useMouse中，然后在这个函数里面定义的一些生命周期和value的内容会随着setup函数的调用被“钩入(hook)”到组件上，并且这个函数return出来的数据可以直接被用在模板上，更具体的玩法我们坐等3.0的出现吧。</p>\n<p>基础内容不过多介绍，毕竟真实的api还没发布，想了解具体内容的可以来看尤大的<a href=\"https://link.juejin.im?target=https%3A%2F%2Fzhuanlan.zhihu.com%2Fp%2F68477600\" target=\"_blank\" rel=\"noopener\">讲解</a></p>\n<h3 id=\"same-amp-diff-Point\"><a href=\"#same-amp-diff-Point\" class=\"headerlink\" title=\"same &amp; diff Point\"></a>same &amp; diff Point</h3><p>看完了2个框架关于hook的实现，我们来做个简单的对比</p>\n<ol>\n<li>Same Point:</li>\n</ol>\n<ul>\n<li>出现的背景，解决的问题是一样的，2个框架都是为了解决逻辑复用过乱，代码体积过大等一些问题，包括this问题，使用function函数我们很少会和this去打交道了。</li>\n<li>使用方式类似，都是把可以复用的一些单独的逻辑抽离到一个单独的函数中去，同时返回组件中需要用到的数据，并且内部会自我维护数据的更新，从而触发视图的更新</li>\n</ul>\n<ol>\n<li>Diff Point:</li>\n</ol>\n<p><strong>实现原理不同</strong> react hook底层是基于链表实现，调用的条件是每次组件被render的时候都会顺序执行所有的hooks，所以下面的代码会报错</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">App</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> [name, setName] = useState(<span class=\"string\">'demo'</span>);</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(condition)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">const</span> [val, setVal] = useState(<span class=\"string\">''</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>因为底层是链表，每一个hook的next是指向下一个hook的，if会导致顺序不正确，从而导致报错，所以react是不允许这样使用hook的。</p>\n<p>vue hook只会在setup函数被调用的时候被注册一次，react数据更改的时候，会导致重新render，重新render又会重新把hooks重新注册一次，所以react的上手难度更高一些，而vue之所以能避开这些麻烦的问题，根本原因在于它对数据的响应是基于proxy的，这种场景下，只要任何一个更改data的地方，相关的function或者template都会被重新计算，因此避开了react可能遇到的性能上的问题</p>\n<p>当然react对这些都有解决方案，想了解的同学可以去看官网有介绍，比如useCallback，useMemo等hook的作用，我们看下尤大对vue和react hook的总结对比：</p>\n<blockquote>\n<p>1.整体上更符合 JavaScript 的直觉；</p>\n</blockquote>\n<blockquote>\n<p>2.不受调用顺序的限制，可以有条件地被调用；</p>\n</blockquote>\n<blockquote>\n<p>3.不会在后续更新时不断产生大量的内联函数而影响引擎优化或是导致 GC 压力；</p>\n</blockquote>\n<blockquote>\n<p>4.不需要总是使用 useCallback 来缓存传给子组件的回调以防止过度更新；</p>\n</blockquote>\n<blockquote>\n<p>5.不需要担心传了错误的依赖数组给 useEffect/useMemo/useCallback 从而导致回调中使用了过期的值 —— Vue 的依赖追踪是全自动的。</p>\n</blockquote>\n<p>不得不说，青出于蓝而胜于蓝，vue虽然借鉴了react，但是天然的响应式数据，完美的避开了一些react hook遇到的短板~</p>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><ol>\n<li>function component 将会是接下来各大框架发展的一个方向，function天然对TS的友好也是一个重要的影响;</li>\n<li>react hook的上手成本相对于vue会难一些，vue天生规避了一些react中比较难处理的地方;</li>\n<li>hook一定是大前端的一个趋势，现在才是刚刚开始的阶段：<a href=\"https://link.juejin.im?target=https%3A%2F%2Fgithub.com%2Funixzii%2FSwiftUI-Hooks\" target=\"_blank\" rel=\"noopener\">SwiftUI-Hooks</a>, <a href=\"https://link.juejin.im?target=https%3A%2F%2Fgithub.com%2FrrousselGit%2Fflutter_hooks\" target=\"_blank\" rel=\"noopener\">flutter_hooks</a>…</li>\n</ol>"},{"title":"diff算法","date":"2019-03-10T07:57:40.000Z","_content":"#### Diff三种策略\n\n![img](http://leqikeji.cn/blogImg/diff.png)\n\n\n\nDiff算法的作用是用来计算出 **Virtual DOM** 中被改变的部分，然后针对该部分进行原生DOM操作，而不用重新渲染整个页面。\n<!-- more -->\nDiff算法有三大策略：\n\n> 1. Tree Diff\n> 2. Component Diff\n> 3. Element Diff\n\n三种策略的执行顺序也是顺序依次执行。\n**Tree Diff** 是对树每一层进行遍历，找出不同，如图所示。\n\n![img](http://leqikeji.cn/blogImg/diff_demo.png)\n\n**Component Diff** 是数据层面的差异比较\n\n如果都是同一类型的组件(即：两节点是同一个组件类的两个不同实例，比如：<div id=\"before\"></div>与<div id=\"after\"></div>)，按照原策略继续比较Virtual DOM树即可\n\n如果出现不是同一类型的组件，则将该组件判断为dirty component，从而替换整个组件下的所有子节点\n\n**Element Diff**真实DOM渲染，结构差异的比较\n\n首先进行第一层比较，第一层都是R，不发生变化；然后进入第二层Component Diff，发现A组件没有，则删除A及其子组件B、C；最后比较第三层，创建A及其子组件B、C。\n\n当节点处于同一层级时，Diff提供三种DOM操作：**删除**、**移动**、**插入**。\n ![img](http://leqikeji.cn/blogImg/element_diff.png)\n\n如图所示，首先将OldVnode 和 NewVnode的首尾位置分别标记为oldS、oldE、newS、newE。\n\n(1)  oldS和newS相同，不发生变化，oldS++，newS++。\n\n> oldS = a，oldE = d\n>  newS = a, newE = c\n\n(2)  newS与OldVnode不匹配，oldS前面插入f，newS++。\n\n> oldS = b，oldE = d\n>  newS = f， newE = c\n\n(3)  newS与oldE相同，oldE移动到oldS前面，newS++，oldE--。\n\n> oldS = b，oldE = d\n>  newS = d， newE = c\n\n(4)  newE与oldE相同，不发生变化，newE--，oldE--。\n\n> oldS = b，oldE = c\n>  newS = e， newE = c\n\n(5)  都不相同，oldS前插入newE，删除oldS，oldS++，newS++，newE--，oldE--。\n\n> oldS = b，oldE = b\n>  newS = e， newE = e\n\n(6)  oldS > oldE，Diff结束，最后结果为：a、f、d、e、c。\n\n**最后附上核心源码分析：**\n**patch**\n\n```javascript\n\nfunction patch (oldVnode, vnode) {\n    // some code\n    if (sameVnode(oldVnode, vnode)) {\n        patchVnode(oldVnode, vnode)\n    } else {\n        const oEl = oldVnode.el // 当前oldVnode对应的真实元素节点\n        let parentEle = api.parentNode(oEl)  // 父元素\n        createEle(vnode)  // 根据Vnode生成新元素\n        if (parentEle !== null) {\n            api.insertBefore(parentEle, vnode.el, api.nextSibling(oEl)) // 将新元素添加进父元素\n            api.removeChild(parentEle, oldVnode.el)  // 移除以前的旧元素节点\n            oldVnode = null\n        }\n    }\n    // some code \n    return vnode\n}\n\npatchVnode (oldVnode, vnode) {\n    const el = vnode.el = oldVnode.el\n    let i, oldCh = oldVnode.children, ch = vnode.children\n    if (oldVnode === vnode) return\n    if (oldVnode.text !== null && vnode.text !== null && oldVnode.text !== vnode.text) {\n        api.setTextContent(el, vnode.text)\n    }else {\n        updateEle(el, vnode, oldVnode)\n        if (oldCh && ch && oldCh !== ch) {\n            updateChildren(el, oldCh, ch)\n        }else if (ch){\n            createEle(vnode) //create el's children dom\n        }else if (oldCh){\n            api.removeChildren(el)\n        }\n    }\n}\n```\n\n这个函数做了以下事情：\n\n- 找到对应的真实dom，称为el\n- 判断Vnode和oldVnode是否指向同一个对象，如果是，那么直接return\n- 如果他们都有文本节点并且不相等，那么将el的文本节点设置为Vnode的文本节点。\n- 如果oldVnode有子节点而Vnode没有，则删除el的子节点\n- 如果oldVnode没有子节点而Vnode有，则将Vnode的子节点真实化之后添加到el\n- 如果两者都有子节点，则执行updateChildren函数比较子节点\n\n**updateChildren**\n\n```javascript\nfunction updateChildren (parentElm, oldCh, newCh, insertedVnodeQueue, removeOnly) {\n    var oldStartIdx = 0;\n    var newStartIdx = 0;\n    var oldEndIdx = oldCh.length - 1;\n    var oldStartVnode = oldCh[0];\n    var oldEndVnode = oldCh[oldEndIdx];\n    var newEndIdx = newCh.length - 1;\n    var newStartVnode = newCh[0];\n    var newEndVnode = newCh[newEndIdx];\n    var oldKeyToIdx, idxInOld, vnodeToMove, refElm;\n\n    var canMove = !removeOnly;\n    {\n        checkDuplicateKeys(newCh);\n    }\n    // oldVnode起始位置小于结束位置并且newVnode起始位置小于结束位置\n    while (oldStartIdx <= oldEndIdx && newStartIdx <= newEndIdx) {\n        // isUndef 用来判断对象是否等于undefined或者为空，是的话返回true\n        if (isUndef(oldStartVnode)) {\n            // oldVnode 起始位置oldS++\n            oldStartVnode = oldCh[++oldStartIdx]; // Vnode has been moved left\n        } else if (isUndef(oldEndVnode)) {\n            // oldVnode 结束位置oldE--\n            oldEndVnode = oldCh[--oldEndIdx];\n        } else if (sameVnode(oldStartVnode, newStartVnode)) {\n            // oldS和newS相同，不变化，进行patch，oldS++，newS++\n            patchVnode(oldStartVnode, newStartVnode, insertedVnodeQueue, newCh, newStartIdx);\n            oldStartVnode = oldCh[++oldStartIdx];\n            newStartVnode = newCh[++newStartIdx];\n        } else if (sameVnode(oldEndVnode, newEndVnode)) {\n            // oldE和newE相同，不变化，进行patch，oldE--，newE--\n            patchVnode(oldEndVnode, newEndVnode, insertedVnodeQueue, newCh, newEndIdx);\n            oldEndVnode = oldCh[--oldEndIdx];\n            newEndVnode = newCh[--newEndIdx];\n        } else if (sameVnode(oldStartVnode, newEndVnode)) { // Vnode moved right\n            // oldS和newE相同，oldS移动到oldE之后，进行patch，oldS++，newE--\n            patchVnode(oldStartVnode, newEndVnode, insertedVnodeQueue, newCh, newEndIdx);\n            canMove && nodeOps.insertBefore(parentElm, oldStartVnode.elm, nodeOps.nextSibling(oldEndVnode.elm));\n            oldStartVnode = oldCh[++oldStartIdx];\n            newEndVnode = newCh[--newEndIdx];\n        } else if (sameVnode(oldEndVnode, newStartVnode)) { // Vnode moved left\n            // oldE和newS相同，oldE移动到oldS之前，进行patch，oldE--，newS++\n            patchVnode(oldEndVnode, newStartVnode, insertedVnodeQueue, newCh, newStartIdx);\n            canMove && nodeOps.insertBefore(parentElm, oldEndVnode.elm, oldStartVnode.elm);\n            oldEndVnode = oldCh[--oldEndIdx];\n            newStartVnode = newCh[++newStartIdx];\n        } else {\n            // 全都不相同情况下\n            // 获取oldVnode->index的key\n            if (isUndef(oldKeyToIdx)) {\n                oldKeyToIdx = createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx); \n            }\n            idxInOld = isDef(newStartVnode.key)\n              ? oldKeyToIdx[newStartVnode.key]\n              : findIdxInOld(newStartVnode, oldCh, oldStartIdx, oldEndIdx);\n            if (isUndef(idxInOld)) { // New element\n                // oldVnode->index为undefined或null，说明没有该元素，创建新的元素\n                createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm, false, newCh, newStartIdx);\n            } else {\n                  // 获取oldVnode\n                  vnodeToMove = oldCh[idxInOld];\n                  if (sameVnode(vnodeToMove, newStartVnode)) {\n                      // 创建的Vnode和newS相同，插入到oldS之前，进行patch\n                      patchVnode(vnodeToMove, newStartVnode, insertedVnodeQueue, newCh, newStartIdx);\n                      oldCh[idxInOld] = undefined;\n                      canMove && nodeOps.insertBefore(parentElm, vnodeToMove.elm, oldStartVnode.elm);\n                  } else {\n                      // 相同的key但是不一样的element. 被视为新的element\n                      createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm, false, newCh, newStartIdx);\n                  }\n            }\n            newStartVnode = newCh[++newStartIdx];\n        }\n    }\n    // 当oldS>oldE时，将newS至newE间的全部插入\n    if (oldStartIdx > oldEndIdx) {\n        refElm = isUndef(newCh[newEndIdx + 1]) ? null : newCh[newEndIdx + 1].elm;\n        addVnodes(parentElm, refElm, newCh, newStartIdx, newEndIdx, insertedVnodeQueue);\n    } else if (newStartIdx > newEndIdx) {\n        // 当newS>newE，将oldS至oldE间的全部删除\n        removeVnodes(parentElm, oldCh, oldStartIdx, oldEndIdx);\n    }\n}\n```\n\n","source":"_posts/diff.md","raw":"---\ntitle: diff算法\ndate: 2019-03-10 15:57:40\ntags:\n    - 算法\ncategories:\n    - 技术分享\n---\n#### Diff三种策略\n\n![img](http://leqikeji.cn/blogImg/diff.png)\n\n\n\nDiff算法的作用是用来计算出 **Virtual DOM** 中被改变的部分，然后针对该部分进行原生DOM操作，而不用重新渲染整个页面。\n<!-- more -->\nDiff算法有三大策略：\n\n> 1. Tree Diff\n> 2. Component Diff\n> 3. Element Diff\n\n三种策略的执行顺序也是顺序依次执行。\n**Tree Diff** 是对树每一层进行遍历，找出不同，如图所示。\n\n![img](http://leqikeji.cn/blogImg/diff_demo.png)\n\n**Component Diff** 是数据层面的差异比较\n\n如果都是同一类型的组件(即：两节点是同一个组件类的两个不同实例，比如：<div id=\"before\"></div>与<div id=\"after\"></div>)，按照原策略继续比较Virtual DOM树即可\n\n如果出现不是同一类型的组件，则将该组件判断为dirty component，从而替换整个组件下的所有子节点\n\n**Element Diff**真实DOM渲染，结构差异的比较\n\n首先进行第一层比较，第一层都是R，不发生变化；然后进入第二层Component Diff，发现A组件没有，则删除A及其子组件B、C；最后比较第三层，创建A及其子组件B、C。\n\n当节点处于同一层级时，Diff提供三种DOM操作：**删除**、**移动**、**插入**。\n ![img](http://leqikeji.cn/blogImg/element_diff.png)\n\n如图所示，首先将OldVnode 和 NewVnode的首尾位置分别标记为oldS、oldE、newS、newE。\n\n(1)  oldS和newS相同，不发生变化，oldS++，newS++。\n\n> oldS = a，oldE = d\n>  newS = a, newE = c\n\n(2)  newS与OldVnode不匹配，oldS前面插入f，newS++。\n\n> oldS = b，oldE = d\n>  newS = f， newE = c\n\n(3)  newS与oldE相同，oldE移动到oldS前面，newS++，oldE--。\n\n> oldS = b，oldE = d\n>  newS = d， newE = c\n\n(4)  newE与oldE相同，不发生变化，newE--，oldE--。\n\n> oldS = b，oldE = c\n>  newS = e， newE = c\n\n(5)  都不相同，oldS前插入newE，删除oldS，oldS++，newS++，newE--，oldE--。\n\n> oldS = b，oldE = b\n>  newS = e， newE = e\n\n(6)  oldS > oldE，Diff结束，最后结果为：a、f、d、e、c。\n\n**最后附上核心源码分析：**\n**patch**\n\n```javascript\n\nfunction patch (oldVnode, vnode) {\n    // some code\n    if (sameVnode(oldVnode, vnode)) {\n        patchVnode(oldVnode, vnode)\n    } else {\n        const oEl = oldVnode.el // 当前oldVnode对应的真实元素节点\n        let parentEle = api.parentNode(oEl)  // 父元素\n        createEle(vnode)  // 根据Vnode生成新元素\n        if (parentEle !== null) {\n            api.insertBefore(parentEle, vnode.el, api.nextSibling(oEl)) // 将新元素添加进父元素\n            api.removeChild(parentEle, oldVnode.el)  // 移除以前的旧元素节点\n            oldVnode = null\n        }\n    }\n    // some code \n    return vnode\n}\n\npatchVnode (oldVnode, vnode) {\n    const el = vnode.el = oldVnode.el\n    let i, oldCh = oldVnode.children, ch = vnode.children\n    if (oldVnode === vnode) return\n    if (oldVnode.text !== null && vnode.text !== null && oldVnode.text !== vnode.text) {\n        api.setTextContent(el, vnode.text)\n    }else {\n        updateEle(el, vnode, oldVnode)\n        if (oldCh && ch && oldCh !== ch) {\n            updateChildren(el, oldCh, ch)\n        }else if (ch){\n            createEle(vnode) //create el's children dom\n        }else if (oldCh){\n            api.removeChildren(el)\n        }\n    }\n}\n```\n\n这个函数做了以下事情：\n\n- 找到对应的真实dom，称为el\n- 判断Vnode和oldVnode是否指向同一个对象，如果是，那么直接return\n- 如果他们都有文本节点并且不相等，那么将el的文本节点设置为Vnode的文本节点。\n- 如果oldVnode有子节点而Vnode没有，则删除el的子节点\n- 如果oldVnode没有子节点而Vnode有，则将Vnode的子节点真实化之后添加到el\n- 如果两者都有子节点，则执行updateChildren函数比较子节点\n\n**updateChildren**\n\n```javascript\nfunction updateChildren (parentElm, oldCh, newCh, insertedVnodeQueue, removeOnly) {\n    var oldStartIdx = 0;\n    var newStartIdx = 0;\n    var oldEndIdx = oldCh.length - 1;\n    var oldStartVnode = oldCh[0];\n    var oldEndVnode = oldCh[oldEndIdx];\n    var newEndIdx = newCh.length - 1;\n    var newStartVnode = newCh[0];\n    var newEndVnode = newCh[newEndIdx];\n    var oldKeyToIdx, idxInOld, vnodeToMove, refElm;\n\n    var canMove = !removeOnly;\n    {\n        checkDuplicateKeys(newCh);\n    }\n    // oldVnode起始位置小于结束位置并且newVnode起始位置小于结束位置\n    while (oldStartIdx <= oldEndIdx && newStartIdx <= newEndIdx) {\n        // isUndef 用来判断对象是否等于undefined或者为空，是的话返回true\n        if (isUndef(oldStartVnode)) {\n            // oldVnode 起始位置oldS++\n            oldStartVnode = oldCh[++oldStartIdx]; // Vnode has been moved left\n        } else if (isUndef(oldEndVnode)) {\n            // oldVnode 结束位置oldE--\n            oldEndVnode = oldCh[--oldEndIdx];\n        } else if (sameVnode(oldStartVnode, newStartVnode)) {\n            // oldS和newS相同，不变化，进行patch，oldS++，newS++\n            patchVnode(oldStartVnode, newStartVnode, insertedVnodeQueue, newCh, newStartIdx);\n            oldStartVnode = oldCh[++oldStartIdx];\n            newStartVnode = newCh[++newStartIdx];\n        } else if (sameVnode(oldEndVnode, newEndVnode)) {\n            // oldE和newE相同，不变化，进行patch，oldE--，newE--\n            patchVnode(oldEndVnode, newEndVnode, insertedVnodeQueue, newCh, newEndIdx);\n            oldEndVnode = oldCh[--oldEndIdx];\n            newEndVnode = newCh[--newEndIdx];\n        } else if (sameVnode(oldStartVnode, newEndVnode)) { // Vnode moved right\n            // oldS和newE相同，oldS移动到oldE之后，进行patch，oldS++，newE--\n            patchVnode(oldStartVnode, newEndVnode, insertedVnodeQueue, newCh, newEndIdx);\n            canMove && nodeOps.insertBefore(parentElm, oldStartVnode.elm, nodeOps.nextSibling(oldEndVnode.elm));\n            oldStartVnode = oldCh[++oldStartIdx];\n            newEndVnode = newCh[--newEndIdx];\n        } else if (sameVnode(oldEndVnode, newStartVnode)) { // Vnode moved left\n            // oldE和newS相同，oldE移动到oldS之前，进行patch，oldE--，newS++\n            patchVnode(oldEndVnode, newStartVnode, insertedVnodeQueue, newCh, newStartIdx);\n            canMove && nodeOps.insertBefore(parentElm, oldEndVnode.elm, oldStartVnode.elm);\n            oldEndVnode = oldCh[--oldEndIdx];\n            newStartVnode = newCh[++newStartIdx];\n        } else {\n            // 全都不相同情况下\n            // 获取oldVnode->index的key\n            if (isUndef(oldKeyToIdx)) {\n                oldKeyToIdx = createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx); \n            }\n            idxInOld = isDef(newStartVnode.key)\n              ? oldKeyToIdx[newStartVnode.key]\n              : findIdxInOld(newStartVnode, oldCh, oldStartIdx, oldEndIdx);\n            if (isUndef(idxInOld)) { // New element\n                // oldVnode->index为undefined或null，说明没有该元素，创建新的元素\n                createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm, false, newCh, newStartIdx);\n            } else {\n                  // 获取oldVnode\n                  vnodeToMove = oldCh[idxInOld];\n                  if (sameVnode(vnodeToMove, newStartVnode)) {\n                      // 创建的Vnode和newS相同，插入到oldS之前，进行patch\n                      patchVnode(vnodeToMove, newStartVnode, insertedVnodeQueue, newCh, newStartIdx);\n                      oldCh[idxInOld] = undefined;\n                      canMove && nodeOps.insertBefore(parentElm, vnodeToMove.elm, oldStartVnode.elm);\n                  } else {\n                      // 相同的key但是不一样的element. 被视为新的element\n                      createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm, false, newCh, newStartIdx);\n                  }\n            }\n            newStartVnode = newCh[++newStartIdx];\n        }\n    }\n    // 当oldS>oldE时，将newS至newE间的全部插入\n    if (oldStartIdx > oldEndIdx) {\n        refElm = isUndef(newCh[newEndIdx + 1]) ? null : newCh[newEndIdx + 1].elm;\n        addVnodes(parentElm, refElm, newCh, newStartIdx, newEndIdx, insertedVnodeQueue);\n    } else if (newStartIdx > newEndIdx) {\n        // 当newS>newE，将oldS至oldE间的全部删除\n        removeVnodes(parentElm, oldCh, oldStartIdx, oldEndIdx);\n    }\n}\n```\n\n","slug":"diff","published":1,"updated":"2019-12-25T03:34:10.428Z","_id":"ck4kqm47600050w9mxclgtwqp","comments":1,"layout":"post","photos":[],"link":"","content":"<h4 id=\"Diff三种策略\"><a href=\"#Diff三种策略\" class=\"headerlink\" title=\"Diff三种策略\"></a>Diff三种策略</h4><p><img src=\"http://leqikeji.cn/blogImg/diff.png\" alt=\"img\"></p>\n<p>Diff算法的作用是用来计算出 <strong>Virtual DOM</strong> 中被改变的部分，然后针对该部分进行原生DOM操作，而不用重新渲染整个页面。<br><a id=\"more\"></a><br>Diff算法有三大策略：</p>\n<blockquote>\n<ol>\n<li>Tree Diff</li>\n<li>Component Diff</li>\n<li>Element Diff</li>\n</ol>\n</blockquote>\n<p>三种策略的执行顺序也是顺序依次执行。<br><strong>Tree Diff</strong> 是对树每一层进行遍历，找出不同，如图所示。</p>\n<p><img src=\"http://leqikeji.cn/blogImg/diff_demo.png\" alt=\"img\"></p>\n<p><strong>Component Diff</strong> 是数据层面的差异比较</p>\n<p>如果都是同一类型的组件(即：两节点是同一个组件类的两个不同实例，比如：<div id=\"before\"></div>与<div id=\"after\"></div>)，按照原策略继续比较Virtual DOM树即可</p>\n<p>如果出现不是同一类型的组件，则将该组件判断为dirty component，从而替换整个组件下的所有子节点</p>\n<p><strong>Element Diff</strong>真实DOM渲染，结构差异的比较</p>\n<p>首先进行第一层比较，第一层都是R，不发生变化；然后进入第二层Component Diff，发现A组件没有，则删除A及其子组件B、C；最后比较第三层，创建A及其子组件B、C。</p>\n<p>当节点处于同一层级时，Diff提供三种DOM操作：<strong>删除</strong>、<strong>移动</strong>、<strong>插入</strong>。<br> <img src=\"http://leqikeji.cn/blogImg/element_diff.png\" alt=\"img\"></p>\n<p>如图所示，首先将OldVnode 和 NewVnode的首尾位置分别标记为oldS、oldE、newS、newE。</p>\n<p>(1)  oldS和newS相同，不发生变化，oldS++，newS++。</p>\n<blockquote>\n<p>oldS = a，oldE = d<br> newS = a, newE = c</p>\n</blockquote>\n<p>(2)  newS与OldVnode不匹配，oldS前面插入f，newS++。</p>\n<blockquote>\n<p>oldS = b，oldE = d<br> newS = f， newE = c</p>\n</blockquote>\n<p>(3)  newS与oldE相同，oldE移动到oldS前面，newS++，oldE–。</p>\n<blockquote>\n<p>oldS = b，oldE = d<br> newS = d， newE = c</p>\n</blockquote>\n<p>(4)  newE与oldE相同，不发生变化，newE–，oldE–。</p>\n<blockquote>\n<p>oldS = b，oldE = c<br> newS = e， newE = c</p>\n</blockquote>\n<p>(5)  都不相同，oldS前插入newE，删除oldS，oldS++，newS++，newE–，oldE–。</p>\n<blockquote>\n<p>oldS = b，oldE = b<br> newS = e， newE = e</p>\n</blockquote>\n<p>(6)  oldS &gt; oldE，Diff结束，最后结果为：a、f、d、e、c。</p>\n<p><strong>最后附上核心源码分析：</strong><br><strong>patch</strong></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">patch</span> (<span class=\"params\">oldVnode, vnode</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// some code</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (sameVnode(oldVnode, vnode)) &#123;</span><br><span class=\"line\">        patchVnode(oldVnode, vnode)</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">const</span> oEl = oldVnode.el <span class=\"comment\">// 当前oldVnode对应的真实元素节点</span></span><br><span class=\"line\">        <span class=\"keyword\">let</span> parentEle = api.parentNode(oEl)  <span class=\"comment\">// 父元素</span></span><br><span class=\"line\">        createEle(vnode)  <span class=\"comment\">// 根据Vnode生成新元素</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (parentEle !== <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">            api.insertBefore(parentEle, vnode.el, api.nextSibling(oEl)) <span class=\"comment\">// 将新元素添加进父元素</span></span><br><span class=\"line\">            api.removeChild(parentEle, oldVnode.el)  <span class=\"comment\">// 移除以前的旧元素节点</span></span><br><span class=\"line\">            oldVnode = <span class=\"literal\">null</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// some code </span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> vnode</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">patchVnode (oldVnode, vnode) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> el = vnode.el = oldVnode.el</span><br><span class=\"line\">    <span class=\"keyword\">let</span> i, oldCh = oldVnode.children, ch = vnode.children</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (oldVnode === vnode) <span class=\"keyword\">return</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (oldVnode.text !== <span class=\"literal\">null</span> &amp;&amp; vnode.text !== <span class=\"literal\">null</span> &amp;&amp; oldVnode.text !== vnode.text) &#123;</span><br><span class=\"line\">        api.setTextContent(el, vnode.text)</span><br><span class=\"line\">    &#125;<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        updateEle(el, vnode, oldVnode)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (oldCh &amp;&amp; ch &amp;&amp; oldCh !== ch) &#123;</span><br><span class=\"line\">            updateChildren(el, oldCh, ch)</span><br><span class=\"line\">        &#125;<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (ch)&#123;</span><br><span class=\"line\">            createEle(vnode) <span class=\"comment\">//create el's children dom</span></span><br><span class=\"line\">        &#125;<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (oldCh)&#123;</span><br><span class=\"line\">            api.removeChildren(el)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这个函数做了以下事情：</p>\n<ul>\n<li>找到对应的真实dom，称为el</li>\n<li>判断Vnode和oldVnode是否指向同一个对象，如果是，那么直接return</li>\n<li>如果他们都有文本节点并且不相等，那么将el的文本节点设置为Vnode的文本节点。</li>\n<li>如果oldVnode有子节点而Vnode没有，则删除el的子节点</li>\n<li>如果oldVnode没有子节点而Vnode有，则将Vnode的子节点真实化之后添加到el</li>\n<li>如果两者都有子节点，则执行updateChildren函数比较子节点</li>\n</ul>\n<p><strong>updateChildren</strong></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">updateChildren</span> (<span class=\"params\">parentElm, oldCh, newCh, insertedVnodeQueue, removeOnly</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> oldStartIdx = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> newStartIdx = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> oldEndIdx = oldCh.length - <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> oldStartVnode = oldCh[<span class=\"number\">0</span>];</span><br><span class=\"line\">    <span class=\"keyword\">var</span> oldEndVnode = oldCh[oldEndIdx];</span><br><span class=\"line\">    <span class=\"keyword\">var</span> newEndIdx = newCh.length - <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> newStartVnode = newCh[<span class=\"number\">0</span>];</span><br><span class=\"line\">    <span class=\"keyword\">var</span> newEndVnode = newCh[newEndIdx];</span><br><span class=\"line\">    <span class=\"keyword\">var</span> oldKeyToIdx, idxInOld, vnodeToMove, refElm;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">var</span> canMove = !removeOnly;</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        checkDuplicateKeys(newCh);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// oldVnode起始位置小于结束位置并且newVnode起始位置小于结束位置</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (oldStartIdx &lt;= oldEndIdx &amp;&amp; newStartIdx &lt;= newEndIdx) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// isUndef 用来判断对象是否等于undefined或者为空，是的话返回true</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (isUndef(oldStartVnode)) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// oldVnode 起始位置oldS++</span></span><br><span class=\"line\">            oldStartVnode = oldCh[++oldStartIdx]; <span class=\"comment\">// Vnode has been moved left</span></span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (isUndef(oldEndVnode)) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// oldVnode 结束位置oldE--</span></span><br><span class=\"line\">            oldEndVnode = oldCh[--oldEndIdx];</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (sameVnode(oldStartVnode, newStartVnode)) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// oldS和newS相同，不变化，进行patch，oldS++，newS++</span></span><br><span class=\"line\">            patchVnode(oldStartVnode, newStartVnode, insertedVnodeQueue, newCh, newStartIdx);</span><br><span class=\"line\">            oldStartVnode = oldCh[++oldStartIdx];</span><br><span class=\"line\">            newStartVnode = newCh[++newStartIdx];</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (sameVnode(oldEndVnode, newEndVnode)) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// oldE和newE相同，不变化，进行patch，oldE--，newE--</span></span><br><span class=\"line\">            patchVnode(oldEndVnode, newEndVnode, insertedVnodeQueue, newCh, newEndIdx);</span><br><span class=\"line\">            oldEndVnode = oldCh[--oldEndIdx];</span><br><span class=\"line\">            newEndVnode = newCh[--newEndIdx];</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (sameVnode(oldStartVnode, newEndVnode)) &#123; <span class=\"comment\">// Vnode moved right</span></span><br><span class=\"line\">            <span class=\"comment\">// oldS和newE相同，oldS移动到oldE之后，进行patch，oldS++，newE--</span></span><br><span class=\"line\">            patchVnode(oldStartVnode, newEndVnode, insertedVnodeQueue, newCh, newEndIdx);</span><br><span class=\"line\">            canMove &amp;&amp; nodeOps.insertBefore(parentElm, oldStartVnode.elm, nodeOps.nextSibling(oldEndVnode.elm));</span><br><span class=\"line\">            oldStartVnode = oldCh[++oldStartIdx];</span><br><span class=\"line\">            newEndVnode = newCh[--newEndIdx];</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (sameVnode(oldEndVnode, newStartVnode)) &#123; <span class=\"comment\">// Vnode moved left</span></span><br><span class=\"line\">            <span class=\"comment\">// oldE和newS相同，oldE移动到oldS之前，进行patch，oldE--，newS++</span></span><br><span class=\"line\">            patchVnode(oldEndVnode, newStartVnode, insertedVnodeQueue, newCh, newStartIdx);</span><br><span class=\"line\">            canMove &amp;&amp; nodeOps.insertBefore(parentElm, oldEndVnode.elm, oldStartVnode.elm);</span><br><span class=\"line\">            oldEndVnode = oldCh[--oldEndIdx];</span><br><span class=\"line\">            newStartVnode = newCh[++newStartIdx];</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 全都不相同情况下</span></span><br><span class=\"line\">            <span class=\"comment\">// 获取oldVnode-&gt;index的key</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (isUndef(oldKeyToIdx)) &#123;</span><br><span class=\"line\">                oldKeyToIdx = createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx); </span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            idxInOld = isDef(newStartVnode.key)</span><br><span class=\"line\">              ? oldKeyToIdx[newStartVnode.key]</span><br><span class=\"line\">              : findIdxInOld(newStartVnode, oldCh, oldStartIdx, oldEndIdx);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (isUndef(idxInOld)) &#123; <span class=\"comment\">// New element</span></span><br><span class=\"line\">                <span class=\"comment\">// oldVnode-&gt;index为undefined或null，说明没有该元素，创建新的元素</span></span><br><span class=\"line\">                createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm, <span class=\"literal\">false</span>, newCh, newStartIdx);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                  <span class=\"comment\">// 获取oldVnode</span></span><br><span class=\"line\">                  vnodeToMove = oldCh[idxInOld];</span><br><span class=\"line\">                  <span class=\"keyword\">if</span> (sameVnode(vnodeToMove, newStartVnode)) &#123;</span><br><span class=\"line\">                      <span class=\"comment\">// 创建的Vnode和newS相同，插入到oldS之前，进行patch</span></span><br><span class=\"line\">                      patchVnode(vnodeToMove, newStartVnode, insertedVnodeQueue, newCh, newStartIdx);</span><br><span class=\"line\">                      oldCh[idxInOld] = <span class=\"literal\">undefined</span>;</span><br><span class=\"line\">                      canMove &amp;&amp; nodeOps.insertBefore(parentElm, vnodeToMove.elm, oldStartVnode.elm);</span><br><span class=\"line\">                  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                      <span class=\"comment\">// 相同的key但是不一样的element. 被视为新的element</span></span><br><span class=\"line\">                      createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm, <span class=\"literal\">false</span>, newCh, newStartIdx);</span><br><span class=\"line\">                  &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            newStartVnode = newCh[++newStartIdx];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 当oldS&gt;oldE时，将newS至newE间的全部插入</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (oldStartIdx &gt; oldEndIdx) &#123;</span><br><span class=\"line\">        refElm = isUndef(newCh[newEndIdx + <span class=\"number\">1</span>]) ? <span class=\"literal\">null</span> : newCh[newEndIdx + <span class=\"number\">1</span>].elm;</span><br><span class=\"line\">        addVnodes(parentElm, refElm, newCh, newStartIdx, newEndIdx, insertedVnodeQueue);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (newStartIdx &gt; newEndIdx) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 当newS&gt;newE，将oldS至oldE间的全部删除</span></span><br><span class=\"line\">        removeVnodes(parentElm, oldCh, oldStartIdx, oldEndIdx);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"<h4 id=\"Diff三种策略\"><a href=\"#Diff三种策略\" class=\"headerlink\" title=\"Diff三种策略\"></a>Diff三种策略</h4><p><img src=\"http://leqikeji.cn/blogImg/diff.png\" alt=\"img\"></p>\n<p>Diff算法的作用是用来计算出 <strong>Virtual DOM</strong> 中被改变的部分，然后针对该部分进行原生DOM操作，而不用重新渲染整个页面。<br>","more":"<br>Diff算法有三大策略：</p>\n<blockquote>\n<ol>\n<li>Tree Diff</li>\n<li>Component Diff</li>\n<li>Element Diff</li>\n</ol>\n</blockquote>\n<p>三种策略的执行顺序也是顺序依次执行。<br><strong>Tree Diff</strong> 是对树每一层进行遍历，找出不同，如图所示。</p>\n<p><img src=\"http://leqikeji.cn/blogImg/diff_demo.png\" alt=\"img\"></p>\n<p><strong>Component Diff</strong> 是数据层面的差异比较</p>\n<p>如果都是同一类型的组件(即：两节点是同一个组件类的两个不同实例，比如：<div id=\"before\"></div>与<div id=\"after\"></div>)，按照原策略继续比较Virtual DOM树即可</p>\n<p>如果出现不是同一类型的组件，则将该组件判断为dirty component，从而替换整个组件下的所有子节点</p>\n<p><strong>Element Diff</strong>真实DOM渲染，结构差异的比较</p>\n<p>首先进行第一层比较，第一层都是R，不发生变化；然后进入第二层Component Diff，发现A组件没有，则删除A及其子组件B、C；最后比较第三层，创建A及其子组件B、C。</p>\n<p>当节点处于同一层级时，Diff提供三种DOM操作：<strong>删除</strong>、<strong>移动</strong>、<strong>插入</strong>。<br> <img src=\"http://leqikeji.cn/blogImg/element_diff.png\" alt=\"img\"></p>\n<p>如图所示，首先将OldVnode 和 NewVnode的首尾位置分别标记为oldS、oldE、newS、newE。</p>\n<p>(1)  oldS和newS相同，不发生变化，oldS++，newS++。</p>\n<blockquote>\n<p>oldS = a，oldE = d<br> newS = a, newE = c</p>\n</blockquote>\n<p>(2)  newS与OldVnode不匹配，oldS前面插入f，newS++。</p>\n<blockquote>\n<p>oldS = b，oldE = d<br> newS = f， newE = c</p>\n</blockquote>\n<p>(3)  newS与oldE相同，oldE移动到oldS前面，newS++，oldE–。</p>\n<blockquote>\n<p>oldS = b，oldE = d<br> newS = d， newE = c</p>\n</blockquote>\n<p>(4)  newE与oldE相同，不发生变化，newE–，oldE–。</p>\n<blockquote>\n<p>oldS = b，oldE = c<br> newS = e， newE = c</p>\n</blockquote>\n<p>(5)  都不相同，oldS前插入newE，删除oldS，oldS++，newS++，newE–，oldE–。</p>\n<blockquote>\n<p>oldS = b，oldE = b<br> newS = e， newE = e</p>\n</blockquote>\n<p>(6)  oldS &gt; oldE，Diff结束，最后结果为：a、f、d、e、c。</p>\n<p><strong>最后附上核心源码分析：</strong><br><strong>patch</strong></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">patch</span> (<span class=\"params\">oldVnode, vnode</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// some code</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (sameVnode(oldVnode, vnode)) &#123;</span><br><span class=\"line\">        patchVnode(oldVnode, vnode)</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">const</span> oEl = oldVnode.el <span class=\"comment\">// 当前oldVnode对应的真实元素节点</span></span><br><span class=\"line\">        <span class=\"keyword\">let</span> parentEle = api.parentNode(oEl)  <span class=\"comment\">// 父元素</span></span><br><span class=\"line\">        createEle(vnode)  <span class=\"comment\">// 根据Vnode生成新元素</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (parentEle !== <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">            api.insertBefore(parentEle, vnode.el, api.nextSibling(oEl)) <span class=\"comment\">// 将新元素添加进父元素</span></span><br><span class=\"line\">            api.removeChild(parentEle, oldVnode.el)  <span class=\"comment\">// 移除以前的旧元素节点</span></span><br><span class=\"line\">            oldVnode = <span class=\"literal\">null</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// some code </span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> vnode</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">patchVnode (oldVnode, vnode) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> el = vnode.el = oldVnode.el</span><br><span class=\"line\">    <span class=\"keyword\">let</span> i, oldCh = oldVnode.children, ch = vnode.children</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (oldVnode === vnode) <span class=\"keyword\">return</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (oldVnode.text !== <span class=\"literal\">null</span> &amp;&amp; vnode.text !== <span class=\"literal\">null</span> &amp;&amp; oldVnode.text !== vnode.text) &#123;</span><br><span class=\"line\">        api.setTextContent(el, vnode.text)</span><br><span class=\"line\">    &#125;<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        updateEle(el, vnode, oldVnode)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (oldCh &amp;&amp; ch &amp;&amp; oldCh !== ch) &#123;</span><br><span class=\"line\">            updateChildren(el, oldCh, ch)</span><br><span class=\"line\">        &#125;<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (ch)&#123;</span><br><span class=\"line\">            createEle(vnode) <span class=\"comment\">//create el's children dom</span></span><br><span class=\"line\">        &#125;<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (oldCh)&#123;</span><br><span class=\"line\">            api.removeChildren(el)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这个函数做了以下事情：</p>\n<ul>\n<li>找到对应的真实dom，称为el</li>\n<li>判断Vnode和oldVnode是否指向同一个对象，如果是，那么直接return</li>\n<li>如果他们都有文本节点并且不相等，那么将el的文本节点设置为Vnode的文本节点。</li>\n<li>如果oldVnode有子节点而Vnode没有，则删除el的子节点</li>\n<li>如果oldVnode没有子节点而Vnode有，则将Vnode的子节点真实化之后添加到el</li>\n<li>如果两者都有子节点，则执行updateChildren函数比较子节点</li>\n</ul>\n<p><strong>updateChildren</strong></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">updateChildren</span> (<span class=\"params\">parentElm, oldCh, newCh, insertedVnodeQueue, removeOnly</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> oldStartIdx = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> newStartIdx = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> oldEndIdx = oldCh.length - <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> oldStartVnode = oldCh[<span class=\"number\">0</span>];</span><br><span class=\"line\">    <span class=\"keyword\">var</span> oldEndVnode = oldCh[oldEndIdx];</span><br><span class=\"line\">    <span class=\"keyword\">var</span> newEndIdx = newCh.length - <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> newStartVnode = newCh[<span class=\"number\">0</span>];</span><br><span class=\"line\">    <span class=\"keyword\">var</span> newEndVnode = newCh[newEndIdx];</span><br><span class=\"line\">    <span class=\"keyword\">var</span> oldKeyToIdx, idxInOld, vnodeToMove, refElm;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">var</span> canMove = !removeOnly;</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        checkDuplicateKeys(newCh);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// oldVnode起始位置小于结束位置并且newVnode起始位置小于结束位置</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (oldStartIdx &lt;= oldEndIdx &amp;&amp; newStartIdx &lt;= newEndIdx) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// isUndef 用来判断对象是否等于undefined或者为空，是的话返回true</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (isUndef(oldStartVnode)) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// oldVnode 起始位置oldS++</span></span><br><span class=\"line\">            oldStartVnode = oldCh[++oldStartIdx]; <span class=\"comment\">// Vnode has been moved left</span></span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (isUndef(oldEndVnode)) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// oldVnode 结束位置oldE--</span></span><br><span class=\"line\">            oldEndVnode = oldCh[--oldEndIdx];</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (sameVnode(oldStartVnode, newStartVnode)) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// oldS和newS相同，不变化，进行patch，oldS++，newS++</span></span><br><span class=\"line\">            patchVnode(oldStartVnode, newStartVnode, insertedVnodeQueue, newCh, newStartIdx);</span><br><span class=\"line\">            oldStartVnode = oldCh[++oldStartIdx];</span><br><span class=\"line\">            newStartVnode = newCh[++newStartIdx];</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (sameVnode(oldEndVnode, newEndVnode)) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// oldE和newE相同，不变化，进行patch，oldE--，newE--</span></span><br><span class=\"line\">            patchVnode(oldEndVnode, newEndVnode, insertedVnodeQueue, newCh, newEndIdx);</span><br><span class=\"line\">            oldEndVnode = oldCh[--oldEndIdx];</span><br><span class=\"line\">            newEndVnode = newCh[--newEndIdx];</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (sameVnode(oldStartVnode, newEndVnode)) &#123; <span class=\"comment\">// Vnode moved right</span></span><br><span class=\"line\">            <span class=\"comment\">// oldS和newE相同，oldS移动到oldE之后，进行patch，oldS++，newE--</span></span><br><span class=\"line\">            patchVnode(oldStartVnode, newEndVnode, insertedVnodeQueue, newCh, newEndIdx);</span><br><span class=\"line\">            canMove &amp;&amp; nodeOps.insertBefore(parentElm, oldStartVnode.elm, nodeOps.nextSibling(oldEndVnode.elm));</span><br><span class=\"line\">            oldStartVnode = oldCh[++oldStartIdx];</span><br><span class=\"line\">            newEndVnode = newCh[--newEndIdx];</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (sameVnode(oldEndVnode, newStartVnode)) &#123; <span class=\"comment\">// Vnode moved left</span></span><br><span class=\"line\">            <span class=\"comment\">// oldE和newS相同，oldE移动到oldS之前，进行patch，oldE--，newS++</span></span><br><span class=\"line\">            patchVnode(oldEndVnode, newStartVnode, insertedVnodeQueue, newCh, newStartIdx);</span><br><span class=\"line\">            canMove &amp;&amp; nodeOps.insertBefore(parentElm, oldEndVnode.elm, oldStartVnode.elm);</span><br><span class=\"line\">            oldEndVnode = oldCh[--oldEndIdx];</span><br><span class=\"line\">            newStartVnode = newCh[++newStartIdx];</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 全都不相同情况下</span></span><br><span class=\"line\">            <span class=\"comment\">// 获取oldVnode-&gt;index的key</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (isUndef(oldKeyToIdx)) &#123;</span><br><span class=\"line\">                oldKeyToIdx = createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx); </span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            idxInOld = isDef(newStartVnode.key)</span><br><span class=\"line\">              ? oldKeyToIdx[newStartVnode.key]</span><br><span class=\"line\">              : findIdxInOld(newStartVnode, oldCh, oldStartIdx, oldEndIdx);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (isUndef(idxInOld)) &#123; <span class=\"comment\">// New element</span></span><br><span class=\"line\">                <span class=\"comment\">// oldVnode-&gt;index为undefined或null，说明没有该元素，创建新的元素</span></span><br><span class=\"line\">                createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm, <span class=\"literal\">false</span>, newCh, newStartIdx);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                  <span class=\"comment\">// 获取oldVnode</span></span><br><span class=\"line\">                  vnodeToMove = oldCh[idxInOld];</span><br><span class=\"line\">                  <span class=\"keyword\">if</span> (sameVnode(vnodeToMove, newStartVnode)) &#123;</span><br><span class=\"line\">                      <span class=\"comment\">// 创建的Vnode和newS相同，插入到oldS之前，进行patch</span></span><br><span class=\"line\">                      patchVnode(vnodeToMove, newStartVnode, insertedVnodeQueue, newCh, newStartIdx);</span><br><span class=\"line\">                      oldCh[idxInOld] = <span class=\"literal\">undefined</span>;</span><br><span class=\"line\">                      canMove &amp;&amp; nodeOps.insertBefore(parentElm, vnodeToMove.elm, oldStartVnode.elm);</span><br><span class=\"line\">                  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                      <span class=\"comment\">// 相同的key但是不一样的element. 被视为新的element</span></span><br><span class=\"line\">                      createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm, <span class=\"literal\">false</span>, newCh, newStartIdx);</span><br><span class=\"line\">                  &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            newStartVnode = newCh[++newStartIdx];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 当oldS&gt;oldE时，将newS至newE间的全部插入</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (oldStartIdx &gt; oldEndIdx) &#123;</span><br><span class=\"line\">        refElm = isUndef(newCh[newEndIdx + <span class=\"number\">1</span>]) ? <span class=\"literal\">null</span> : newCh[newEndIdx + <span class=\"number\">1</span>].elm;</span><br><span class=\"line\">        addVnodes(parentElm, refElm, newCh, newStartIdx, newEndIdx, insertedVnodeQueue);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (newStartIdx &gt; newEndIdx) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 当newS&gt;newE，将oldS至oldE间的全部删除</span></span><br><span class=\"line\">        removeVnodes(parentElm, oldCh, oldStartIdx, oldEndIdx);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>"},{"title":"DFS和BFS小结","date":"2020-04-08T08:40:32.000Z","_content":"\n**DFS（Deep First Search）深度优先遍历。**\n\n**BFS（Breath First Search）广度优先遍历。**\n<!-- more -->\n\n## 1.DFS（深度优先遍历）\n\n**深度优先遍历的步骤分为 1.递归下去 2.回溯上来。顾名思义，深度优先，则是以深度为准则，先一条路走到底，直到达到目标。**\n\n**否则既没有达到目标又无路可走了，那么则退回到上一步的状态，走其他路。这便是回溯上来。**\n\n##### DFS模板\n\n```javascript\nfunction dfs() {\n    if(到达终点状态)  {  \n        //... 根据题意添加  \n        return;  \n    }  \n    if(越界或者是不合法状态)  \n        return;  \n    if(特殊状态)//剪枝\n        return ;\n    for(扩展方式)  {  \n        if(扩展方式所达到状态合法)  {  \n            修改操作;//根据题意来添加  \n            标记；  \n            dfs（）；  \n            (还原标记)；  \n            //是否还原标记根据题意  \n            //如果加上（还原标记）就是 回溯法  \n        }  \n    }  \n}  \n```\n\n## 2.BFS（广度优先遍历）\n\n广度优先遍历较之深度优先遍历之不同在于，深度优先遍历旨在不管有多少条岔路，先一条路走到底，不成功就返回上一个路口然后就选择下一条岔路，而广度优先遍历旨在面临一个路口时，把所有的岔路口都记下来，然后选择其中一个进入，然后将它的分路情况记录下来，然后再返回来进入另外一个岔路，并重复这样的操作\n\n##### BFS模板\n\n```javascript\nfunction BFS(s) {\n    let queue = [s];\n    while(queue.length) {\n        const top = queue.shift()\n        //取出队首元素top并出队;    \n        //...\n        //访问队首元素top操作;\n        //将top的下一层结点中未曾入队的结点全部入队，并设置为已入队; \n    }\n} \n```\n\n## 3. 案例\n\n#### 3.1机器人的运动范围\n\n地上有一个m行n列的方格，从坐标 [0,0] 到坐标 [m-1,n-1] 。一个机器人从坐标 [0, 0] 的格子开始移动，它每次可以向左、右、上、下移动一格（不能移动到方格外），也不能进入行坐标和列坐标的数位之和大于k的格子。例如，当k为18时，机器人能够进入方格 [35, 37] ，因为3+5+3+7=18。但它不能进入方格 [35, 38]，因为3+5+3+8=19。请问该机器人能够到达多少个格子？\n\n示例 1：\n\n> 输入：m = 2, n = 3, k = 1\n> 输出：3\n\n示例 2：\n\n> 输入：m = 3, n = 1, k = 0\n> 输出：1\n\n提示：\n\n> 1 <= n,m <= 100\n> 0 <= k <= 20\n\n**思路：**如果我们直接遍历检查所有的点，取出满足数位相加之和的条件，机器人不一定可以达到。例如当 m=38，n=15，k=9 时，由于只能向合法坐标移动 1 格，从`(18,0)`并不能到达`(20, 0)`，即使`(20, 0)`满足数位之和的条件。\n\n所以我们应当采用DFS或者BFS的思想来处理\n\n##### 解法1 DFS\n\n```javascript\nconst bitSum = (num) => String(num).split('').reduce((_t, _n)=> (Number(_t) + Number(_n)), 0)\n\nvar movingCount = function(m, n, k) {\n    let res = 0;\n    const directions = [\n        [-1, 0],\n        [1, 0],\n        [0, -1],\n        [0, 1]\n    ];\n    const visited = {};\n    dfs(0, 0);\n    return res;\n\n    function dfs(x, y) {\n        visited[`${x}-${y}`] = true;\n        if (bitSum(x) + bitSum(y) > k) {\n            return;\n        }\n        ++res;\n\n        for (const direction of directions) {\n            const newx = direction[0] + x;\n            const newy = direction[1] + y;\n            if (\n                !visited[`${newx}-${newy}`] &&\n                newx >= 0 &&\n                newy >= 0 &&\n                newx < m &&\n                newy < n\n            ) {\n                dfs(newx, newy);\n            }\n        }\n    }\n};\n```\n\n##### 解法2 BFS\n\n```javascript\nvar movingCount = function(m, n, k) {\n    let res = 0;\n    const directions = [\n        [1, 0],\n        [0, 1]\n    ];\n    const queue = [[0, 0]];\n    const visited = {\n        \"0-0\": true\n    };\n\n    while (queue.length) {\n        const [x, y] = queue.shift();\n        \n        if (bitSum(x) + bitSum(y) > k) {\n            continue;\n        }\n        ++res;\n\n        for (const direction of directions) {\n            const newx = direction[0] + x;\n            const newy = direction[1] + y;\n            if (\n                !visited[`${newx}-${newy}`] &&\n                newx >= 0 &&\n                newy >= 0 &&\n                newx < m &&\n                newy < n\n            ) {\n                queue.push([newx, newy]);\n                visited[`${newx}-${newy}`] = true;\n            }\n        }\n    }\n\n    return res;\n};\n```\n\n\n\n## 4.总结\n\n对于这两个遍历方法，其实我们是可以轻松的看出来，他们有许多差异与许多相同点的。\n\n**1.数据结构上的运用**\n\nDFS用递归的形式，用到了栈结构，先进后出。\n\nBFS选取状态用队列的形式，先进先出。\n\n**2.复杂度**\n\nDFS的复杂度与BFS的复杂度大体一致，不同之处在于遍历的方式与对于问题的解决出发点不同，DFS适合目标明确，而BFS适合大范围的寻找。\n\n**3.思想**\n\n思想上来说这两种方法都是穷竭列举所有的情况。","source":"_posts/DFS和BFS.md","raw":"---\ntitle: DFS和BFS小结\ndate: 2020-04-08 16:40:32\ntags:\n    - dfs\n    - bfs\ncategories:\n    - 技术分享\n\n---\n\n**DFS（Deep First Search）深度优先遍历。**\n\n**BFS（Breath First Search）广度优先遍历。**\n<!-- more -->\n\n## 1.DFS（深度优先遍历）\n\n**深度优先遍历的步骤分为 1.递归下去 2.回溯上来。顾名思义，深度优先，则是以深度为准则，先一条路走到底，直到达到目标。**\n\n**否则既没有达到目标又无路可走了，那么则退回到上一步的状态，走其他路。这便是回溯上来。**\n\n##### DFS模板\n\n```javascript\nfunction dfs() {\n    if(到达终点状态)  {  \n        //... 根据题意添加  \n        return;  \n    }  \n    if(越界或者是不合法状态)  \n        return;  \n    if(特殊状态)//剪枝\n        return ;\n    for(扩展方式)  {  \n        if(扩展方式所达到状态合法)  {  \n            修改操作;//根据题意来添加  \n            标记；  \n            dfs（）；  \n            (还原标记)；  \n            //是否还原标记根据题意  \n            //如果加上（还原标记）就是 回溯法  \n        }  \n    }  \n}  \n```\n\n## 2.BFS（广度优先遍历）\n\n广度优先遍历较之深度优先遍历之不同在于，深度优先遍历旨在不管有多少条岔路，先一条路走到底，不成功就返回上一个路口然后就选择下一条岔路，而广度优先遍历旨在面临一个路口时，把所有的岔路口都记下来，然后选择其中一个进入，然后将它的分路情况记录下来，然后再返回来进入另外一个岔路，并重复这样的操作\n\n##### BFS模板\n\n```javascript\nfunction BFS(s) {\n    let queue = [s];\n    while(queue.length) {\n        const top = queue.shift()\n        //取出队首元素top并出队;    \n        //...\n        //访问队首元素top操作;\n        //将top的下一层结点中未曾入队的结点全部入队，并设置为已入队; \n    }\n} \n```\n\n## 3. 案例\n\n#### 3.1机器人的运动范围\n\n地上有一个m行n列的方格，从坐标 [0,0] 到坐标 [m-1,n-1] 。一个机器人从坐标 [0, 0] 的格子开始移动，它每次可以向左、右、上、下移动一格（不能移动到方格外），也不能进入行坐标和列坐标的数位之和大于k的格子。例如，当k为18时，机器人能够进入方格 [35, 37] ，因为3+5+3+7=18。但它不能进入方格 [35, 38]，因为3+5+3+8=19。请问该机器人能够到达多少个格子？\n\n示例 1：\n\n> 输入：m = 2, n = 3, k = 1\n> 输出：3\n\n示例 2：\n\n> 输入：m = 3, n = 1, k = 0\n> 输出：1\n\n提示：\n\n> 1 <= n,m <= 100\n> 0 <= k <= 20\n\n**思路：**如果我们直接遍历检查所有的点，取出满足数位相加之和的条件，机器人不一定可以达到。例如当 m=38，n=15，k=9 时，由于只能向合法坐标移动 1 格，从`(18,0)`并不能到达`(20, 0)`，即使`(20, 0)`满足数位之和的条件。\n\n所以我们应当采用DFS或者BFS的思想来处理\n\n##### 解法1 DFS\n\n```javascript\nconst bitSum = (num) => String(num).split('').reduce((_t, _n)=> (Number(_t) + Number(_n)), 0)\n\nvar movingCount = function(m, n, k) {\n    let res = 0;\n    const directions = [\n        [-1, 0],\n        [1, 0],\n        [0, -1],\n        [0, 1]\n    ];\n    const visited = {};\n    dfs(0, 0);\n    return res;\n\n    function dfs(x, y) {\n        visited[`${x}-${y}`] = true;\n        if (bitSum(x) + bitSum(y) > k) {\n            return;\n        }\n        ++res;\n\n        for (const direction of directions) {\n            const newx = direction[0] + x;\n            const newy = direction[1] + y;\n            if (\n                !visited[`${newx}-${newy}`] &&\n                newx >= 0 &&\n                newy >= 0 &&\n                newx < m &&\n                newy < n\n            ) {\n                dfs(newx, newy);\n            }\n        }\n    }\n};\n```\n\n##### 解法2 BFS\n\n```javascript\nvar movingCount = function(m, n, k) {\n    let res = 0;\n    const directions = [\n        [1, 0],\n        [0, 1]\n    ];\n    const queue = [[0, 0]];\n    const visited = {\n        \"0-0\": true\n    };\n\n    while (queue.length) {\n        const [x, y] = queue.shift();\n        \n        if (bitSum(x) + bitSum(y) > k) {\n            continue;\n        }\n        ++res;\n\n        for (const direction of directions) {\n            const newx = direction[0] + x;\n            const newy = direction[1] + y;\n            if (\n                !visited[`${newx}-${newy}`] &&\n                newx >= 0 &&\n                newy >= 0 &&\n                newx < m &&\n                newy < n\n            ) {\n                queue.push([newx, newy]);\n                visited[`${newx}-${newy}`] = true;\n            }\n        }\n    }\n\n    return res;\n};\n```\n\n\n\n## 4.总结\n\n对于这两个遍历方法，其实我们是可以轻松的看出来，他们有许多差异与许多相同点的。\n\n**1.数据结构上的运用**\n\nDFS用递归的形式，用到了栈结构，先进后出。\n\nBFS选取状态用队列的形式，先进先出。\n\n**2.复杂度**\n\nDFS的复杂度与BFS的复杂度大体一致，不同之处在于遍历的方式与对于问题的解决出发点不同，DFS适合目标明确，而BFS适合大范围的寻找。\n\n**3.思想**\n\n思想上来说这两种方法都是穷竭列举所有的情况。","slug":"DFS和BFS","published":1,"updated":"2020-04-08T08:47:50.472Z","_id":"ck8r36s7d0000ah9m9anjl3qt","comments":1,"layout":"post","photos":[],"link":"","content":"<p><strong>DFS（Deep First Search）深度优先遍历。</strong></p>\n<p><strong>BFS（Breath First Search）广度优先遍历。</strong><br><a id=\"more\"></a></p>\n<h2 id=\"1-DFS（深度优先遍历）\"><a href=\"#1-DFS（深度优先遍历）\" class=\"headerlink\" title=\"1.DFS（深度优先遍历）\"></a>1.DFS（深度优先遍历）</h2><p><strong>深度优先遍历的步骤分为 1.递归下去 2.回溯上来。顾名思义，深度优先，则是以深度为准则，先一条路走到底，直到达到目标。</strong></p>\n<p><strong>否则既没有达到目标又无路可走了，那么则退回到上一步的状态，走其他路。这便是回溯上来。</strong></p>\n<h5 id=\"DFS模板\"><a href=\"#DFS模板\" class=\"headerlink\" title=\"DFS模板\"></a>DFS模板</h5><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">dfs</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(到达终点状态)  &#123;  </span><br><span class=\"line\">        <span class=\"comment\">//... 根据题意添加  </span></span><br><span class=\"line\">        <span class=\"keyword\">return</span>;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">    <span class=\"keyword\">if</span>(越界或者是不合法状态)  </span><br><span class=\"line\">        <span class=\"keyword\">return</span>;  </span><br><span class=\"line\">    <span class=\"keyword\">if</span>(特殊状态)<span class=\"comment\">//剪枝</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> ;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(扩展方式)  &#123;  </span><br><span class=\"line\">        <span class=\"keyword\">if</span>(扩展方式所达到状态合法)  &#123;  </span><br><span class=\"line\">            修改操作;<span class=\"comment\">//根据题意来添加  </span></span><br><span class=\"line\">            标记；  </span><br><span class=\"line\">            dfs（）；  </span><br><span class=\"line\">            (还原标记)；  </span><br><span class=\"line\">            <span class=\"comment\">//是否还原标记根据题意  </span></span><br><span class=\"line\">            <span class=\"comment\">//如果加上（还原标记）就是 回溯法  </span></span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"2-BFS（广度优先遍历）\"><a href=\"#2-BFS（广度优先遍历）\" class=\"headerlink\" title=\"2.BFS（广度优先遍历）\"></a>2.BFS（广度优先遍历）</h2><p>广度优先遍历较之深度优先遍历之不同在于，深度优先遍历旨在不管有多少条岔路，先一条路走到底，不成功就返回上一个路口然后就选择下一条岔路，而广度优先遍历旨在面临一个路口时，把所有的岔路口都记下来，然后选择其中一个进入，然后将它的分路情况记录下来，然后再返回来进入另外一个岔路，并重复这样的操作</p>\n<h5 id=\"BFS模板\"><a href=\"#BFS模板\" class=\"headerlink\" title=\"BFS模板\"></a>BFS模板</h5><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">BFS</span>(<span class=\"params\">s</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> queue = [s];</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(queue.length) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">const</span> top = queue.shift()</span><br><span class=\"line\">        <span class=\"comment\">//取出队首元素top并出队;    </span></span><br><span class=\"line\">        <span class=\"comment\">//...</span></span><br><span class=\"line\">        <span class=\"comment\">//访问队首元素top操作;</span></span><br><span class=\"line\">        <span class=\"comment\">//将top的下一层结点中未曾入队的结点全部入队，并设置为已入队; </span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"3-案例\"><a href=\"#3-案例\" class=\"headerlink\" title=\"3. 案例\"></a>3. 案例</h2><h4 id=\"3-1机器人的运动范围\"><a href=\"#3-1机器人的运动范围\" class=\"headerlink\" title=\"3.1机器人的运动范围\"></a>3.1机器人的运动范围</h4><p>地上有一个m行n列的方格，从坐标 [0,0] 到坐标 [m-1,n-1] 。一个机器人从坐标 [0, 0] 的格子开始移动，它每次可以向左、右、上、下移动一格（不能移动到方格外），也不能进入行坐标和列坐标的数位之和大于k的格子。例如，当k为18时，机器人能够进入方格 [35, 37] ，因为3+5+3+7=18。但它不能进入方格 [35, 38]，因为3+5+3+8=19。请问该机器人能够到达多少个格子？</p>\n<p>示例 1：</p>\n<blockquote>\n<p>输入：m = 2, n = 3, k = 1<br>输出：3</p>\n</blockquote>\n<p>示例 2：</p>\n<blockquote>\n<p>输入：m = 3, n = 1, k = 0<br>输出：1</p>\n</blockquote>\n<p>提示：</p>\n<blockquote>\n<p>1 &lt;= n,m &lt;= 100<br>0 &lt;= k &lt;= 20</p>\n</blockquote>\n<p><strong>思路：</strong>如果我们直接遍历检查所有的点，取出满足数位相加之和的条件，机器人不一定可以达到。例如当 m=38，n=15，k=9 时，由于只能向合法坐标移动 1 格，从<code>(18,0)</code>并不能到达<code>(20, 0)</code>，即使<code>(20, 0)</code>满足数位之和的条件。</p>\n<p>所以我们应当采用DFS或者BFS的思想来处理</p>\n<h5 id=\"解法1-DFS\"><a href=\"#解法1-DFS\" class=\"headerlink\" title=\"解法1 DFS\"></a>解法1 DFS</h5><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> bitSum = <span class=\"function\">(<span class=\"params\">num</span>) =&gt;</span> <span class=\"built_in\">String</span>(num).split(<span class=\"string\">''</span>).reduce(<span class=\"function\">(<span class=\"params\">_t, _n</span>)=&gt;</span> (<span class=\"built_in\">Number</span>(_t) + <span class=\"built_in\">Number</span>(_n)), <span class=\"number\">0</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> movingCount = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">m, n, k</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> res = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> directions = [</span><br><span class=\"line\">        [<span class=\"number\">-1</span>, <span class=\"number\">0</span>],</span><br><span class=\"line\">        [<span class=\"number\">1</span>, <span class=\"number\">0</span>],</span><br><span class=\"line\">        [<span class=\"number\">0</span>, <span class=\"number\">-1</span>],</span><br><span class=\"line\">        [<span class=\"number\">0</span>, <span class=\"number\">1</span>]</span><br><span class=\"line\">    ];</span><br><span class=\"line\">    <span class=\"keyword\">const</span> visited = &#123;&#125;;</span><br><span class=\"line\">    dfs(<span class=\"number\">0</span>, <span class=\"number\">0</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> res;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">dfs</span>(<span class=\"params\">x, y</span>) </span>&#123;</span><br><span class=\"line\">        visited[<span class=\"string\">`<span class=\"subst\">$&#123;x&#125;</span>-<span class=\"subst\">$&#123;y&#125;</span>`</span>] = <span class=\"literal\">true</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (bitSum(x) + bitSum(y) &gt; k) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        ++res;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">const</span> direction <span class=\"keyword\">of</span> directions) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">const</span> newx = direction[<span class=\"number\">0</span>] + x;</span><br><span class=\"line\">            <span class=\"keyword\">const</span> newy = direction[<span class=\"number\">1</span>] + y;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (</span><br><span class=\"line\">                !visited[<span class=\"string\">`<span class=\"subst\">$&#123;newx&#125;</span>-<span class=\"subst\">$&#123;newy&#125;</span>`</span>] &amp;&amp;</span><br><span class=\"line\">                newx &gt;= <span class=\"number\">0</span> &amp;&amp;</span><br><span class=\"line\">                newy &gt;= <span class=\"number\">0</span> &amp;&amp;</span><br><span class=\"line\">                newx &lt; m &amp;&amp;</span><br><span class=\"line\">                newy &lt; n</span><br><span class=\"line\">            ) &#123;</span><br><span class=\"line\">                dfs(newx, newy);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h5 id=\"解法2-BFS\"><a href=\"#解法2-BFS\" class=\"headerlink\" title=\"解法2 BFS\"></a>解法2 BFS</h5><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> movingCount = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">m, n, k</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> res = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> directions = [</span><br><span class=\"line\">        [<span class=\"number\">1</span>, <span class=\"number\">0</span>],</span><br><span class=\"line\">        [<span class=\"number\">0</span>, <span class=\"number\">1</span>]</span><br><span class=\"line\">    ];</span><br><span class=\"line\">    <span class=\"keyword\">const</span> queue = [[<span class=\"number\">0</span>, <span class=\"number\">0</span>]];</span><br><span class=\"line\">    <span class=\"keyword\">const</span> visited = &#123;</span><br><span class=\"line\">        <span class=\"string\">\"0-0\"</span>: <span class=\"literal\">true</span></span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (queue.length) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">const</span> [x, y] = queue.shift();</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (bitSum(x) + bitSum(y) &gt; k) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        ++res;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">const</span> direction <span class=\"keyword\">of</span> directions) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">const</span> newx = direction[<span class=\"number\">0</span>] + x;</span><br><span class=\"line\">            <span class=\"keyword\">const</span> newy = direction[<span class=\"number\">1</span>] + y;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (</span><br><span class=\"line\">                !visited[<span class=\"string\">`<span class=\"subst\">$&#123;newx&#125;</span>-<span class=\"subst\">$&#123;newy&#125;</span>`</span>] &amp;&amp;</span><br><span class=\"line\">                newx &gt;= <span class=\"number\">0</span> &amp;&amp;</span><br><span class=\"line\">                newy &gt;= <span class=\"number\">0</span> &amp;&amp;</span><br><span class=\"line\">                newx &lt; m &amp;&amp;</span><br><span class=\"line\">                newy &lt; n</span><br><span class=\"line\">            ) &#123;</span><br><span class=\"line\">                queue.push([newx, newy]);</span><br><span class=\"line\">                visited[<span class=\"string\">`<span class=\"subst\">$&#123;newx&#125;</span>-<span class=\"subst\">$&#123;newy&#125;</span>`</span>] = <span class=\"literal\">true</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h2 id=\"4-总结\"><a href=\"#4-总结\" class=\"headerlink\" title=\"4.总结\"></a>4.总结</h2><p>对于这两个遍历方法，其实我们是可以轻松的看出来，他们有许多差异与许多相同点的。</p>\n<p><strong>1.数据结构上的运用</strong></p>\n<p>DFS用递归的形式，用到了栈结构，先进后出。</p>\n<p>BFS选取状态用队列的形式，先进先出。</p>\n<p><strong>2.复杂度</strong></p>\n<p>DFS的复杂度与BFS的复杂度大体一致，不同之处在于遍历的方式与对于问题的解决出发点不同，DFS适合目标明确，而BFS适合大范围的寻找。</p>\n<p><strong>3.思想</strong></p>\n<p>思想上来说这两种方法都是穷竭列举所有的情况。</p>\n","site":{"data":{}},"excerpt":"<p><strong>DFS（Deep First Search）深度优先遍历。</strong></p>\n<p><strong>BFS（Breath First Search）广度优先遍历。</strong><br>","more":"</p>\n<h2 id=\"1-DFS（深度优先遍历）\"><a href=\"#1-DFS（深度优先遍历）\" class=\"headerlink\" title=\"1.DFS（深度优先遍历）\"></a>1.DFS（深度优先遍历）</h2><p><strong>深度优先遍历的步骤分为 1.递归下去 2.回溯上来。顾名思义，深度优先，则是以深度为准则，先一条路走到底，直到达到目标。</strong></p>\n<p><strong>否则既没有达到目标又无路可走了，那么则退回到上一步的状态，走其他路。这便是回溯上来。</strong></p>\n<h5 id=\"DFS模板\"><a href=\"#DFS模板\" class=\"headerlink\" title=\"DFS模板\"></a>DFS模板</h5><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">dfs</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(到达终点状态)  &#123;  </span><br><span class=\"line\">        <span class=\"comment\">//... 根据题意添加  </span></span><br><span class=\"line\">        <span class=\"keyword\">return</span>;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">    <span class=\"keyword\">if</span>(越界或者是不合法状态)  </span><br><span class=\"line\">        <span class=\"keyword\">return</span>;  </span><br><span class=\"line\">    <span class=\"keyword\">if</span>(特殊状态)<span class=\"comment\">//剪枝</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> ;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(扩展方式)  &#123;  </span><br><span class=\"line\">        <span class=\"keyword\">if</span>(扩展方式所达到状态合法)  &#123;  </span><br><span class=\"line\">            修改操作;<span class=\"comment\">//根据题意来添加  </span></span><br><span class=\"line\">            标记；  </span><br><span class=\"line\">            dfs（）；  </span><br><span class=\"line\">            (还原标记)；  </span><br><span class=\"line\">            <span class=\"comment\">//是否还原标记根据题意  </span></span><br><span class=\"line\">            <span class=\"comment\">//如果加上（还原标记）就是 回溯法  </span></span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"2-BFS（广度优先遍历）\"><a href=\"#2-BFS（广度优先遍历）\" class=\"headerlink\" title=\"2.BFS（广度优先遍历）\"></a>2.BFS（广度优先遍历）</h2><p>广度优先遍历较之深度优先遍历之不同在于，深度优先遍历旨在不管有多少条岔路，先一条路走到底，不成功就返回上一个路口然后就选择下一条岔路，而广度优先遍历旨在面临一个路口时，把所有的岔路口都记下来，然后选择其中一个进入，然后将它的分路情况记录下来，然后再返回来进入另外一个岔路，并重复这样的操作</p>\n<h5 id=\"BFS模板\"><a href=\"#BFS模板\" class=\"headerlink\" title=\"BFS模板\"></a>BFS模板</h5><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">BFS</span>(<span class=\"params\">s</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> queue = [s];</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(queue.length) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">const</span> top = queue.shift()</span><br><span class=\"line\">        <span class=\"comment\">//取出队首元素top并出队;    </span></span><br><span class=\"line\">        <span class=\"comment\">//...</span></span><br><span class=\"line\">        <span class=\"comment\">//访问队首元素top操作;</span></span><br><span class=\"line\">        <span class=\"comment\">//将top的下一层结点中未曾入队的结点全部入队，并设置为已入队; </span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"3-案例\"><a href=\"#3-案例\" class=\"headerlink\" title=\"3. 案例\"></a>3. 案例</h2><h4 id=\"3-1机器人的运动范围\"><a href=\"#3-1机器人的运动范围\" class=\"headerlink\" title=\"3.1机器人的运动范围\"></a>3.1机器人的运动范围</h4><p>地上有一个m行n列的方格，从坐标 [0,0] 到坐标 [m-1,n-1] 。一个机器人从坐标 [0, 0] 的格子开始移动，它每次可以向左、右、上、下移动一格（不能移动到方格外），也不能进入行坐标和列坐标的数位之和大于k的格子。例如，当k为18时，机器人能够进入方格 [35, 37] ，因为3+5+3+7=18。但它不能进入方格 [35, 38]，因为3+5+3+8=19。请问该机器人能够到达多少个格子？</p>\n<p>示例 1：</p>\n<blockquote>\n<p>输入：m = 2, n = 3, k = 1<br>输出：3</p>\n</blockquote>\n<p>示例 2：</p>\n<blockquote>\n<p>输入：m = 3, n = 1, k = 0<br>输出：1</p>\n</blockquote>\n<p>提示：</p>\n<blockquote>\n<p>1 &lt;= n,m &lt;= 100<br>0 &lt;= k &lt;= 20</p>\n</blockquote>\n<p><strong>思路：</strong>如果我们直接遍历检查所有的点，取出满足数位相加之和的条件，机器人不一定可以达到。例如当 m=38，n=15，k=9 时，由于只能向合法坐标移动 1 格，从<code>(18,0)</code>并不能到达<code>(20, 0)</code>，即使<code>(20, 0)</code>满足数位之和的条件。</p>\n<p>所以我们应当采用DFS或者BFS的思想来处理</p>\n<h5 id=\"解法1-DFS\"><a href=\"#解法1-DFS\" class=\"headerlink\" title=\"解法1 DFS\"></a>解法1 DFS</h5><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> bitSum = <span class=\"function\">(<span class=\"params\">num</span>) =&gt;</span> <span class=\"built_in\">String</span>(num).split(<span class=\"string\">''</span>).reduce(<span class=\"function\">(<span class=\"params\">_t, _n</span>)=&gt;</span> (<span class=\"built_in\">Number</span>(_t) + <span class=\"built_in\">Number</span>(_n)), <span class=\"number\">0</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> movingCount = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">m, n, k</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> res = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> directions = [</span><br><span class=\"line\">        [<span class=\"number\">-1</span>, <span class=\"number\">0</span>],</span><br><span class=\"line\">        [<span class=\"number\">1</span>, <span class=\"number\">0</span>],</span><br><span class=\"line\">        [<span class=\"number\">0</span>, <span class=\"number\">-1</span>],</span><br><span class=\"line\">        [<span class=\"number\">0</span>, <span class=\"number\">1</span>]</span><br><span class=\"line\">    ];</span><br><span class=\"line\">    <span class=\"keyword\">const</span> visited = &#123;&#125;;</span><br><span class=\"line\">    dfs(<span class=\"number\">0</span>, <span class=\"number\">0</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> res;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">dfs</span>(<span class=\"params\">x, y</span>) </span>&#123;</span><br><span class=\"line\">        visited[<span class=\"string\">`<span class=\"subst\">$&#123;x&#125;</span>-<span class=\"subst\">$&#123;y&#125;</span>`</span>] = <span class=\"literal\">true</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (bitSum(x) + bitSum(y) &gt; k) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        ++res;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">const</span> direction <span class=\"keyword\">of</span> directions) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">const</span> newx = direction[<span class=\"number\">0</span>] + x;</span><br><span class=\"line\">            <span class=\"keyword\">const</span> newy = direction[<span class=\"number\">1</span>] + y;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (</span><br><span class=\"line\">                !visited[<span class=\"string\">`<span class=\"subst\">$&#123;newx&#125;</span>-<span class=\"subst\">$&#123;newy&#125;</span>`</span>] &amp;&amp;</span><br><span class=\"line\">                newx &gt;= <span class=\"number\">0</span> &amp;&amp;</span><br><span class=\"line\">                newy &gt;= <span class=\"number\">0</span> &amp;&amp;</span><br><span class=\"line\">                newx &lt; m &amp;&amp;</span><br><span class=\"line\">                newy &lt; n</span><br><span class=\"line\">            ) &#123;</span><br><span class=\"line\">                dfs(newx, newy);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h5 id=\"解法2-BFS\"><a href=\"#解法2-BFS\" class=\"headerlink\" title=\"解法2 BFS\"></a>解法2 BFS</h5><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> movingCount = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">m, n, k</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> res = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> directions = [</span><br><span class=\"line\">        [<span class=\"number\">1</span>, <span class=\"number\">0</span>],</span><br><span class=\"line\">        [<span class=\"number\">0</span>, <span class=\"number\">1</span>]</span><br><span class=\"line\">    ];</span><br><span class=\"line\">    <span class=\"keyword\">const</span> queue = [[<span class=\"number\">0</span>, <span class=\"number\">0</span>]];</span><br><span class=\"line\">    <span class=\"keyword\">const</span> visited = &#123;</span><br><span class=\"line\">        <span class=\"string\">\"0-0\"</span>: <span class=\"literal\">true</span></span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (queue.length) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">const</span> [x, y] = queue.shift();</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (bitSum(x) + bitSum(y) &gt; k) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        ++res;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">const</span> direction <span class=\"keyword\">of</span> directions) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">const</span> newx = direction[<span class=\"number\">0</span>] + x;</span><br><span class=\"line\">            <span class=\"keyword\">const</span> newy = direction[<span class=\"number\">1</span>] + y;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (</span><br><span class=\"line\">                !visited[<span class=\"string\">`<span class=\"subst\">$&#123;newx&#125;</span>-<span class=\"subst\">$&#123;newy&#125;</span>`</span>] &amp;&amp;</span><br><span class=\"line\">                newx &gt;= <span class=\"number\">0</span> &amp;&amp;</span><br><span class=\"line\">                newy &gt;= <span class=\"number\">0</span> &amp;&amp;</span><br><span class=\"line\">                newx &lt; m &amp;&amp;</span><br><span class=\"line\">                newy &lt; n</span><br><span class=\"line\">            ) &#123;</span><br><span class=\"line\">                queue.push([newx, newy]);</span><br><span class=\"line\">                visited[<span class=\"string\">`<span class=\"subst\">$&#123;newx&#125;</span>-<span class=\"subst\">$&#123;newy&#125;</span>`</span>] = <span class=\"literal\">true</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h2 id=\"4-总结\"><a href=\"#4-总结\" class=\"headerlink\" title=\"4.总结\"></a>4.总结</h2><p>对于这两个遍历方法，其实我们是可以轻松的看出来，他们有许多差异与许多相同点的。</p>\n<p><strong>1.数据结构上的运用</strong></p>\n<p>DFS用递归的形式，用到了栈结构，先进后出。</p>\n<p>BFS选取状态用队列的形式，先进先出。</p>\n<p><strong>2.复杂度</strong></p>\n<p>DFS的复杂度与BFS的复杂度大体一致，不同之处在于遍历的方式与对于问题的解决出发点不同，DFS适合目标明确，而BFS适合大范围的寻找。</p>\n<p><strong>3.思想</strong></p>\n<p>思想上来说这两种方法都是穷竭列举所有的情况。</p>"},{"title":"回流和重绘","date":"2020-03-11T10:56:40.000Z","_content":"\n# 你真的了解回流和重绘吗\n\n回流和重绘可以说是每一个web开发者都经常听到的两个词语，可是可能有很多人不是很清楚这两步具体做了什么事情。\n\n## 浏览器的渲染过程\n\n本文先从浏览器的渲染过程来从头到尾的讲解一下回流重绘，如果大家想直接看如何减少回流和重绘，优化性能，可以跳到后面。\n<!-- more -->\n![webkit渲染过程](https://wos2.58cdn.com.cn/iJkFeDcBiJiJ/rocket/8c43d3a7-55e7-47ae-a006-30a536a3db3d.jpeg)\n\n从上面这个图上，我们可以看到，浏览器渲染过程如下：\n\n1. 解析HTML，生成DOM树，解析CSS，生成CSSOM树\n2. 将DOM树和CSSOM树结合，生成渲染树(Render Tree)\n3. Layout(回流):根据生成的渲染树，进行回流(Layout)，得到节点的几何信息（位置，大小）\n4. Painting(重绘):根据渲染树以及回流得到的几何信息，得到节点的绝对像素\n5. Display:将像素发送给GPU，展示在页面上。（这一步其实还有很多内容，比如会在GPU将多个合成层合并为同一个层，并展示在页面中。而css3硬件加速的原理则是新建合成层，这里我们不展开，之后有机会会写一篇博客）\n\n渲染过程看起来很简单，让我们来具体了解下每一步具体做了什么。\n\n### 生成渲染树![生成渲染树](https://wos2.58cdn.com.cn/iJkFeDcBiJiJ/rocket/cf142c61-0431-47bf-83cf-5acb5cba0568.jpeg)\n\n为了构建渲染树，浏览器主要完成了以下工作：\n\n1. 从DOM树的根节点开始遍历每个可见节点。\n2. 对于每个可见的节点，找到CSSOM树中对应的规则，并应用它们。\n3. 根据每个可见节点以及其对应的样式，组合生成渲染树。\n\n第一步中，既然说到了要遍历可见的节点，那么我们得先知道，什么节点是不可见的。不可见的节点包括：\n\n- 一些不会渲染输出的节点，比如script、meta、link等。\n- 一些通过css进行隐藏的节点。比如display:none。注意，利用visibility和opacity隐藏的节点，还是会显示在渲染树上的。只有display:none的节点才不会显示在渲染树上。\n\n从上面的例子来讲，我们可以看到span标签的样式有一个display:none，因此，它最终并没有在渲染树上。\n\n**注意：渲染树只包含可见的节点**\n\n### 回流\n\n前面我们通过构造渲染树，我们将可见DOM节点以及它对应的样式结合起来，可是我们还需要计算它们在设备视口(viewport)内的确切位置和大小，这个计算的阶段就是回流。\n\n为了弄清每个对象在网站上的确切大小和位置，浏览器从渲染树的根节点开始遍历，我们可以以下面这个实例来表示：\n\n```\n<!DOCTYPE html>\n<html>\n  <head>\n    <meta name=\"viewport\" content=\"width=device-width,initial-scale=1\">\n    <title>Critial Path: Hello world!</title>\n  </head>\n  <body>\n    <div style=\"width: 50%\">\n      <div style=\"width: 50%\">Hello world!</div>\n    </div>\n  </body>\n</html>\n```\n\n我们可以看到，第一个div将节点的显示尺寸设置为视口宽度的50%，第二个div将其尺寸设置为父节点的50%。而在回流这个阶段，我们就需要根据视口具体的宽度，将其转为实际的像素值。（如下图）![img](https://wos2.58cdn.com.cn/iJkFeDcBiJiJ/rocket/1ad9c13e-2007-4366-9de5-70143c794a7c.jpeg)\n\n### 重绘\n\n最终，我们通过构造渲染树和回流阶段，我们知道了哪些节点是可见的，以及可见节点的样式和具体的几何信息(位置、大小)，那么我们就可以将渲染树的每个节点都转换为屏幕上的实际像素，这个阶段就叫做重绘节点。\n\n既然知道了浏览器的渲染过程后，我们就来探讨下，何时会发生回流重绘。\n\n## 何时发生回流重绘\n\n我们前面知道了，回流这一阶段主要是计算节点的位置和几何信息，那么当页面布局和几何信息发生变化的时候，就需要回流。比如以下情况：\n\n- 添加或删除可见的DOM元素\n- 元素的位置发生变化\n- 元素的尺寸发生变化（包括外边距、内边框、边框大小、高度和宽度等）\n- 内容发生变化，比如文本变化或图片被另一个不同尺寸的图片所替代。\n- 页面一开始渲染的时候（这肯定避免不了）\n- 浏览器的窗口尺寸变化（因为回流是根据视口的大小来计算元素的位置和大小的）\n\n**注意：回流一定会触发重绘，而重绘不一定会回流**\n\n根据改变的范围和程度，渲染树中或大或小的部分需要重新计算，有些改变会触发整个页面的重排，比如，滚动条出现的时候或者修改了根节点。\n\n## 浏览器的优化机制\n\n现代的浏览器都是很聪明的，由于每次重排都会造成额外的计算消耗，因此大多数浏览器都会通过队列化修改并批量执行来优化重排过程。浏览器会将修改操作放入到队列里，直到过了一段时间或者操作达到了一个阈值，才清空队列。但是！**当你获取布局信息的操作的时候，会强制队列刷新**，比如当你访问以下属性或者使用以下方法：\n\n- offsetTop、offsetLeft、offsetWidth、offsetHeight\n- scrollTop、scrollLeft、scrollWidth、scrollHeight\n- clientTop、clientLeft、clientWidth、clientHeight\n- getComputedStyle()\n- getBoundingClientRect\n- 具体可以访问这个网站：https://gist.github.com/paulirish/5d52fb081b3570c81e3a\n\n以上属性和方法都需要返回最新的布局信息，因此浏览器不得不清空队列，触发回流重绘来返回正确的值。因此，我们在修改样式的时候，**最好避免使用上面列出的属性，他们都会刷新渲染队列。**如果要使用它们，最好将值缓存起来。\n\n## 减少回流和重绘\n\n好了，到了我们今天的重头戏，前面说了这么多背景和理论知识，接下来让我们谈谈如何减少回流和重绘。\n\n### 最小化重绘和重排\n\n由于重绘和重排可能代价比较昂贵，因此最好就是可以减少它的发生次数。为了减少发生次数，我们可以合并多次对DOM和样式的修改，然后一次处理掉。考虑这个例子\n\n```\nconst el = document.getElementById('test');\nel.style.padding = '5px';\nel.style.borderLeft = '1px';\nel.style.borderRight = '2px';\n```\n\n例子中，有三个样式属性被修改了，每一个都会影响元素的几何结构，引起回流。当然，大部分现代浏览器都对其做了优化，因此，只会触发一次重排。但是如果在旧版的浏览器或者在上面代码执行的时候，有其他代码访问了布局信息(上文中的会触发回流的布局信息)，那么就会导致三次重排。\n\n因此，我们可以合并所有的改变然后依次处理，比如我们可以采取以下的方式：\n\n- 使用cssText\n\n  ```\n  const el = document.getElementById('test');\n  el.style.cssText += 'border-left: 1px; border-right: 2px; padding: 5px;';\n  ```\n\n- 修改CSS的class\n\n  ```\n  const el = document.getElementById('test');\n  el.className += ' active';\n  ```\n\n### 批量修改DOM\n\n当我们需要对DOM对一系列修改的时候，可以通过以下步骤减少回流重绘次数：\n\n1. 使元素脱离文档流\n2. 对其进行多次修改\n3. 将元素带回到文档中。\n\n该过程的第一步和第三步可能会引起回流，但是经过第一步之后，对DOM的所有修改都不会引起回流重绘，因为它已经不在渲染树了。\n\n有三种方式可以让DOM脱离文档流：\n\n- 隐藏元素，应用修改，重新显示\n- 使用文档片段(document fragment)在当前DOM之外构建一个子树，再把它拷贝回文档。\n- 将原始元素拷贝到一个脱离文档的节点中，修改节点后，再替换原始的元素。\n\n考虑我们要执行一段批量插入节点的代码：\n\n```\nfunction appendDataToElement(appendToElement, data) {\n    let li;\n    for (let i = 0; i < data.length; i++) {\n    \tli = document.createElement('li');\n        li.textContent = 'text';\n        appendToElement.appendChild(li);\n    }\n}\n\nconst ul = document.getElementById('list');\nappendDataToElement(ul, data);\n```\n\n如果我们直接这样执行的话，由于每次循环都会插入一个新的节点，会导致浏览器回流一次。\n\n我们可以使用这三种方式进行优化:\n\n**隐藏元素，应用修改，重新显示**\n\n这个会在展示和隐藏节点的时候，产生两次回流\n\n```\nfunction appendDataToElement(appendToElement, data) {\n    let li;\n    for (let i = 0; i < data.length; i++) {\n    \tli = document.createElement('li');\n        li.textContent = 'text';\n        appendToElement.appendChild(li);\n    }\n}\nconst ul = document.getElementById('list');\nul.style.display = 'none';\nappendDataToElement(ul, data);\nul.style.display = 'block';\n```\n\n**使用文档片段(document fragment)在当前DOM之外构建一个子树，再把它拷贝回文档**\n\n```\nconst ul = document.getElementById('list');\nconst fragment = document.createDocumentFragment();\nappendDataToElement(fragment, data);\nul.appendChild(fragment);\n```\n\n**将原始元素拷贝到一个脱离文档的节点中，修改节点后，再替换原始的元素。**\n\n```\nconst ul = document.getElementById('list');\nconst clone = ul.cloneNode(true);\nappendDataToElement(clone, data);\nul.parentNode.replaceChild(clone, ul);\n```\n\n对于上面这三种情况，我写了一个[demo](https://chenjigeng.github.io/example/share/避免回流重绘/批量修改DOM.html)在safari和chrome上测试修改前和修改后的性能。然而实验结果不是很理想。\n\n**原因：原因其实上面也说过了，现代浏览器会使用队列来储存多次修改，进行优化，所以对这个优化方案，我们其实不用优先考虑。**\n\n### 避免触发同步布局事件\n\n上文我们说过，当我们访问元素的一些属性的时候，会导致浏览器强制清空队列，进行强制同步布局。举个例子，比如说我们想将一个p标签数组的宽度赋值为一个元素的宽度，我们可能写出这样的代码：\n\n```\nfunction initP() {\n    for (let i = 0; i < paragraphs.length; i++) {\n        paragraphs[i].style.width = box.offsetWidth + 'px';\n    }\n}\n```\n\n这段代码看上去是没有什么问题，可是其实会造成很大的性能问题。在每次循环的时候，都读取了box的一个offsetWidth属性值，然后利用它来更新p标签的width属性。这就导致了每一次循环的时候，浏览器都必须先使上一次循环中的样式更新操作生效，才能响应本次循环的样式读取操作。**每一次循环都会强制浏览器刷新队列**。我们可以优化为:\n\n```\nconst width = box.offsetWidth;\nfunction initP() {\n    for (let i = 0; i < paragraphs.length; i++) {\n        paragraphs[i].style.width = width + 'px';\n    }\n}\n```\n\n同样，我也写了个[demo](https://chenjigeng.github.io/example/share/避免回流重绘/避免快速连续的布局.html)来比较两者的性能差异。你可以自己点开这个demo体验下。这个对比的性能差距就比较明显。\n\n### 对于复杂动画效果,使用绝对定位让其脱离文档流\n\n对于复杂动画效果，由于会经常的引起回流重绘，因此，我们可以使用绝对定位，让它脱离文档流。否则会引起父元素以及后续元素频繁的回流。这个我们就直接上个[例子](https://chenjigeng.github.io/example/share/避免回流重绘/将复杂动画浮动化.html)。\n\n打开这个例子后，我们可以打开控制台，控制台上会输出当前的帧数(虽然不准)。![image-20181210223750055](https://wos2.58cdn.com.cn/iJkFeDcBiJiJ/rocket/06844140-4139-4bf5-824a-911212321a4a.jpeg)\n\n从上图中，我们可以看到，帧数一直都没到60。这个时候，只要我们点击一下那个按钮，把这个元素设置为绝对定位，帧数就可以稳定60。\n\n### css3硬件加速（GPU加速）\n\n比起考虑如何减少回流重绘，我们更期望的是，根本不要回流重绘。这个时候，css3硬件加速就闪亮登场啦！！\n\n**划重点：**\n\n**1. 使用css3硬件加速，可以让transform、opacity、filters这些动画不会引起回流重绘 。**\n\n**2. 对于动画的其它属性，比如background-color这些，还是会引起回流重绘的，不过它还是可以提升这些动画的性能。**\n\n本篇文章只讨论如何使用，暂不考虑其原理，之后有空会另外开篇文章说明。\n\n#### 如何使用\n\n常见的触发硬件加速的css属性：\n\n- transform\n- opacity\n- filters\n- Will-change\n\n#### 效果\n\n我们可以先看个[例子](https://chenjigeng.github.io/example/share/对比gpu加速/gpu加速-transform.html)。我通过使用chrome的Performance捕获了动画一段时间里的回流重绘情况，实际结果如下图：\n\n![image-20181210225609533](https://wos2.58cdn.com.cn/iJkFeDcBiJiJ/rocket/5837b1bf-9667-4a5f-b403-29b254144022.jpeg)\n\n从图中我们可以看出，在动画进行的时候，没有发生任何的回流重绘。如果感兴趣你也可以自己做下实验。\n\n#### 重点\n\n- 使用css3硬件加速，可以让transform、opacity、filters这些动画不会引起回流重绘\n- 对于动画的其它属性，比如background-color这些，还是会引起回流重绘的，不过它还是可以提升这些动画的性能。\n\n#### css3硬件加速的坑\n\n当然，任何美好的东西都是会有对应的代价的，过犹不及。css3硬件加速还是有坑的:\n\n- 如果你为太多元素使用css3硬件加速，会导致内存占用较大，会有性能问题。\n- 在GPU渲染字体会导致抗锯齿无效。这是因为GPU和CPU的算法不同。因此如果你不在动画结束的时候关闭硬件加速，会产生字体模糊。\n\n## 总结\n\n本文主要讲了浏览器的渲染过程、浏览器的优化机制以及如何减少甚至避免回流和重绘，希望可以帮助大家更好的理解回流重绘。\n\n","source":"_posts/回流和重绘.md","raw":"---\ntitle: 回流和重绘\ndate: 2020-03-11 18:56:40\ntags:\n    -浏览器渲染\ncategories:\n    - 技术分享\n---\n\n# 你真的了解回流和重绘吗\n\n回流和重绘可以说是每一个web开发者都经常听到的两个词语，可是可能有很多人不是很清楚这两步具体做了什么事情。\n\n## 浏览器的渲染过程\n\n本文先从浏览器的渲染过程来从头到尾的讲解一下回流重绘，如果大家想直接看如何减少回流和重绘，优化性能，可以跳到后面。\n<!-- more -->\n![webkit渲染过程](https://wos2.58cdn.com.cn/iJkFeDcBiJiJ/rocket/8c43d3a7-55e7-47ae-a006-30a536a3db3d.jpeg)\n\n从上面这个图上，我们可以看到，浏览器渲染过程如下：\n\n1. 解析HTML，生成DOM树，解析CSS，生成CSSOM树\n2. 将DOM树和CSSOM树结合，生成渲染树(Render Tree)\n3. Layout(回流):根据生成的渲染树，进行回流(Layout)，得到节点的几何信息（位置，大小）\n4. Painting(重绘):根据渲染树以及回流得到的几何信息，得到节点的绝对像素\n5. Display:将像素发送给GPU，展示在页面上。（这一步其实还有很多内容，比如会在GPU将多个合成层合并为同一个层，并展示在页面中。而css3硬件加速的原理则是新建合成层，这里我们不展开，之后有机会会写一篇博客）\n\n渲染过程看起来很简单，让我们来具体了解下每一步具体做了什么。\n\n### 生成渲染树![生成渲染树](https://wos2.58cdn.com.cn/iJkFeDcBiJiJ/rocket/cf142c61-0431-47bf-83cf-5acb5cba0568.jpeg)\n\n为了构建渲染树，浏览器主要完成了以下工作：\n\n1. 从DOM树的根节点开始遍历每个可见节点。\n2. 对于每个可见的节点，找到CSSOM树中对应的规则，并应用它们。\n3. 根据每个可见节点以及其对应的样式，组合生成渲染树。\n\n第一步中，既然说到了要遍历可见的节点，那么我们得先知道，什么节点是不可见的。不可见的节点包括：\n\n- 一些不会渲染输出的节点，比如script、meta、link等。\n- 一些通过css进行隐藏的节点。比如display:none。注意，利用visibility和opacity隐藏的节点，还是会显示在渲染树上的。只有display:none的节点才不会显示在渲染树上。\n\n从上面的例子来讲，我们可以看到span标签的样式有一个display:none，因此，它最终并没有在渲染树上。\n\n**注意：渲染树只包含可见的节点**\n\n### 回流\n\n前面我们通过构造渲染树，我们将可见DOM节点以及它对应的样式结合起来，可是我们还需要计算它们在设备视口(viewport)内的确切位置和大小，这个计算的阶段就是回流。\n\n为了弄清每个对象在网站上的确切大小和位置，浏览器从渲染树的根节点开始遍历，我们可以以下面这个实例来表示：\n\n```\n<!DOCTYPE html>\n<html>\n  <head>\n    <meta name=\"viewport\" content=\"width=device-width,initial-scale=1\">\n    <title>Critial Path: Hello world!</title>\n  </head>\n  <body>\n    <div style=\"width: 50%\">\n      <div style=\"width: 50%\">Hello world!</div>\n    </div>\n  </body>\n</html>\n```\n\n我们可以看到，第一个div将节点的显示尺寸设置为视口宽度的50%，第二个div将其尺寸设置为父节点的50%。而在回流这个阶段，我们就需要根据视口具体的宽度，将其转为实际的像素值。（如下图）![img](https://wos2.58cdn.com.cn/iJkFeDcBiJiJ/rocket/1ad9c13e-2007-4366-9de5-70143c794a7c.jpeg)\n\n### 重绘\n\n最终，我们通过构造渲染树和回流阶段，我们知道了哪些节点是可见的，以及可见节点的样式和具体的几何信息(位置、大小)，那么我们就可以将渲染树的每个节点都转换为屏幕上的实际像素，这个阶段就叫做重绘节点。\n\n既然知道了浏览器的渲染过程后，我们就来探讨下，何时会发生回流重绘。\n\n## 何时发生回流重绘\n\n我们前面知道了，回流这一阶段主要是计算节点的位置和几何信息，那么当页面布局和几何信息发生变化的时候，就需要回流。比如以下情况：\n\n- 添加或删除可见的DOM元素\n- 元素的位置发生变化\n- 元素的尺寸发生变化（包括外边距、内边框、边框大小、高度和宽度等）\n- 内容发生变化，比如文本变化或图片被另一个不同尺寸的图片所替代。\n- 页面一开始渲染的时候（这肯定避免不了）\n- 浏览器的窗口尺寸变化（因为回流是根据视口的大小来计算元素的位置和大小的）\n\n**注意：回流一定会触发重绘，而重绘不一定会回流**\n\n根据改变的范围和程度，渲染树中或大或小的部分需要重新计算，有些改变会触发整个页面的重排，比如，滚动条出现的时候或者修改了根节点。\n\n## 浏览器的优化机制\n\n现代的浏览器都是很聪明的，由于每次重排都会造成额外的计算消耗，因此大多数浏览器都会通过队列化修改并批量执行来优化重排过程。浏览器会将修改操作放入到队列里，直到过了一段时间或者操作达到了一个阈值，才清空队列。但是！**当你获取布局信息的操作的时候，会强制队列刷新**，比如当你访问以下属性或者使用以下方法：\n\n- offsetTop、offsetLeft、offsetWidth、offsetHeight\n- scrollTop、scrollLeft、scrollWidth、scrollHeight\n- clientTop、clientLeft、clientWidth、clientHeight\n- getComputedStyle()\n- getBoundingClientRect\n- 具体可以访问这个网站：https://gist.github.com/paulirish/5d52fb081b3570c81e3a\n\n以上属性和方法都需要返回最新的布局信息，因此浏览器不得不清空队列，触发回流重绘来返回正确的值。因此，我们在修改样式的时候，**最好避免使用上面列出的属性，他们都会刷新渲染队列。**如果要使用它们，最好将值缓存起来。\n\n## 减少回流和重绘\n\n好了，到了我们今天的重头戏，前面说了这么多背景和理论知识，接下来让我们谈谈如何减少回流和重绘。\n\n### 最小化重绘和重排\n\n由于重绘和重排可能代价比较昂贵，因此最好就是可以减少它的发生次数。为了减少发生次数，我们可以合并多次对DOM和样式的修改，然后一次处理掉。考虑这个例子\n\n```\nconst el = document.getElementById('test');\nel.style.padding = '5px';\nel.style.borderLeft = '1px';\nel.style.borderRight = '2px';\n```\n\n例子中，有三个样式属性被修改了，每一个都会影响元素的几何结构，引起回流。当然，大部分现代浏览器都对其做了优化，因此，只会触发一次重排。但是如果在旧版的浏览器或者在上面代码执行的时候，有其他代码访问了布局信息(上文中的会触发回流的布局信息)，那么就会导致三次重排。\n\n因此，我们可以合并所有的改变然后依次处理，比如我们可以采取以下的方式：\n\n- 使用cssText\n\n  ```\n  const el = document.getElementById('test');\n  el.style.cssText += 'border-left: 1px; border-right: 2px; padding: 5px;';\n  ```\n\n- 修改CSS的class\n\n  ```\n  const el = document.getElementById('test');\n  el.className += ' active';\n  ```\n\n### 批量修改DOM\n\n当我们需要对DOM对一系列修改的时候，可以通过以下步骤减少回流重绘次数：\n\n1. 使元素脱离文档流\n2. 对其进行多次修改\n3. 将元素带回到文档中。\n\n该过程的第一步和第三步可能会引起回流，但是经过第一步之后，对DOM的所有修改都不会引起回流重绘，因为它已经不在渲染树了。\n\n有三种方式可以让DOM脱离文档流：\n\n- 隐藏元素，应用修改，重新显示\n- 使用文档片段(document fragment)在当前DOM之外构建一个子树，再把它拷贝回文档。\n- 将原始元素拷贝到一个脱离文档的节点中，修改节点后，再替换原始的元素。\n\n考虑我们要执行一段批量插入节点的代码：\n\n```\nfunction appendDataToElement(appendToElement, data) {\n    let li;\n    for (let i = 0; i < data.length; i++) {\n    \tli = document.createElement('li');\n        li.textContent = 'text';\n        appendToElement.appendChild(li);\n    }\n}\n\nconst ul = document.getElementById('list');\nappendDataToElement(ul, data);\n```\n\n如果我们直接这样执行的话，由于每次循环都会插入一个新的节点，会导致浏览器回流一次。\n\n我们可以使用这三种方式进行优化:\n\n**隐藏元素，应用修改，重新显示**\n\n这个会在展示和隐藏节点的时候，产生两次回流\n\n```\nfunction appendDataToElement(appendToElement, data) {\n    let li;\n    for (let i = 0; i < data.length; i++) {\n    \tli = document.createElement('li');\n        li.textContent = 'text';\n        appendToElement.appendChild(li);\n    }\n}\nconst ul = document.getElementById('list');\nul.style.display = 'none';\nappendDataToElement(ul, data);\nul.style.display = 'block';\n```\n\n**使用文档片段(document fragment)在当前DOM之外构建一个子树，再把它拷贝回文档**\n\n```\nconst ul = document.getElementById('list');\nconst fragment = document.createDocumentFragment();\nappendDataToElement(fragment, data);\nul.appendChild(fragment);\n```\n\n**将原始元素拷贝到一个脱离文档的节点中，修改节点后，再替换原始的元素。**\n\n```\nconst ul = document.getElementById('list');\nconst clone = ul.cloneNode(true);\nappendDataToElement(clone, data);\nul.parentNode.replaceChild(clone, ul);\n```\n\n对于上面这三种情况，我写了一个[demo](https://chenjigeng.github.io/example/share/避免回流重绘/批量修改DOM.html)在safari和chrome上测试修改前和修改后的性能。然而实验结果不是很理想。\n\n**原因：原因其实上面也说过了，现代浏览器会使用队列来储存多次修改，进行优化，所以对这个优化方案，我们其实不用优先考虑。**\n\n### 避免触发同步布局事件\n\n上文我们说过，当我们访问元素的一些属性的时候，会导致浏览器强制清空队列，进行强制同步布局。举个例子，比如说我们想将一个p标签数组的宽度赋值为一个元素的宽度，我们可能写出这样的代码：\n\n```\nfunction initP() {\n    for (let i = 0; i < paragraphs.length; i++) {\n        paragraphs[i].style.width = box.offsetWidth + 'px';\n    }\n}\n```\n\n这段代码看上去是没有什么问题，可是其实会造成很大的性能问题。在每次循环的时候，都读取了box的一个offsetWidth属性值，然后利用它来更新p标签的width属性。这就导致了每一次循环的时候，浏览器都必须先使上一次循环中的样式更新操作生效，才能响应本次循环的样式读取操作。**每一次循环都会强制浏览器刷新队列**。我们可以优化为:\n\n```\nconst width = box.offsetWidth;\nfunction initP() {\n    for (let i = 0; i < paragraphs.length; i++) {\n        paragraphs[i].style.width = width + 'px';\n    }\n}\n```\n\n同样，我也写了个[demo](https://chenjigeng.github.io/example/share/避免回流重绘/避免快速连续的布局.html)来比较两者的性能差异。你可以自己点开这个demo体验下。这个对比的性能差距就比较明显。\n\n### 对于复杂动画效果,使用绝对定位让其脱离文档流\n\n对于复杂动画效果，由于会经常的引起回流重绘，因此，我们可以使用绝对定位，让它脱离文档流。否则会引起父元素以及后续元素频繁的回流。这个我们就直接上个[例子](https://chenjigeng.github.io/example/share/避免回流重绘/将复杂动画浮动化.html)。\n\n打开这个例子后，我们可以打开控制台，控制台上会输出当前的帧数(虽然不准)。![image-20181210223750055](https://wos2.58cdn.com.cn/iJkFeDcBiJiJ/rocket/06844140-4139-4bf5-824a-911212321a4a.jpeg)\n\n从上图中，我们可以看到，帧数一直都没到60。这个时候，只要我们点击一下那个按钮，把这个元素设置为绝对定位，帧数就可以稳定60。\n\n### css3硬件加速（GPU加速）\n\n比起考虑如何减少回流重绘，我们更期望的是，根本不要回流重绘。这个时候，css3硬件加速就闪亮登场啦！！\n\n**划重点：**\n\n**1. 使用css3硬件加速，可以让transform、opacity、filters这些动画不会引起回流重绘 。**\n\n**2. 对于动画的其它属性，比如background-color这些，还是会引起回流重绘的，不过它还是可以提升这些动画的性能。**\n\n本篇文章只讨论如何使用，暂不考虑其原理，之后有空会另外开篇文章说明。\n\n#### 如何使用\n\n常见的触发硬件加速的css属性：\n\n- transform\n- opacity\n- filters\n- Will-change\n\n#### 效果\n\n我们可以先看个[例子](https://chenjigeng.github.io/example/share/对比gpu加速/gpu加速-transform.html)。我通过使用chrome的Performance捕获了动画一段时间里的回流重绘情况，实际结果如下图：\n\n![image-20181210225609533](https://wos2.58cdn.com.cn/iJkFeDcBiJiJ/rocket/5837b1bf-9667-4a5f-b403-29b254144022.jpeg)\n\n从图中我们可以看出，在动画进行的时候，没有发生任何的回流重绘。如果感兴趣你也可以自己做下实验。\n\n#### 重点\n\n- 使用css3硬件加速，可以让transform、opacity、filters这些动画不会引起回流重绘\n- 对于动画的其它属性，比如background-color这些，还是会引起回流重绘的，不过它还是可以提升这些动画的性能。\n\n#### css3硬件加速的坑\n\n当然，任何美好的东西都是会有对应的代价的，过犹不及。css3硬件加速还是有坑的:\n\n- 如果你为太多元素使用css3硬件加速，会导致内存占用较大，会有性能问题。\n- 在GPU渲染字体会导致抗锯齿无效。这是因为GPU和CPU的算法不同。因此如果你不在动画结束的时候关闭硬件加速，会产生字体模糊。\n\n## 总结\n\n本文主要讲了浏览器的渲染过程、浏览器的优化机制以及如何减少甚至避免回流和重绘，希望可以帮助大家更好的理解回流重绘。\n\n","slug":"回流和重绘","published":1,"updated":"2020-05-15T06:04:55.232Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cka7sznsc0000tu9mrvkhir5n","content":"<h1 id=\"你真的了解回流和重绘吗\"><a href=\"#你真的了解回流和重绘吗\" class=\"headerlink\" title=\"你真的了解回流和重绘吗\"></a>你真的了解回流和重绘吗</h1><p>回流和重绘可以说是每一个web开发者都经常听到的两个词语，可是可能有很多人不是很清楚这两步具体做了什么事情。</p>\n<h2 id=\"浏览器的渲染过程\"><a href=\"#浏览器的渲染过程\" class=\"headerlink\" title=\"浏览器的渲染过程\"></a>浏览器的渲染过程</h2><p>本文先从浏览器的渲染过程来从头到尾的讲解一下回流重绘，如果大家想直接看如何减少回流和重绘，优化性能，可以跳到后面。<br><a id=\"more\"></a><br><img src=\"https://wos2.58cdn.com.cn/iJkFeDcBiJiJ/rocket/8c43d3a7-55e7-47ae-a006-30a536a3db3d.jpeg\" alt=\"webkit渲染过程\"></p>\n<p>从上面这个图上，我们可以看到，浏览器渲染过程如下：</p>\n<ol>\n<li>解析HTML，生成DOM树，解析CSS，生成CSSOM树</li>\n<li>将DOM树和CSSOM树结合，生成渲染树(Render Tree)</li>\n<li>Layout(回流):根据生成的渲染树，进行回流(Layout)，得到节点的几何信息（位置，大小）</li>\n<li>Painting(重绘):根据渲染树以及回流得到的几何信息，得到节点的绝对像素</li>\n<li>Display:将像素发送给GPU，展示在页面上。（这一步其实还有很多内容，比如会在GPU将多个合成层合并为同一个层，并展示在页面中。而css3硬件加速的原理则是新建合成层，这里我们不展开，之后有机会会写一篇博客）</li>\n</ol>\n<p>渲染过程看起来很简单，让我们来具体了解下每一步具体做了什么。</p>\n<h3 id=\"生成渲染树\"><a href=\"#生成渲染树\" class=\"headerlink\" title=\"生成渲染树\"></a>生成渲染树<img src=\"https://wos2.58cdn.com.cn/iJkFeDcBiJiJ/rocket/cf142c61-0431-47bf-83cf-5acb5cba0568.jpeg\" alt=\"生成渲染树\"></h3><p>为了构建渲染树，浏览器主要完成了以下工作：</p>\n<ol>\n<li>从DOM树的根节点开始遍历每个可见节点。</li>\n<li>对于每个可见的节点，找到CSSOM树中对应的规则，并应用它们。</li>\n<li>根据每个可见节点以及其对应的样式，组合生成渲染树。</li>\n</ol>\n<p>第一步中，既然说到了要遍历可见的节点，那么我们得先知道，什么节点是不可见的。不可见的节点包括：</p>\n<ul>\n<li>一些不会渲染输出的节点，比如script、meta、link等。</li>\n<li>一些通过css进行隐藏的节点。比如display:none。注意，利用visibility和opacity隐藏的节点，还是会显示在渲染树上的。只有display:none的节点才不会显示在渲染树上。</li>\n</ul>\n<p>从上面的例子来讲，我们可以看到span标签的样式有一个display:none，因此，它最终并没有在渲染树上。</p>\n<p><strong>注意：渲染树只包含可见的节点</strong></p>\n<h3 id=\"回流\"><a href=\"#回流\" class=\"headerlink\" title=\"回流\"></a>回流</h3><p>前面我们通过构造渲染树，我们将可见DOM节点以及它对应的样式结合起来，可是我们还需要计算它们在设备视口(viewport)内的确切位置和大小，这个计算的阶段就是回流。</p>\n<p>为了弄清每个对象在网站上的确切大小和位置，浏览器从渲染树的根节点开始遍历，我们可以以下面这个实例来表示：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!DOCTYPE html&gt;</span><br><span class=\"line\">&lt;html&gt;</span><br><span class=\"line\">  &lt;head&gt;</span><br><span class=\"line\">    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,initial-scale=1&quot;&gt;</span><br><span class=\"line\">    &lt;title&gt;Critial Path: Hello world!&lt;/title&gt;</span><br><span class=\"line\">  &lt;/head&gt;</span><br><span class=\"line\">  &lt;body&gt;</span><br><span class=\"line\">    &lt;div style=&quot;width: 50%&quot;&gt;</span><br><span class=\"line\">      &lt;div style=&quot;width: 50%&quot;&gt;Hello world!&lt;/div&gt;</span><br><span class=\"line\">    &lt;/div&gt;</span><br><span class=\"line\">  &lt;/body&gt;</span><br><span class=\"line\">&lt;/html&gt;</span><br></pre></td></tr></table></figure>\n<p>我们可以看到，第一个div将节点的显示尺寸设置为视口宽度的50%，第二个div将其尺寸设置为父节点的50%。而在回流这个阶段，我们就需要根据视口具体的宽度，将其转为实际的像素值。（如下图）<img src=\"https://wos2.58cdn.com.cn/iJkFeDcBiJiJ/rocket/1ad9c13e-2007-4366-9de5-70143c794a7c.jpeg\" alt=\"img\"></p>\n<h3 id=\"重绘\"><a href=\"#重绘\" class=\"headerlink\" title=\"重绘\"></a>重绘</h3><p>最终，我们通过构造渲染树和回流阶段，我们知道了哪些节点是可见的，以及可见节点的样式和具体的几何信息(位置、大小)，那么我们就可以将渲染树的每个节点都转换为屏幕上的实际像素，这个阶段就叫做重绘节点。</p>\n<p>既然知道了浏览器的渲染过程后，我们就来探讨下，何时会发生回流重绘。</p>\n<h2 id=\"何时发生回流重绘\"><a href=\"#何时发生回流重绘\" class=\"headerlink\" title=\"何时发生回流重绘\"></a>何时发生回流重绘</h2><p>我们前面知道了，回流这一阶段主要是计算节点的位置和几何信息，那么当页面布局和几何信息发生变化的时候，就需要回流。比如以下情况：</p>\n<ul>\n<li>添加或删除可见的DOM元素</li>\n<li>元素的位置发生变化</li>\n<li>元素的尺寸发生变化（包括外边距、内边框、边框大小、高度和宽度等）</li>\n<li>内容发生变化，比如文本变化或图片被另一个不同尺寸的图片所替代。</li>\n<li>页面一开始渲染的时候（这肯定避免不了）</li>\n<li>浏览器的窗口尺寸变化（因为回流是根据视口的大小来计算元素的位置和大小的）</li>\n</ul>\n<p><strong>注意：回流一定会触发重绘，而重绘不一定会回流</strong></p>\n<p>根据改变的范围和程度，渲染树中或大或小的部分需要重新计算，有些改变会触发整个页面的重排，比如，滚动条出现的时候或者修改了根节点。</p>\n<h2 id=\"浏览器的优化机制\"><a href=\"#浏览器的优化机制\" class=\"headerlink\" title=\"浏览器的优化机制\"></a>浏览器的优化机制</h2><p>现代的浏览器都是很聪明的，由于每次重排都会造成额外的计算消耗，因此大多数浏览器都会通过队列化修改并批量执行来优化重排过程。浏览器会将修改操作放入到队列里，直到过了一段时间或者操作达到了一个阈值，才清空队列。但是！<strong>当你获取布局信息的操作的时候，会强制队列刷新</strong>，比如当你访问以下属性或者使用以下方法：</p>\n<ul>\n<li>offsetTop、offsetLeft、offsetWidth、offsetHeight</li>\n<li>scrollTop、scrollLeft、scrollWidth、scrollHeight</li>\n<li>clientTop、clientLeft、clientWidth、clientHeight</li>\n<li>getComputedStyle()</li>\n<li>getBoundingClientRect</li>\n<li>具体可以访问这个网站：<a href=\"https://gist.github.com/paulirish/5d52fb081b3570c81e3a\" target=\"_blank\" rel=\"noopener\">https://gist.github.com/paulirish/5d52fb081b3570c81e3a</a></li>\n</ul>\n<p>以上属性和方法都需要返回最新的布局信息，因此浏览器不得不清空队列，触发回流重绘来返回正确的值。因此，我们在修改样式的时候，<strong>最好避免使用上面列出的属性，他们都会刷新渲染队列。</strong>如果要使用它们，最好将值缓存起来。</p>\n<h2 id=\"减少回流和重绘\"><a href=\"#减少回流和重绘\" class=\"headerlink\" title=\"减少回流和重绘\"></a>减少回流和重绘</h2><p>好了，到了我们今天的重头戏，前面说了这么多背景和理论知识，接下来让我们谈谈如何减少回流和重绘。</p>\n<h3 id=\"最小化重绘和重排\"><a href=\"#最小化重绘和重排\" class=\"headerlink\" title=\"最小化重绘和重排\"></a>最小化重绘和重排</h3><p>由于重绘和重排可能代价比较昂贵，因此最好就是可以减少它的发生次数。为了减少发生次数，我们可以合并多次对DOM和样式的修改，然后一次处理掉。考虑这个例子</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const el = document.getElementById(&apos;test&apos;);</span><br><span class=\"line\">el.style.padding = &apos;5px&apos;;</span><br><span class=\"line\">el.style.borderLeft = &apos;1px&apos;;</span><br><span class=\"line\">el.style.borderRight = &apos;2px&apos;;</span><br></pre></td></tr></table></figure>\n<p>例子中，有三个样式属性被修改了，每一个都会影响元素的几何结构，引起回流。当然，大部分现代浏览器都对其做了优化，因此，只会触发一次重排。但是如果在旧版的浏览器或者在上面代码执行的时候，有其他代码访问了布局信息(上文中的会触发回流的布局信息)，那么就会导致三次重排。</p>\n<p>因此，我们可以合并所有的改变然后依次处理，比如我们可以采取以下的方式：</p>\n<ul>\n<li><p>使用cssText</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const el = document.getElementById(&apos;test&apos;);</span><br><span class=\"line\">el.style.cssText += &apos;border-left: 1px; border-right: 2px; padding: 5px;&apos;;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>修改CSS的class</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const el = document.getElementById(&apos;test&apos;);</span><br><span class=\"line\">el.className += &apos; active&apos;;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h3 id=\"批量修改DOM\"><a href=\"#批量修改DOM\" class=\"headerlink\" title=\"批量修改DOM\"></a>批量修改DOM</h3><p>当我们需要对DOM对一系列修改的时候，可以通过以下步骤减少回流重绘次数：</p>\n<ol>\n<li>使元素脱离文档流</li>\n<li>对其进行多次修改</li>\n<li>将元素带回到文档中。</li>\n</ol>\n<p>该过程的第一步和第三步可能会引起回流，但是经过第一步之后，对DOM的所有修改都不会引起回流重绘，因为它已经不在渲染树了。</p>\n<p>有三种方式可以让DOM脱离文档流：</p>\n<ul>\n<li>隐藏元素，应用修改，重新显示</li>\n<li>使用文档片段(document fragment)在当前DOM之外构建一个子树，再把它拷贝回文档。</li>\n<li>将原始元素拷贝到一个脱离文档的节点中，修改节点后，再替换原始的元素。</li>\n</ul>\n<p>考虑我们要执行一段批量插入节点的代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function appendDataToElement(appendToElement, data) &#123;</span><br><span class=\"line\">    let li;</span><br><span class=\"line\">    for (let i = 0; i &lt; data.length; i++) &#123;</span><br><span class=\"line\">    \tli = document.createElement(&apos;li&apos;);</span><br><span class=\"line\">        li.textContent = &apos;text&apos;;</span><br><span class=\"line\">        appendToElement.appendChild(li);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">const ul = document.getElementById(&apos;list&apos;);</span><br><span class=\"line\">appendDataToElement(ul, data);</span><br></pre></td></tr></table></figure>\n<p>如果我们直接这样执行的话，由于每次循环都会插入一个新的节点，会导致浏览器回流一次。</p>\n<p>我们可以使用这三种方式进行优化:</p>\n<p><strong>隐藏元素，应用修改，重新显示</strong></p>\n<p>这个会在展示和隐藏节点的时候，产生两次回流</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function appendDataToElement(appendToElement, data) &#123;</span><br><span class=\"line\">    let li;</span><br><span class=\"line\">    for (let i = 0; i &lt; data.length; i++) &#123;</span><br><span class=\"line\">    \tli = document.createElement(&apos;li&apos;);</span><br><span class=\"line\">        li.textContent = &apos;text&apos;;</span><br><span class=\"line\">        appendToElement.appendChild(li);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">const ul = document.getElementById(&apos;list&apos;);</span><br><span class=\"line\">ul.style.display = &apos;none&apos;;</span><br><span class=\"line\">appendDataToElement(ul, data);</span><br><span class=\"line\">ul.style.display = &apos;block&apos;;</span><br></pre></td></tr></table></figure>\n<p><strong>使用文档片段(document fragment)在当前DOM之外构建一个子树，再把它拷贝回文档</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const ul = document.getElementById(&apos;list&apos;);</span><br><span class=\"line\">const fragment = document.createDocumentFragment();</span><br><span class=\"line\">appendDataToElement(fragment, data);</span><br><span class=\"line\">ul.appendChild(fragment);</span><br></pre></td></tr></table></figure>\n<p><strong>将原始元素拷贝到一个脱离文档的节点中，修改节点后，再替换原始的元素。</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const ul = document.getElementById(&apos;list&apos;);</span><br><span class=\"line\">const clone = ul.cloneNode(true);</span><br><span class=\"line\">appendDataToElement(clone, data);</span><br><span class=\"line\">ul.parentNode.replaceChild(clone, ul);</span><br></pre></td></tr></table></figure>\n<p>对于上面这三种情况，我写了一个<a href=\"https://chenjigeng.github.io/example/share/避免回流重绘/批量修改DOM.html\" target=\"_blank\" rel=\"noopener\">demo</a>在safari和chrome上测试修改前和修改后的性能。然而实验结果不是很理想。</p>\n<p><strong>原因：原因其实上面也说过了，现代浏览器会使用队列来储存多次修改，进行优化，所以对这个优化方案，我们其实不用优先考虑。</strong></p>\n<h3 id=\"避免触发同步布局事件\"><a href=\"#避免触发同步布局事件\" class=\"headerlink\" title=\"避免触发同步布局事件\"></a>避免触发同步布局事件</h3><p>上文我们说过，当我们访问元素的一些属性的时候，会导致浏览器强制清空队列，进行强制同步布局。举个例子，比如说我们想将一个p标签数组的宽度赋值为一个元素的宽度，我们可能写出这样的代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function initP() &#123;</span><br><span class=\"line\">    for (let i = 0; i &lt; paragraphs.length; i++) &#123;</span><br><span class=\"line\">        paragraphs[i].style.width = box.offsetWidth + &apos;px&apos;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这段代码看上去是没有什么问题，可是其实会造成很大的性能问题。在每次循环的时候，都读取了box的一个offsetWidth属性值，然后利用它来更新p标签的width属性。这就导致了每一次循环的时候，浏览器都必须先使上一次循环中的样式更新操作生效，才能响应本次循环的样式读取操作。<strong>每一次循环都会强制浏览器刷新队列</strong>。我们可以优化为:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const width = box.offsetWidth;</span><br><span class=\"line\">function initP() &#123;</span><br><span class=\"line\">    for (let i = 0; i &lt; paragraphs.length; i++) &#123;</span><br><span class=\"line\">        paragraphs[i].style.width = width + &apos;px&apos;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>同样，我也写了个<a href=\"https://chenjigeng.github.io/example/share/避免回流重绘/避免快速连续的布局.html\" target=\"_blank\" rel=\"noopener\">demo</a>来比较两者的性能差异。你可以自己点开这个demo体验下。这个对比的性能差距就比较明显。</p>\n<h3 id=\"对于复杂动画效果-使用绝对定位让其脱离文档流\"><a href=\"#对于复杂动画效果-使用绝对定位让其脱离文档流\" class=\"headerlink\" title=\"对于复杂动画效果,使用绝对定位让其脱离文档流\"></a>对于复杂动画效果,使用绝对定位让其脱离文档流</h3><p>对于复杂动画效果，由于会经常的引起回流重绘，因此，我们可以使用绝对定位，让它脱离文档流。否则会引起父元素以及后续元素频繁的回流。这个我们就直接上个<a href=\"https://chenjigeng.github.io/example/share/避免回流重绘/将复杂动画浮动化.html\" target=\"_blank\" rel=\"noopener\">例子</a>。</p>\n<p>打开这个例子后，我们可以打开控制台，控制台上会输出当前的帧数(虽然不准)。<img src=\"https://wos2.58cdn.com.cn/iJkFeDcBiJiJ/rocket/06844140-4139-4bf5-824a-911212321a4a.jpeg\" alt=\"image-20181210223750055\"></p>\n<p>从上图中，我们可以看到，帧数一直都没到60。这个时候，只要我们点击一下那个按钮，把这个元素设置为绝对定位，帧数就可以稳定60。</p>\n<h3 id=\"css3硬件加速（GPU加速）\"><a href=\"#css3硬件加速（GPU加速）\" class=\"headerlink\" title=\"css3硬件加速（GPU加速）\"></a>css3硬件加速（GPU加速）</h3><p>比起考虑如何减少回流重绘，我们更期望的是，根本不要回流重绘。这个时候，css3硬件加速就闪亮登场啦！！</p>\n<p><strong>划重点：</strong></p>\n<p><strong>1. 使用css3硬件加速，可以让transform、opacity、filters这些动画不会引起回流重绘 。</strong></p>\n<p><strong>2. 对于动画的其它属性，比如background-color这些，还是会引起回流重绘的，不过它还是可以提升这些动画的性能。</strong></p>\n<p>本篇文章只讨论如何使用，暂不考虑其原理，之后有空会另外开篇文章说明。</p>\n<h4 id=\"如何使用\"><a href=\"#如何使用\" class=\"headerlink\" title=\"如何使用\"></a>如何使用</h4><p>常见的触发硬件加速的css属性：</p>\n<ul>\n<li>transform</li>\n<li>opacity</li>\n<li>filters</li>\n<li>Will-change</li>\n</ul>\n<h4 id=\"效果\"><a href=\"#效果\" class=\"headerlink\" title=\"效果\"></a>效果</h4><p>我们可以先看个<a href=\"https://chenjigeng.github.io/example/share/对比gpu加速/gpu加速-transform.html\" target=\"_blank\" rel=\"noopener\">例子</a>。我通过使用chrome的Performance捕获了动画一段时间里的回流重绘情况，实际结果如下图：</p>\n<p><img src=\"https://wos2.58cdn.com.cn/iJkFeDcBiJiJ/rocket/5837b1bf-9667-4a5f-b403-29b254144022.jpeg\" alt=\"image-20181210225609533\"></p>\n<p>从图中我们可以看出，在动画进行的时候，没有发生任何的回流重绘。如果感兴趣你也可以自己做下实验。</p>\n<h4 id=\"重点\"><a href=\"#重点\" class=\"headerlink\" title=\"重点\"></a>重点</h4><ul>\n<li>使用css3硬件加速，可以让transform、opacity、filters这些动画不会引起回流重绘</li>\n<li>对于动画的其它属性，比如background-color这些，还是会引起回流重绘的，不过它还是可以提升这些动画的性能。</li>\n</ul>\n<h4 id=\"css3硬件加速的坑\"><a href=\"#css3硬件加速的坑\" class=\"headerlink\" title=\"css3硬件加速的坑\"></a>css3硬件加速的坑</h4><p>当然，任何美好的东西都是会有对应的代价的，过犹不及。css3硬件加速还是有坑的:</p>\n<ul>\n<li>如果你为太多元素使用css3硬件加速，会导致内存占用较大，会有性能问题。</li>\n<li>在GPU渲染字体会导致抗锯齿无效。这是因为GPU和CPU的算法不同。因此如果你不在动画结束的时候关闭硬件加速，会产生字体模糊。</li>\n</ul>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>本文主要讲了浏览器的渲染过程、浏览器的优化机制以及如何减少甚至避免回流和重绘，希望可以帮助大家更好的理解回流重绘。</p>\n","site":{"data":{}},"excerpt":"<h1 id=\"你真的了解回流和重绘吗\"><a href=\"#你真的了解回流和重绘吗\" class=\"headerlink\" title=\"你真的了解回流和重绘吗\"></a>你真的了解回流和重绘吗</h1><p>回流和重绘可以说是每一个web开发者都经常听到的两个词语，可是可能有很多人不是很清楚这两步具体做了什么事情。</p>\n<h2 id=\"浏览器的渲染过程\"><a href=\"#浏览器的渲染过程\" class=\"headerlink\" title=\"浏览器的渲染过程\"></a>浏览器的渲染过程</h2><p>本文先从浏览器的渲染过程来从头到尾的讲解一下回流重绘，如果大家想直接看如何减少回流和重绘，优化性能，可以跳到后面。<br>","more":"<br><img src=\"https://wos2.58cdn.com.cn/iJkFeDcBiJiJ/rocket/8c43d3a7-55e7-47ae-a006-30a536a3db3d.jpeg\" alt=\"webkit渲染过程\"></p>\n<p>从上面这个图上，我们可以看到，浏览器渲染过程如下：</p>\n<ol>\n<li>解析HTML，生成DOM树，解析CSS，生成CSSOM树</li>\n<li>将DOM树和CSSOM树结合，生成渲染树(Render Tree)</li>\n<li>Layout(回流):根据生成的渲染树，进行回流(Layout)，得到节点的几何信息（位置，大小）</li>\n<li>Painting(重绘):根据渲染树以及回流得到的几何信息，得到节点的绝对像素</li>\n<li>Display:将像素发送给GPU，展示在页面上。（这一步其实还有很多内容，比如会在GPU将多个合成层合并为同一个层，并展示在页面中。而css3硬件加速的原理则是新建合成层，这里我们不展开，之后有机会会写一篇博客）</li>\n</ol>\n<p>渲染过程看起来很简单，让我们来具体了解下每一步具体做了什么。</p>\n<h3 id=\"生成渲染树\"><a href=\"#生成渲染树\" class=\"headerlink\" title=\"生成渲染树\"></a>生成渲染树<img src=\"https://wos2.58cdn.com.cn/iJkFeDcBiJiJ/rocket/cf142c61-0431-47bf-83cf-5acb5cba0568.jpeg\" alt=\"生成渲染树\"></h3><p>为了构建渲染树，浏览器主要完成了以下工作：</p>\n<ol>\n<li>从DOM树的根节点开始遍历每个可见节点。</li>\n<li>对于每个可见的节点，找到CSSOM树中对应的规则，并应用它们。</li>\n<li>根据每个可见节点以及其对应的样式，组合生成渲染树。</li>\n</ol>\n<p>第一步中，既然说到了要遍历可见的节点，那么我们得先知道，什么节点是不可见的。不可见的节点包括：</p>\n<ul>\n<li>一些不会渲染输出的节点，比如script、meta、link等。</li>\n<li>一些通过css进行隐藏的节点。比如display:none。注意，利用visibility和opacity隐藏的节点，还是会显示在渲染树上的。只有display:none的节点才不会显示在渲染树上。</li>\n</ul>\n<p>从上面的例子来讲，我们可以看到span标签的样式有一个display:none，因此，它最终并没有在渲染树上。</p>\n<p><strong>注意：渲染树只包含可见的节点</strong></p>\n<h3 id=\"回流\"><a href=\"#回流\" class=\"headerlink\" title=\"回流\"></a>回流</h3><p>前面我们通过构造渲染树，我们将可见DOM节点以及它对应的样式结合起来，可是我们还需要计算它们在设备视口(viewport)内的确切位置和大小，这个计算的阶段就是回流。</p>\n<p>为了弄清每个对象在网站上的确切大小和位置，浏览器从渲染树的根节点开始遍历，我们可以以下面这个实例来表示：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!DOCTYPE html&gt;</span><br><span class=\"line\">&lt;html&gt;</span><br><span class=\"line\">  &lt;head&gt;</span><br><span class=\"line\">    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,initial-scale=1&quot;&gt;</span><br><span class=\"line\">    &lt;title&gt;Critial Path: Hello world!&lt;/title&gt;</span><br><span class=\"line\">  &lt;/head&gt;</span><br><span class=\"line\">  &lt;body&gt;</span><br><span class=\"line\">    &lt;div style=&quot;width: 50%&quot;&gt;</span><br><span class=\"line\">      &lt;div style=&quot;width: 50%&quot;&gt;Hello world!&lt;/div&gt;</span><br><span class=\"line\">    &lt;/div&gt;</span><br><span class=\"line\">  &lt;/body&gt;</span><br><span class=\"line\">&lt;/html&gt;</span><br></pre></td></tr></table></figure>\n<p>我们可以看到，第一个div将节点的显示尺寸设置为视口宽度的50%，第二个div将其尺寸设置为父节点的50%。而在回流这个阶段，我们就需要根据视口具体的宽度，将其转为实际的像素值。（如下图）<img src=\"https://wos2.58cdn.com.cn/iJkFeDcBiJiJ/rocket/1ad9c13e-2007-4366-9de5-70143c794a7c.jpeg\" alt=\"img\"></p>\n<h3 id=\"重绘\"><a href=\"#重绘\" class=\"headerlink\" title=\"重绘\"></a>重绘</h3><p>最终，我们通过构造渲染树和回流阶段，我们知道了哪些节点是可见的，以及可见节点的样式和具体的几何信息(位置、大小)，那么我们就可以将渲染树的每个节点都转换为屏幕上的实际像素，这个阶段就叫做重绘节点。</p>\n<p>既然知道了浏览器的渲染过程后，我们就来探讨下，何时会发生回流重绘。</p>\n<h2 id=\"何时发生回流重绘\"><a href=\"#何时发生回流重绘\" class=\"headerlink\" title=\"何时发生回流重绘\"></a>何时发生回流重绘</h2><p>我们前面知道了，回流这一阶段主要是计算节点的位置和几何信息，那么当页面布局和几何信息发生变化的时候，就需要回流。比如以下情况：</p>\n<ul>\n<li>添加或删除可见的DOM元素</li>\n<li>元素的位置发生变化</li>\n<li>元素的尺寸发生变化（包括外边距、内边框、边框大小、高度和宽度等）</li>\n<li>内容发生变化，比如文本变化或图片被另一个不同尺寸的图片所替代。</li>\n<li>页面一开始渲染的时候（这肯定避免不了）</li>\n<li>浏览器的窗口尺寸变化（因为回流是根据视口的大小来计算元素的位置和大小的）</li>\n</ul>\n<p><strong>注意：回流一定会触发重绘，而重绘不一定会回流</strong></p>\n<p>根据改变的范围和程度，渲染树中或大或小的部分需要重新计算，有些改变会触发整个页面的重排，比如，滚动条出现的时候或者修改了根节点。</p>\n<h2 id=\"浏览器的优化机制\"><a href=\"#浏览器的优化机制\" class=\"headerlink\" title=\"浏览器的优化机制\"></a>浏览器的优化机制</h2><p>现代的浏览器都是很聪明的，由于每次重排都会造成额外的计算消耗，因此大多数浏览器都会通过队列化修改并批量执行来优化重排过程。浏览器会将修改操作放入到队列里，直到过了一段时间或者操作达到了一个阈值，才清空队列。但是！<strong>当你获取布局信息的操作的时候，会强制队列刷新</strong>，比如当你访问以下属性或者使用以下方法：</p>\n<ul>\n<li>offsetTop、offsetLeft、offsetWidth、offsetHeight</li>\n<li>scrollTop、scrollLeft、scrollWidth、scrollHeight</li>\n<li>clientTop、clientLeft、clientWidth、clientHeight</li>\n<li>getComputedStyle()</li>\n<li>getBoundingClientRect</li>\n<li>具体可以访问这个网站：<a href=\"https://gist.github.com/paulirish/5d52fb081b3570c81e3a\" target=\"_blank\" rel=\"noopener\">https://gist.github.com/paulirish/5d52fb081b3570c81e3a</a></li>\n</ul>\n<p>以上属性和方法都需要返回最新的布局信息，因此浏览器不得不清空队列，触发回流重绘来返回正确的值。因此，我们在修改样式的时候，<strong>最好避免使用上面列出的属性，他们都会刷新渲染队列。</strong>如果要使用它们，最好将值缓存起来。</p>\n<h2 id=\"减少回流和重绘\"><a href=\"#减少回流和重绘\" class=\"headerlink\" title=\"减少回流和重绘\"></a>减少回流和重绘</h2><p>好了，到了我们今天的重头戏，前面说了这么多背景和理论知识，接下来让我们谈谈如何减少回流和重绘。</p>\n<h3 id=\"最小化重绘和重排\"><a href=\"#最小化重绘和重排\" class=\"headerlink\" title=\"最小化重绘和重排\"></a>最小化重绘和重排</h3><p>由于重绘和重排可能代价比较昂贵，因此最好就是可以减少它的发生次数。为了减少发生次数，我们可以合并多次对DOM和样式的修改，然后一次处理掉。考虑这个例子</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const el = document.getElementById(&apos;test&apos;);</span><br><span class=\"line\">el.style.padding = &apos;5px&apos;;</span><br><span class=\"line\">el.style.borderLeft = &apos;1px&apos;;</span><br><span class=\"line\">el.style.borderRight = &apos;2px&apos;;</span><br></pre></td></tr></table></figure>\n<p>例子中，有三个样式属性被修改了，每一个都会影响元素的几何结构，引起回流。当然，大部分现代浏览器都对其做了优化，因此，只会触发一次重排。但是如果在旧版的浏览器或者在上面代码执行的时候，有其他代码访问了布局信息(上文中的会触发回流的布局信息)，那么就会导致三次重排。</p>\n<p>因此，我们可以合并所有的改变然后依次处理，比如我们可以采取以下的方式：</p>\n<ul>\n<li><p>使用cssText</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const el = document.getElementById(&apos;test&apos;);</span><br><span class=\"line\">el.style.cssText += &apos;border-left: 1px; border-right: 2px; padding: 5px;&apos;;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>修改CSS的class</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const el = document.getElementById(&apos;test&apos;);</span><br><span class=\"line\">el.className += &apos; active&apos;;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h3 id=\"批量修改DOM\"><a href=\"#批量修改DOM\" class=\"headerlink\" title=\"批量修改DOM\"></a>批量修改DOM</h3><p>当我们需要对DOM对一系列修改的时候，可以通过以下步骤减少回流重绘次数：</p>\n<ol>\n<li>使元素脱离文档流</li>\n<li>对其进行多次修改</li>\n<li>将元素带回到文档中。</li>\n</ol>\n<p>该过程的第一步和第三步可能会引起回流，但是经过第一步之后，对DOM的所有修改都不会引起回流重绘，因为它已经不在渲染树了。</p>\n<p>有三种方式可以让DOM脱离文档流：</p>\n<ul>\n<li>隐藏元素，应用修改，重新显示</li>\n<li>使用文档片段(document fragment)在当前DOM之外构建一个子树，再把它拷贝回文档。</li>\n<li>将原始元素拷贝到一个脱离文档的节点中，修改节点后，再替换原始的元素。</li>\n</ul>\n<p>考虑我们要执行一段批量插入节点的代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function appendDataToElement(appendToElement, data) &#123;</span><br><span class=\"line\">    let li;</span><br><span class=\"line\">    for (let i = 0; i &lt; data.length; i++) &#123;</span><br><span class=\"line\">    \tli = document.createElement(&apos;li&apos;);</span><br><span class=\"line\">        li.textContent = &apos;text&apos;;</span><br><span class=\"line\">        appendToElement.appendChild(li);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">const ul = document.getElementById(&apos;list&apos;);</span><br><span class=\"line\">appendDataToElement(ul, data);</span><br></pre></td></tr></table></figure>\n<p>如果我们直接这样执行的话，由于每次循环都会插入一个新的节点，会导致浏览器回流一次。</p>\n<p>我们可以使用这三种方式进行优化:</p>\n<p><strong>隐藏元素，应用修改，重新显示</strong></p>\n<p>这个会在展示和隐藏节点的时候，产生两次回流</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function appendDataToElement(appendToElement, data) &#123;</span><br><span class=\"line\">    let li;</span><br><span class=\"line\">    for (let i = 0; i &lt; data.length; i++) &#123;</span><br><span class=\"line\">    \tli = document.createElement(&apos;li&apos;);</span><br><span class=\"line\">        li.textContent = &apos;text&apos;;</span><br><span class=\"line\">        appendToElement.appendChild(li);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">const ul = document.getElementById(&apos;list&apos;);</span><br><span class=\"line\">ul.style.display = &apos;none&apos;;</span><br><span class=\"line\">appendDataToElement(ul, data);</span><br><span class=\"line\">ul.style.display = &apos;block&apos;;</span><br></pre></td></tr></table></figure>\n<p><strong>使用文档片段(document fragment)在当前DOM之外构建一个子树，再把它拷贝回文档</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const ul = document.getElementById(&apos;list&apos;);</span><br><span class=\"line\">const fragment = document.createDocumentFragment();</span><br><span class=\"line\">appendDataToElement(fragment, data);</span><br><span class=\"line\">ul.appendChild(fragment);</span><br></pre></td></tr></table></figure>\n<p><strong>将原始元素拷贝到一个脱离文档的节点中，修改节点后，再替换原始的元素。</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const ul = document.getElementById(&apos;list&apos;);</span><br><span class=\"line\">const clone = ul.cloneNode(true);</span><br><span class=\"line\">appendDataToElement(clone, data);</span><br><span class=\"line\">ul.parentNode.replaceChild(clone, ul);</span><br></pre></td></tr></table></figure>\n<p>对于上面这三种情况，我写了一个<a href=\"https://chenjigeng.github.io/example/share/避免回流重绘/批量修改DOM.html\" target=\"_blank\" rel=\"noopener\">demo</a>在safari和chrome上测试修改前和修改后的性能。然而实验结果不是很理想。</p>\n<p><strong>原因：原因其实上面也说过了，现代浏览器会使用队列来储存多次修改，进行优化，所以对这个优化方案，我们其实不用优先考虑。</strong></p>\n<h3 id=\"避免触发同步布局事件\"><a href=\"#避免触发同步布局事件\" class=\"headerlink\" title=\"避免触发同步布局事件\"></a>避免触发同步布局事件</h3><p>上文我们说过，当我们访问元素的一些属性的时候，会导致浏览器强制清空队列，进行强制同步布局。举个例子，比如说我们想将一个p标签数组的宽度赋值为一个元素的宽度，我们可能写出这样的代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function initP() &#123;</span><br><span class=\"line\">    for (let i = 0; i &lt; paragraphs.length; i++) &#123;</span><br><span class=\"line\">        paragraphs[i].style.width = box.offsetWidth + &apos;px&apos;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这段代码看上去是没有什么问题，可是其实会造成很大的性能问题。在每次循环的时候，都读取了box的一个offsetWidth属性值，然后利用它来更新p标签的width属性。这就导致了每一次循环的时候，浏览器都必须先使上一次循环中的样式更新操作生效，才能响应本次循环的样式读取操作。<strong>每一次循环都会强制浏览器刷新队列</strong>。我们可以优化为:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const width = box.offsetWidth;</span><br><span class=\"line\">function initP() &#123;</span><br><span class=\"line\">    for (let i = 0; i &lt; paragraphs.length; i++) &#123;</span><br><span class=\"line\">        paragraphs[i].style.width = width + &apos;px&apos;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>同样，我也写了个<a href=\"https://chenjigeng.github.io/example/share/避免回流重绘/避免快速连续的布局.html\" target=\"_blank\" rel=\"noopener\">demo</a>来比较两者的性能差异。你可以自己点开这个demo体验下。这个对比的性能差距就比较明显。</p>\n<h3 id=\"对于复杂动画效果-使用绝对定位让其脱离文档流\"><a href=\"#对于复杂动画效果-使用绝对定位让其脱离文档流\" class=\"headerlink\" title=\"对于复杂动画效果,使用绝对定位让其脱离文档流\"></a>对于复杂动画效果,使用绝对定位让其脱离文档流</h3><p>对于复杂动画效果，由于会经常的引起回流重绘，因此，我们可以使用绝对定位，让它脱离文档流。否则会引起父元素以及后续元素频繁的回流。这个我们就直接上个<a href=\"https://chenjigeng.github.io/example/share/避免回流重绘/将复杂动画浮动化.html\" target=\"_blank\" rel=\"noopener\">例子</a>。</p>\n<p>打开这个例子后，我们可以打开控制台，控制台上会输出当前的帧数(虽然不准)。<img src=\"https://wos2.58cdn.com.cn/iJkFeDcBiJiJ/rocket/06844140-4139-4bf5-824a-911212321a4a.jpeg\" alt=\"image-20181210223750055\"></p>\n<p>从上图中，我们可以看到，帧数一直都没到60。这个时候，只要我们点击一下那个按钮，把这个元素设置为绝对定位，帧数就可以稳定60。</p>\n<h3 id=\"css3硬件加速（GPU加速）\"><a href=\"#css3硬件加速（GPU加速）\" class=\"headerlink\" title=\"css3硬件加速（GPU加速）\"></a>css3硬件加速（GPU加速）</h3><p>比起考虑如何减少回流重绘，我们更期望的是，根本不要回流重绘。这个时候，css3硬件加速就闪亮登场啦！！</p>\n<p><strong>划重点：</strong></p>\n<p><strong>1. 使用css3硬件加速，可以让transform、opacity、filters这些动画不会引起回流重绘 。</strong></p>\n<p><strong>2. 对于动画的其它属性，比如background-color这些，还是会引起回流重绘的，不过它还是可以提升这些动画的性能。</strong></p>\n<p>本篇文章只讨论如何使用，暂不考虑其原理，之后有空会另外开篇文章说明。</p>\n<h4 id=\"如何使用\"><a href=\"#如何使用\" class=\"headerlink\" title=\"如何使用\"></a>如何使用</h4><p>常见的触发硬件加速的css属性：</p>\n<ul>\n<li>transform</li>\n<li>opacity</li>\n<li>filters</li>\n<li>Will-change</li>\n</ul>\n<h4 id=\"效果\"><a href=\"#效果\" class=\"headerlink\" title=\"效果\"></a>效果</h4><p>我们可以先看个<a href=\"https://chenjigeng.github.io/example/share/对比gpu加速/gpu加速-transform.html\" target=\"_blank\" rel=\"noopener\">例子</a>。我通过使用chrome的Performance捕获了动画一段时间里的回流重绘情况，实际结果如下图：</p>\n<p><img src=\"https://wos2.58cdn.com.cn/iJkFeDcBiJiJ/rocket/5837b1bf-9667-4a5f-b403-29b254144022.jpeg\" alt=\"image-20181210225609533\"></p>\n<p>从图中我们可以看出，在动画进行的时候，没有发生任何的回流重绘。如果感兴趣你也可以自己做下实验。</p>\n<h4 id=\"重点\"><a href=\"#重点\" class=\"headerlink\" title=\"重点\"></a>重点</h4><ul>\n<li>使用css3硬件加速，可以让transform、opacity、filters这些动画不会引起回流重绘</li>\n<li>对于动画的其它属性，比如background-color这些，还是会引起回流重绘的，不过它还是可以提升这些动画的性能。</li>\n</ul>\n<h4 id=\"css3硬件加速的坑\"><a href=\"#css3硬件加速的坑\" class=\"headerlink\" title=\"css3硬件加速的坑\"></a>css3硬件加速的坑</h4><p>当然，任何美好的东西都是会有对应的代价的，过犹不及。css3硬件加速还是有坑的:</p>\n<ul>\n<li>如果你为太多元素使用css3硬件加速，会导致内存占用较大，会有性能问题。</li>\n<li>在GPU渲染字体会导致抗锯齿无效。这是因为GPU和CPU的算法不同。因此如果你不在动画结束的时候关闭硬件加速，会产生字体模糊。</li>\n</ul>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>本文主要讲了浏览器的渲染过程、浏览器的优化机制以及如何减少甚至避免回流和重绘，希望可以帮助大家更好的理解回流重绘。</p>"},{"title":"JavaScript 中的位运算和权限设计","date":"2020-04-12T07:56:40.000Z","_content":"\n## 1. 内容概要\n\n本文主要讨论以下两个问题：\n\n- JavaScript 的位运算：先简单回顾下位运算，平时用的少，相信不少人和我一样忘的差不多了\n- 权限设计：根据位运算的特点，设计一个权限系统（添加、删除、判断等）\n<!-- more -->\n## 2. JavaScript 位运算\n\n### 2.1. Number\n\n在讲位运算之前，首先简单看下 JavaScript 中的 Number，下文需要用到。\n\n在 JavaScript 里，数字均为[基于 IEEE 754 标准的双精度 64 位的浮点数](https://zh.wikipedia.org/wiki/雙精度浮點數)，引用维基百科的图片，它的结构长这样：\n\n\n\n![img](https://wos2.58cdn.com.cn/iJkFeDcBiJiJ/rocket/7a04aac6-45b1-43a6-b20c-cd7ff147b060.jpeg)\n\n\n\n- sign bit（符号）: 用来表示正负号\n- exponent（指数）: 用来表示次方数\n- mantissa（尾数）: 用来表示精确度\n\n也就是说一个数字的范围只能在 -(2^53 -1) 至 2^53 -1 之间。\n\n> 既然讲到这里，就多说一句：0.1 + 0.2 算不准的原因也在于此。浮点数用二进制表达时是无穷的，且最多 53 位，必须截断，进而产生误差。最简单的解决办法就是放大一定倍数变成整数，计算完成后再缩小。不过更稳妥的办法是使用下文将会提到的 [math.js](https://mathjs.org/docs/datatypes/bignumbers.html#roundoff-errors) 等工具库。\n\n此外还有四种数字进制：\n\n```javascript\n// 十进制\n123456789\n0\n\n// 二进制：前缀 0b，0B\n0b10000000000000000000000000000000 // 2147483648\n0b01111111100000000000000000000000 // 2139095040\n0B00000000011111111111111111111111 // 8388607\n\n// 八进制：前缀 0o，0O（以前支持前缀 0）\n0o755 // 493\n0o644 // 420\n\n// 十六进制：前缀 0x，0X\n0xFFFFFFFFFFFFFFFFF // 295147905179352830000\n0x123456789ABCDEF   // 81985529216486900\n0XA                 // 10\n复制代码\n```\n\n好了，Number 就说这么多，接下来看 JavaScript 中的位运算。\n\n### 2.2. 位运算\n\n按位操作符将其操作数当作 32 位的比特序列（由 0 和 1 组成）操作，返回值依然是标准的 JavaScript 数值。JavaScript 中的按位操作符有：\n\n| 运算符             | 用法      | 描述                                                         |\n| :----------------- | :-------- | :----------------------------------------------------------- |\n| 按位与（AND）      | `a & b`   | 对于每一个比特位，只有两个操作数相应的比特位都是 1 时，结果才为 1，否则为 0。 |\n| 按位或（OR）       | `a ｜ b`   | 对于每一个比特位，当两个操作数相应的比特位至少有一个 1 时，结果为 1，否则为 0。 |\n| 按位异或（XOR）    | `a ^ b`   | 对于每一个比特位，当两个操作数相应的比特位有且只有一个 1 时，结果为 1，否则为 0。 |\n| 按位非（NOT）      | `~a`      | 反转操作数的比特位，即 0 变成 1，1 变成 0。                  |\n| 左移（Left shift） | `a << b`  | 将 a 的二进制形式向左移 b (< 32) 比特位，右边用 0 填充。     |\n| 有符号右移         | `a >> b`  | 将 a 的二进制表示向右移 b (< 32) 位，丢弃被移出的位。        |\n| 无符号右移         | `a >>> b` | 将 a 的二进制表示向右移 b (< 32) 位，丢弃被移出的位，并使用 0 在左侧填充。 |\n\n下面举几个例子，主要看下 `AND` 和 `OR`：\n\n```javascript\n# 例子1\n    A = 10001001\n    B = 10010000\nA | B = 10011001\n\n# 例子2\n    A = 10001001\n    C = 10001000\nA | C = 10001001\n复制代码\n# 例子1\n    A = 10001001\n    B = 10010000\nA & B = 10000000\n\n# 例子2\n    A = 10001001\n    C = 10001000\nA & C = 10001000\n复制代码\n```\n\n## 3. 位运算在权限系统中的使用\n\n传统的权限系统里，存在很多关联关系，如用户和权限的关联，用户和角色的关联。系统越大，关联关系越多，越难以维护。而引入位运算，可以巧妙的解决该问题。\n\n在讲“位运算在权限系统中的使用”之前，我们先假定两个前提，**下文所有的讨论都是基于这两个前提的**：\n\n1. 每种权限码都是唯一的（这是显然的）\n2. 所有权限码的二进制数形式，有且只有一位值为 1，其余全部为 0（`2^n`）\n\n如果用户权限和权限码，全部使用二级制数字表示，再结合上面 `AND` 和 `OR` 的例子，分析位运算的特点，不难发现：\n\n- `|` 可以用来赋予权限\n- `&` 可以用来校验权限\n\n为了讲的更明白，这里用 Linux 中的实例分析下，Linux 的文件权限分为读、写和执行，有字母和数字等多种表现形式：\n\n| 权限 | 字母表示 | 数字表示 | 二进制 |\n| :--- | :------- | :------- | :----- |\n| 读   | r        | 4        | 0b100  |\n| 写   | w        | 2        | 0b010  |\n| 执行 | x        | 1        | 0b001  |\n\n可以看到，权限用 1、2、4（也就是 `2^n`）表示，转换为二进制后，都是只有一位是 1，其余为 0。我们通过几个例子看下，如何利用二进制的特点执行权限的添加，校验和删除。\n\n### 3.1. 添加权限\n\n```javascript\nlet r = 0b100\nlet w = 0b010\nlet x = 0b001\n\n// 给用户赋全部权限（使用前面讲的 | 操作）\nlet user = r | w | x\n\nconsole.log(user)\n// 7\n\nconsole.log(user.toString(2))\n// 111\n\n//     r = 0b100\n//     w = 0b010\n//     r = 0b001\n// r|w|x = 0b111\n复制代码\n```\n\n可以看到，执行 `r | w | x` 后，`user` 的三位都是 1，表明拥有了全部三个权限。\n\n> Linux 下出现权限问题时，最粗暴的解决方案就是 `chmod 777 xxx`，这里的 `7` 就代表了：可读，可写，可执行。而三个 `7` 分别代表：文件所有者，文件所有者所在组，所有其他用户。\n\n### 3.2. 校验权限\n\n刚才演示了权限的添加，下面演示权限校验：\n\n```javascript\nlet r = 0b100\nlet w = 0b010\nlet x = 0b001\n\n// 给用户赋 r w 两个权限\nlet user = r | w\n// user = 6\n// user = 0b110 (二进制)\n\nconsole.log((user & r) === r) // true  有 r 权限\nconsole.log((user & w) === w) // true  有 w 权限\nconsole.log((user & x) === x) // false 没有 x 权限\n复制代码\n```\n\n如前所料，通过 `用户权限 & 权限 code === 权限 code` 就可以判断出用户是否拥有该权限。\n\n### 3.3. 删除权限\n\n我们讲了用 `|` 赋予权限，使用 `&` 判断权限，那么删除权限呢？删除权限的本质其实是**将指定位置上的 1 重置为 0**。上个例子里用户权限是 `0b110`，拥有读和写两个权限，现在想删除读的权限，本质上就是将第三位的 1 重置为 0，变为 `0b010`：\n\n```javascript\nlet r = 0b100\nlet w = 0b010\nlet x = 0b001\n\nlet user = 0b010;\n\nconsole.log((user & r) === r) // false 没有 r 权限\nconsole.log((user & w) === w) // true  有 w 权限\nconsole.log((user & x) === x) // false 没有 x 权限\n复制代码\n```\n\n那么具体怎么操作呢？其实有两种方案，最简单的就是异或 `^`，按照上文的介绍“当两个操作数相应的比特位有且只有一个 1 时，结果为 1，否则为 0”，所以异或其实是 toggle 操作，无则增，有则减：\n\n```javascript\nlet r    = 0b100\nlet w    = 0b010\nlet x    = 0b001\nlet user = 0b110 // 有 r w 两个权限\n\n// 执行异或操作，删除 r 权限\nuser = user ^ r\n\nconsole.log((user & r) === r) // false 没有 r 权限\nconsole.log((user & w) === w) // true  有 w 权限\nconsole.log((user & x) === x) // false 没有 x 权限\n\nconsole.log(user.toString(2)) // 现在 user 是 0b010\n\n// 再执行一次异或操作\nuser = user ^ r\n\nconsole.log((user & r) === r) // true  有 r 权限\nconsole.log((user & w) === w) // true  有 w 权限\nconsole.log((user & x) === x) // false 没有 x 权限\n\nconsole.log(user.toString(2)) // 现在 user 又变回 0b110\n复制代码\n```\n\n那么如果单纯的想删除权限（而不是无则增，有则减）怎么办呢？答案是执行 `&(~code)`，先取反，再执行与操作：\n\n```javascript\nlet r    = 0b100\nlet w    = 0b010\nlet x    = 0b001\nlet user = 0b110 // 有 r w 两个权限\n\n// 删除 r 权限\nuser = user & (~r)\n\nconsole.log((user & r) === r) // false 没有 r 权限\nconsole.log((user & w) === w) // true  有 w 权限\nconsole.log((user & x) === x) // false 没有 x 权限\n\nconsole.log(user.toString(2)) // 现在 user 是 0b010\n\n// 再执行一次\nuser = user & (~r)\n\nconsole.log((user & r) === r) // false 没有 r 权限\nconsole.log((user & w) === w) // true  有 w 权限\nconsole.log((user & x) === x) // false 没有 x 权限\n\nconsole.log(user.toString(2)) // 现在 user 还是 0b010，并不会新增\n复制代码\n```\n\n## 4. 局限性和解决办法\n\n前面我们回顾了 JavaScript 中的 Number 和位运算，并且了解了基于位运算的权限系统原理和 Linux 文件系统权限的实例。\n\n上述的所有都有前提条件：1、**每种权限码都是唯一的**；2、**每个权限码的二进制数形式，有且只有一位值为 1（`2^n`）**。也就是说，权限码只能是 1, 2, 4, 8,...,1024,...而上文提到，一个数字的范围只能在 -(2^53 -1) 和 2^53 -1 之间，JavaScript 的按位操作符又是将其操作数当作 **32 位**比特序列的。那么同一个应用下可用的权限数就非常有限了。这也是该方案的局限性。\n\n为了突破这个限制，这里提出一个叫“权限空间”的概念，既然权限数有限，那么不妨就多开辟几个空间来存放。\n\n基于权限空间，我们定义两个格式：\n\n1. **权限 code**，字符串，形如 `index,pos`。其中 `pos` 表示 32 位二进制数中 1 的位置（其余全是 0）； `index` 表示**权限空间**，用于突破 JavaScript 数字位数的限制，是从 0 开始的正整数，每个权限code都要归属于一个权限空间。`index` 和 `pos` 使用英文逗号隔开。\n2. **用户权限**，字符串，形如 `1,16,16`。英文逗号分隔每一个**权限空间**的权限值。例如 `1,16,16` 的意思就是，权限空间 0 的权限值是 1，权限空间 1 的权限值是 16，权限空间 2 的权限是 16。\n\n干说可能不好懂，直接上代码：\n\n```javascript\n// 用户的权限 code\nlet userCode = \"\"\n\n// 假设系统里有这些权限\n// 纯模拟，正常情况下是按顺序的，如 0,0 0,1 0,2 ...，尽可能占满一个权限空间，再使用下一个\nconst permissions = {\n  SYS_SETTING: {\n    value: \"0,0\",   // index = 0, pos = 0\n    info: \"系统权限\"\n  },\n  DATA_ADMIN: {\n    value: \"0,8\",\n    info: \"数据库权限\"\n  },\n  USER_ADD: {\n    value: \"0,22\",\n    info: \"用户新增权限\"\n  },\n  USER_EDIT: {\n    value: \"0,30\",\n    info: \"用户编辑权限\"\n  },\n  USER_VIEW: {\n    value: \"1,2\",   // index = 1, pos = 2\n    info: \"用户查看权限\"\n  },\n  USER_DELETE: {\n    value: \"1,17\",\n    info: \"用户删除权限\"\n  },\n  POST_ADD: {\n    value: \"1,28\",\n    info: \"文章新增权限\"\n  },\n  POST_EDIT: {\n    value: \"2,4\",\n    info: \"文章编辑权限\"\n  },\n  POST_VIEW: {\n    value: \"2,19\",\n    info: \"文章查看权限\"\n  },\n  POST_DELETE: {\n    value: \"2,26\",\n    info: \"文章删除权限\"\n  }\n}\n\n// 添加权限\nconst addPermission = (userCode, permission) => {\n  const userPermission = userCode ? userCode.split(\",\") : []\n  const [index, pos] = permission.value.split(\",\")\n\n  userPermission[index] = (userPermission[index] || 0) | Math.pow(2, pos)\n\n  return userPermission.join(\",\")\n}\n\n// 删除权限\nconst delPermission = (userCode, permission) => {\n  const userPermission = userCode ? userCode.split(\",\") : []\n  const [index, pos] = permission.value.split(\",\")\n\n  userPermission[index] = (userPermission[index] || 0) & (~Math.pow(2, pos))\n\n  return userPermission.join(\",\")\n}\n\n// 判断是否有权限\nconst hasPermission = (userCode, permission) => {\n  const userPermission = userCode ? userCode.split(\",\") : []\n  const [index, pos] = permission.value.split(\",\")\n  const permissionValue = Math.pow(2, pos)\n\n  return (userPermission[index] & permissionValue) === permissionValue\n}\n\n// 列出用户拥有的全部权限\nconst listPermission = userCode => {\n  const results = []\n\n  if (!userCode) {\n    return results\n  }\n\n  Object.values(permissions).forEach(permission => {\n    if (hasPermission(userCode, permission)) {\n      results.push(permission.info)\n    }\n  })\n\n  return results\n}\n\nconst log = () => {\n  console.log(`userCode: ${JSON.stringify(userCode, null, \" \")}`)\n  console.log(`权限列表: ${listPermission(userCode).join(\"; \")}`)\n  console.log(\"\")\n}\n\nuserCode = addPermission(userCode, permissions.SYS_SETTING)\nlog()\n// userCode: \"1\"\n// 权限列表: 系统权限\n\nuserCode = addPermission(userCode, permissions.POST_EDIT)\nlog()\n// userCode: \"1,,16\"\n// 权限列表: 系统权限; 文章编辑权限\n\nuserCode = addPermission(userCode, permissions.USER_EDIT)\nlog()\n// userCode: \"1073741825,,16\"\n// 权限列表: 系统权限; 用户编辑权限; 文章编辑权限\n\nuserCode = addPermission(userCode, permissions.USER_DELETE)\nlog()\n// userCode: \"1073741825,131072,16\"\n// 权限列表: 系统权限; 用户编辑权限; 用户删除权限; 文章编辑权限\n\nuserCode = delPermission(userCode, permissions.USER_EDIT)\nlog()\n// userCode: \"1,131072,16\"\n// 权限列表: 系统权限; 用户删除权限; 文章编辑权限\n\nuserCode = delPermission(userCode, permissions.USER_EDIT)\nlog()\n// userCode: \"1,131072,16\"\n// 权限列表: 系统权限; 用户删除权限; 文章编辑权限\n\nuserCode = delPermission(userCode, permissions.USER_DELETE)\nuserCode = delPermission(userCode, permissions.SYS_SETTING)\nuserCode = delPermission(userCode, permissions.POST_EDIT)\nlog()\n// userCode: \"0,0,0\"\n// 权限列表: \n\nuserCode = addPermission(userCode, permissions.SYS_SETTING)\nlog()\n// userCode: \"1,0,0\"\n// 权限列表: 系统权限\n复制代码\n```\n\n除了通过引入**权限空间**的概念突破二进制运算的位数限制，还可以使用 [math.js](http://mathjs.org) 的 `bignumber`，直接运算超过 32 位的二进制数，具体可以看它的文档，这里就不细说了。\n\n## 5. 适用场景和问题\n\n如果按照当前使用最广泛的 [RBAC](https://zh.wikipedia.org/wiki/以角色為基礎的存取控制) 模型设计权限系统，那么一般会有这么几个实体：应用，权限，角色，用户。用户权限可以直接来自权限，也可以来自角色：\n\n- 一个应用下有多个权限\n- 权限和角色是多对多的关系\n- 用户和角色是多对多的关系\n- 用户和权限是多对多的关系\n\n在此种模型下，一般会有用户与权限，用户与角色，角色与权限的对应关系表。想象一个商城后台权限管理系统，可能会有上万，甚至十几万店铺（应用），每个店铺可能会有数十个用户，角色，权限。随着业务的不断发展，刚才提到的那三张对应关系表会越来越大，越来越难以维护。\n\n而进制转换的方法则可以省略对应关系表，减少查询，节省空间。当然，省略掉对应关系不是没有坏处的，例如下面几个问题：\n\n- 如何高效的查找我的权限？\n- 如何高效的查找拥有某权限的所有用户？\n- 如何控制权限的有效期？\n\n所以进制转换的方案比较适合刚才提到的应用极其多，而每个应用中用户，权限，角色数量较少的场景。\n\n## 6. 其他方案\n\n除了二进制方案，当然还有其他方案可以达到类似的效果，例如直接使用一个1和0组成的字符串，权限点对应index，1表示拥有权限，0表示没有权限。举个例子：添加 0、删除 1、编辑 2，用户A拥有添加和编辑的权限，则 userCode 为 101；用户B拥有全部权限，userCode 为 111。这种方案比二进制转换简单，但是浪费空间。\n\n还有利用质数的方案，权限点全部为质数，用户权限为他所拥有的全部权限点的乘积。如：权限点是 2、3、5、7、11，用户权限是 5 * 7 * 11 = 385。这种方案麻烦的地方在于获取质数（新增权限点）和质因数分解（判断权限），权限点特别多的时候就快成 RSA 了，如果只有增删改查个别几个权限，倒是可以考虑。\n\n## 7. 参考\n\n- [MDN：JavaScript 数字和日期](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Numbers_and_dates)\n- [双精度浮点类型](https://zh.wikipedia.org/wiki/雙精度浮點數)\n- [MDN：按位操作符](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Bitwise_Operators)\n- [【小知识大道理】被忽视的位运算](https://www.jianshu.com/p/11f331d97ec2)\n- [为什么不要在 JavaScript 中使用位操作符？](http://jerryzou.com/posts/do-you-really-want-use-bit-operators-in-JavaScript/)\n- [角色权限设计的100种解法](https://mp.weixin.qq.com/s/MKljuxfDMmopr_MrnYljGw)\n- [权限系统与RBAC模型概述](http://www.cnblogs.com/shijiaqi1066/p/3793894.html)\n- [权限设计及算法](https://blog.csdn.net/yingchunhua365/article/details/14090461)\n- [基于角色的访问控制](https://zh.wikipedia.org/wiki/以角色為基礎的存取控制)\n\n","source":"_posts/JavaScript 中的位运算和权限设计.md","raw":"---\ntitle: JavaScript 中的位运算和权限设计\ndate: 2020-04-12 15:56:40\ntags:\n    -算法\ncategories:\n    - 技术分享\n---\n\n## 1. 内容概要\n\n本文主要讨论以下两个问题：\n\n- JavaScript 的位运算：先简单回顾下位运算，平时用的少，相信不少人和我一样忘的差不多了\n- 权限设计：根据位运算的特点，设计一个权限系统（添加、删除、判断等）\n<!-- more -->\n## 2. JavaScript 位运算\n\n### 2.1. Number\n\n在讲位运算之前，首先简单看下 JavaScript 中的 Number，下文需要用到。\n\n在 JavaScript 里，数字均为[基于 IEEE 754 标准的双精度 64 位的浮点数](https://zh.wikipedia.org/wiki/雙精度浮點數)，引用维基百科的图片，它的结构长这样：\n\n\n\n![img](https://wos2.58cdn.com.cn/iJkFeDcBiJiJ/rocket/7a04aac6-45b1-43a6-b20c-cd7ff147b060.jpeg)\n\n\n\n- sign bit（符号）: 用来表示正负号\n- exponent（指数）: 用来表示次方数\n- mantissa（尾数）: 用来表示精确度\n\n也就是说一个数字的范围只能在 -(2^53 -1) 至 2^53 -1 之间。\n\n> 既然讲到这里，就多说一句：0.1 + 0.2 算不准的原因也在于此。浮点数用二进制表达时是无穷的，且最多 53 位，必须截断，进而产生误差。最简单的解决办法就是放大一定倍数变成整数，计算完成后再缩小。不过更稳妥的办法是使用下文将会提到的 [math.js](https://mathjs.org/docs/datatypes/bignumbers.html#roundoff-errors) 等工具库。\n\n此外还有四种数字进制：\n\n```javascript\n// 十进制\n123456789\n0\n\n// 二进制：前缀 0b，0B\n0b10000000000000000000000000000000 // 2147483648\n0b01111111100000000000000000000000 // 2139095040\n0B00000000011111111111111111111111 // 8388607\n\n// 八进制：前缀 0o，0O（以前支持前缀 0）\n0o755 // 493\n0o644 // 420\n\n// 十六进制：前缀 0x，0X\n0xFFFFFFFFFFFFFFFFF // 295147905179352830000\n0x123456789ABCDEF   // 81985529216486900\n0XA                 // 10\n复制代码\n```\n\n好了，Number 就说这么多，接下来看 JavaScript 中的位运算。\n\n### 2.2. 位运算\n\n按位操作符将其操作数当作 32 位的比特序列（由 0 和 1 组成）操作，返回值依然是标准的 JavaScript 数值。JavaScript 中的按位操作符有：\n\n| 运算符             | 用法      | 描述                                                         |\n| :----------------- | :-------- | :----------------------------------------------------------- |\n| 按位与（AND）      | `a & b`   | 对于每一个比特位，只有两个操作数相应的比特位都是 1 时，结果才为 1，否则为 0。 |\n| 按位或（OR）       | `a ｜ b`   | 对于每一个比特位，当两个操作数相应的比特位至少有一个 1 时，结果为 1，否则为 0。 |\n| 按位异或（XOR）    | `a ^ b`   | 对于每一个比特位，当两个操作数相应的比特位有且只有一个 1 时，结果为 1，否则为 0。 |\n| 按位非（NOT）      | `~a`      | 反转操作数的比特位，即 0 变成 1，1 变成 0。                  |\n| 左移（Left shift） | `a << b`  | 将 a 的二进制形式向左移 b (< 32) 比特位，右边用 0 填充。     |\n| 有符号右移         | `a >> b`  | 将 a 的二进制表示向右移 b (< 32) 位，丢弃被移出的位。        |\n| 无符号右移         | `a >>> b` | 将 a 的二进制表示向右移 b (< 32) 位，丢弃被移出的位，并使用 0 在左侧填充。 |\n\n下面举几个例子，主要看下 `AND` 和 `OR`：\n\n```javascript\n# 例子1\n    A = 10001001\n    B = 10010000\nA | B = 10011001\n\n# 例子2\n    A = 10001001\n    C = 10001000\nA | C = 10001001\n复制代码\n# 例子1\n    A = 10001001\n    B = 10010000\nA & B = 10000000\n\n# 例子2\n    A = 10001001\n    C = 10001000\nA & C = 10001000\n复制代码\n```\n\n## 3. 位运算在权限系统中的使用\n\n传统的权限系统里，存在很多关联关系，如用户和权限的关联，用户和角色的关联。系统越大，关联关系越多，越难以维护。而引入位运算，可以巧妙的解决该问题。\n\n在讲“位运算在权限系统中的使用”之前，我们先假定两个前提，**下文所有的讨论都是基于这两个前提的**：\n\n1. 每种权限码都是唯一的（这是显然的）\n2. 所有权限码的二进制数形式，有且只有一位值为 1，其余全部为 0（`2^n`）\n\n如果用户权限和权限码，全部使用二级制数字表示，再结合上面 `AND` 和 `OR` 的例子，分析位运算的特点，不难发现：\n\n- `|` 可以用来赋予权限\n- `&` 可以用来校验权限\n\n为了讲的更明白，这里用 Linux 中的实例分析下，Linux 的文件权限分为读、写和执行，有字母和数字等多种表现形式：\n\n| 权限 | 字母表示 | 数字表示 | 二进制 |\n| :--- | :------- | :------- | :----- |\n| 读   | r        | 4        | 0b100  |\n| 写   | w        | 2        | 0b010  |\n| 执行 | x        | 1        | 0b001  |\n\n可以看到，权限用 1、2、4（也就是 `2^n`）表示，转换为二进制后，都是只有一位是 1，其余为 0。我们通过几个例子看下，如何利用二进制的特点执行权限的添加，校验和删除。\n\n### 3.1. 添加权限\n\n```javascript\nlet r = 0b100\nlet w = 0b010\nlet x = 0b001\n\n// 给用户赋全部权限（使用前面讲的 | 操作）\nlet user = r | w | x\n\nconsole.log(user)\n// 7\n\nconsole.log(user.toString(2))\n// 111\n\n//     r = 0b100\n//     w = 0b010\n//     r = 0b001\n// r|w|x = 0b111\n复制代码\n```\n\n可以看到，执行 `r | w | x` 后，`user` 的三位都是 1，表明拥有了全部三个权限。\n\n> Linux 下出现权限问题时，最粗暴的解决方案就是 `chmod 777 xxx`，这里的 `7` 就代表了：可读，可写，可执行。而三个 `7` 分别代表：文件所有者，文件所有者所在组，所有其他用户。\n\n### 3.2. 校验权限\n\n刚才演示了权限的添加，下面演示权限校验：\n\n```javascript\nlet r = 0b100\nlet w = 0b010\nlet x = 0b001\n\n// 给用户赋 r w 两个权限\nlet user = r | w\n// user = 6\n// user = 0b110 (二进制)\n\nconsole.log((user & r) === r) // true  有 r 权限\nconsole.log((user & w) === w) // true  有 w 权限\nconsole.log((user & x) === x) // false 没有 x 权限\n复制代码\n```\n\n如前所料，通过 `用户权限 & 权限 code === 权限 code` 就可以判断出用户是否拥有该权限。\n\n### 3.3. 删除权限\n\n我们讲了用 `|` 赋予权限，使用 `&` 判断权限，那么删除权限呢？删除权限的本质其实是**将指定位置上的 1 重置为 0**。上个例子里用户权限是 `0b110`，拥有读和写两个权限，现在想删除读的权限，本质上就是将第三位的 1 重置为 0，变为 `0b010`：\n\n```javascript\nlet r = 0b100\nlet w = 0b010\nlet x = 0b001\n\nlet user = 0b010;\n\nconsole.log((user & r) === r) // false 没有 r 权限\nconsole.log((user & w) === w) // true  有 w 权限\nconsole.log((user & x) === x) // false 没有 x 权限\n复制代码\n```\n\n那么具体怎么操作呢？其实有两种方案，最简单的就是异或 `^`，按照上文的介绍“当两个操作数相应的比特位有且只有一个 1 时，结果为 1，否则为 0”，所以异或其实是 toggle 操作，无则增，有则减：\n\n```javascript\nlet r    = 0b100\nlet w    = 0b010\nlet x    = 0b001\nlet user = 0b110 // 有 r w 两个权限\n\n// 执行异或操作，删除 r 权限\nuser = user ^ r\n\nconsole.log((user & r) === r) // false 没有 r 权限\nconsole.log((user & w) === w) // true  有 w 权限\nconsole.log((user & x) === x) // false 没有 x 权限\n\nconsole.log(user.toString(2)) // 现在 user 是 0b010\n\n// 再执行一次异或操作\nuser = user ^ r\n\nconsole.log((user & r) === r) // true  有 r 权限\nconsole.log((user & w) === w) // true  有 w 权限\nconsole.log((user & x) === x) // false 没有 x 权限\n\nconsole.log(user.toString(2)) // 现在 user 又变回 0b110\n复制代码\n```\n\n那么如果单纯的想删除权限（而不是无则增，有则减）怎么办呢？答案是执行 `&(~code)`，先取反，再执行与操作：\n\n```javascript\nlet r    = 0b100\nlet w    = 0b010\nlet x    = 0b001\nlet user = 0b110 // 有 r w 两个权限\n\n// 删除 r 权限\nuser = user & (~r)\n\nconsole.log((user & r) === r) // false 没有 r 权限\nconsole.log((user & w) === w) // true  有 w 权限\nconsole.log((user & x) === x) // false 没有 x 权限\n\nconsole.log(user.toString(2)) // 现在 user 是 0b010\n\n// 再执行一次\nuser = user & (~r)\n\nconsole.log((user & r) === r) // false 没有 r 权限\nconsole.log((user & w) === w) // true  有 w 权限\nconsole.log((user & x) === x) // false 没有 x 权限\n\nconsole.log(user.toString(2)) // 现在 user 还是 0b010，并不会新增\n复制代码\n```\n\n## 4. 局限性和解决办法\n\n前面我们回顾了 JavaScript 中的 Number 和位运算，并且了解了基于位运算的权限系统原理和 Linux 文件系统权限的实例。\n\n上述的所有都有前提条件：1、**每种权限码都是唯一的**；2、**每个权限码的二进制数形式，有且只有一位值为 1（`2^n`）**。也就是说，权限码只能是 1, 2, 4, 8,...,1024,...而上文提到，一个数字的范围只能在 -(2^53 -1) 和 2^53 -1 之间，JavaScript 的按位操作符又是将其操作数当作 **32 位**比特序列的。那么同一个应用下可用的权限数就非常有限了。这也是该方案的局限性。\n\n为了突破这个限制，这里提出一个叫“权限空间”的概念，既然权限数有限，那么不妨就多开辟几个空间来存放。\n\n基于权限空间，我们定义两个格式：\n\n1. **权限 code**，字符串，形如 `index,pos`。其中 `pos` 表示 32 位二进制数中 1 的位置（其余全是 0）； `index` 表示**权限空间**，用于突破 JavaScript 数字位数的限制，是从 0 开始的正整数，每个权限code都要归属于一个权限空间。`index` 和 `pos` 使用英文逗号隔开。\n2. **用户权限**，字符串，形如 `1,16,16`。英文逗号分隔每一个**权限空间**的权限值。例如 `1,16,16` 的意思就是，权限空间 0 的权限值是 1，权限空间 1 的权限值是 16，权限空间 2 的权限是 16。\n\n干说可能不好懂，直接上代码：\n\n```javascript\n// 用户的权限 code\nlet userCode = \"\"\n\n// 假设系统里有这些权限\n// 纯模拟，正常情况下是按顺序的，如 0,0 0,1 0,2 ...，尽可能占满一个权限空间，再使用下一个\nconst permissions = {\n  SYS_SETTING: {\n    value: \"0,0\",   // index = 0, pos = 0\n    info: \"系统权限\"\n  },\n  DATA_ADMIN: {\n    value: \"0,8\",\n    info: \"数据库权限\"\n  },\n  USER_ADD: {\n    value: \"0,22\",\n    info: \"用户新增权限\"\n  },\n  USER_EDIT: {\n    value: \"0,30\",\n    info: \"用户编辑权限\"\n  },\n  USER_VIEW: {\n    value: \"1,2\",   // index = 1, pos = 2\n    info: \"用户查看权限\"\n  },\n  USER_DELETE: {\n    value: \"1,17\",\n    info: \"用户删除权限\"\n  },\n  POST_ADD: {\n    value: \"1,28\",\n    info: \"文章新增权限\"\n  },\n  POST_EDIT: {\n    value: \"2,4\",\n    info: \"文章编辑权限\"\n  },\n  POST_VIEW: {\n    value: \"2,19\",\n    info: \"文章查看权限\"\n  },\n  POST_DELETE: {\n    value: \"2,26\",\n    info: \"文章删除权限\"\n  }\n}\n\n// 添加权限\nconst addPermission = (userCode, permission) => {\n  const userPermission = userCode ? userCode.split(\",\") : []\n  const [index, pos] = permission.value.split(\",\")\n\n  userPermission[index] = (userPermission[index] || 0) | Math.pow(2, pos)\n\n  return userPermission.join(\",\")\n}\n\n// 删除权限\nconst delPermission = (userCode, permission) => {\n  const userPermission = userCode ? userCode.split(\",\") : []\n  const [index, pos] = permission.value.split(\",\")\n\n  userPermission[index] = (userPermission[index] || 0) & (~Math.pow(2, pos))\n\n  return userPermission.join(\",\")\n}\n\n// 判断是否有权限\nconst hasPermission = (userCode, permission) => {\n  const userPermission = userCode ? userCode.split(\",\") : []\n  const [index, pos] = permission.value.split(\",\")\n  const permissionValue = Math.pow(2, pos)\n\n  return (userPermission[index] & permissionValue) === permissionValue\n}\n\n// 列出用户拥有的全部权限\nconst listPermission = userCode => {\n  const results = []\n\n  if (!userCode) {\n    return results\n  }\n\n  Object.values(permissions).forEach(permission => {\n    if (hasPermission(userCode, permission)) {\n      results.push(permission.info)\n    }\n  })\n\n  return results\n}\n\nconst log = () => {\n  console.log(`userCode: ${JSON.stringify(userCode, null, \" \")}`)\n  console.log(`权限列表: ${listPermission(userCode).join(\"; \")}`)\n  console.log(\"\")\n}\n\nuserCode = addPermission(userCode, permissions.SYS_SETTING)\nlog()\n// userCode: \"1\"\n// 权限列表: 系统权限\n\nuserCode = addPermission(userCode, permissions.POST_EDIT)\nlog()\n// userCode: \"1,,16\"\n// 权限列表: 系统权限; 文章编辑权限\n\nuserCode = addPermission(userCode, permissions.USER_EDIT)\nlog()\n// userCode: \"1073741825,,16\"\n// 权限列表: 系统权限; 用户编辑权限; 文章编辑权限\n\nuserCode = addPermission(userCode, permissions.USER_DELETE)\nlog()\n// userCode: \"1073741825,131072,16\"\n// 权限列表: 系统权限; 用户编辑权限; 用户删除权限; 文章编辑权限\n\nuserCode = delPermission(userCode, permissions.USER_EDIT)\nlog()\n// userCode: \"1,131072,16\"\n// 权限列表: 系统权限; 用户删除权限; 文章编辑权限\n\nuserCode = delPermission(userCode, permissions.USER_EDIT)\nlog()\n// userCode: \"1,131072,16\"\n// 权限列表: 系统权限; 用户删除权限; 文章编辑权限\n\nuserCode = delPermission(userCode, permissions.USER_DELETE)\nuserCode = delPermission(userCode, permissions.SYS_SETTING)\nuserCode = delPermission(userCode, permissions.POST_EDIT)\nlog()\n// userCode: \"0,0,0\"\n// 权限列表: \n\nuserCode = addPermission(userCode, permissions.SYS_SETTING)\nlog()\n// userCode: \"1,0,0\"\n// 权限列表: 系统权限\n复制代码\n```\n\n除了通过引入**权限空间**的概念突破二进制运算的位数限制，还可以使用 [math.js](http://mathjs.org) 的 `bignumber`，直接运算超过 32 位的二进制数，具体可以看它的文档，这里就不细说了。\n\n## 5. 适用场景和问题\n\n如果按照当前使用最广泛的 [RBAC](https://zh.wikipedia.org/wiki/以角色為基礎的存取控制) 模型设计权限系统，那么一般会有这么几个实体：应用，权限，角色，用户。用户权限可以直接来自权限，也可以来自角色：\n\n- 一个应用下有多个权限\n- 权限和角色是多对多的关系\n- 用户和角色是多对多的关系\n- 用户和权限是多对多的关系\n\n在此种模型下，一般会有用户与权限，用户与角色，角色与权限的对应关系表。想象一个商城后台权限管理系统，可能会有上万，甚至十几万店铺（应用），每个店铺可能会有数十个用户，角色，权限。随着业务的不断发展，刚才提到的那三张对应关系表会越来越大，越来越难以维护。\n\n而进制转换的方法则可以省略对应关系表，减少查询，节省空间。当然，省略掉对应关系不是没有坏处的，例如下面几个问题：\n\n- 如何高效的查找我的权限？\n- 如何高效的查找拥有某权限的所有用户？\n- 如何控制权限的有效期？\n\n所以进制转换的方案比较适合刚才提到的应用极其多，而每个应用中用户，权限，角色数量较少的场景。\n\n## 6. 其他方案\n\n除了二进制方案，当然还有其他方案可以达到类似的效果，例如直接使用一个1和0组成的字符串，权限点对应index，1表示拥有权限，0表示没有权限。举个例子：添加 0、删除 1、编辑 2，用户A拥有添加和编辑的权限，则 userCode 为 101；用户B拥有全部权限，userCode 为 111。这种方案比二进制转换简单，但是浪费空间。\n\n还有利用质数的方案，权限点全部为质数，用户权限为他所拥有的全部权限点的乘积。如：权限点是 2、3、5、7、11，用户权限是 5 * 7 * 11 = 385。这种方案麻烦的地方在于获取质数（新增权限点）和质因数分解（判断权限），权限点特别多的时候就快成 RSA 了，如果只有增删改查个别几个权限，倒是可以考虑。\n\n## 7. 参考\n\n- [MDN：JavaScript 数字和日期](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Numbers_and_dates)\n- [双精度浮点类型](https://zh.wikipedia.org/wiki/雙精度浮點數)\n- [MDN：按位操作符](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Bitwise_Operators)\n- [【小知识大道理】被忽视的位运算](https://www.jianshu.com/p/11f331d97ec2)\n- [为什么不要在 JavaScript 中使用位操作符？](http://jerryzou.com/posts/do-you-really-want-use-bit-operators-in-JavaScript/)\n- [角色权限设计的100种解法](https://mp.weixin.qq.com/s/MKljuxfDMmopr_MrnYljGw)\n- [权限系统与RBAC模型概述](http://www.cnblogs.com/shijiaqi1066/p/3793894.html)\n- [权限设计及算法](https://blog.csdn.net/yingchunhua365/article/details/14090461)\n- [基于角色的访问控制](https://zh.wikipedia.org/wiki/以角色為基礎的存取控制)\n\n","slug":"JavaScript 中的位运算和权限设计","published":1,"updated":"2020-05-15T06:28:04.632Z","_id":"cka7sznxa0004tu9mg5mm2kb4","comments":1,"layout":"post","photos":[],"link":"","content":"<h2 id=\"1-内容概要\"><a href=\"#1-内容概要\" class=\"headerlink\" title=\"1. 内容概要\"></a>1. 内容概要</h2><p>本文主要讨论以下两个问题：</p>\n<ul>\n<li>JavaScript 的位运算：先简单回顾下位运算，平时用的少，相信不少人和我一样忘的差不多了</li>\n<li>权限设计：根据位运算的特点，设计一个权限系统（添加、删除、判断等）<a id=\"more\"></a>\n<h2 id=\"2-JavaScript-位运算\"><a href=\"#2-JavaScript-位运算\" class=\"headerlink\" title=\"2. JavaScript 位运算\"></a>2. JavaScript 位运算</h2></li>\n</ul>\n<h3 id=\"2-1-Number\"><a href=\"#2-1-Number\" class=\"headerlink\" title=\"2.1. Number\"></a>2.1. Number</h3><p>在讲位运算之前，首先简单看下 JavaScript 中的 Number，下文需要用到。</p>\n<p>在 JavaScript 里，数字均为<a href=\"https://zh.wikipedia.org/wiki/雙精度浮點數\" target=\"_blank\" rel=\"noopener\">基于 IEEE 754 标准的双精度 64 位的浮点数</a>，引用维基百科的图片，它的结构长这样：</p>\n<p><img src=\"https://wos2.58cdn.com.cn/iJkFeDcBiJiJ/rocket/7a04aac6-45b1-43a6-b20c-cd7ff147b060.jpeg\" alt=\"img\"></p>\n<ul>\n<li>sign bit（符号）: 用来表示正负号</li>\n<li>exponent（指数）: 用来表示次方数</li>\n<li>mantissa（尾数）: 用来表示精确度</li>\n</ul>\n<p>也就是说一个数字的范围只能在 -(2^53 -1) 至 2^53 -1 之间。</p>\n<blockquote>\n<p>既然讲到这里，就多说一句：0.1 + 0.2 算不准的原因也在于此。浮点数用二进制表达时是无穷的，且最多 53 位，必须截断，进而产生误差。最简单的解决办法就是放大一定倍数变成整数，计算完成后再缩小。不过更稳妥的办法是使用下文将会提到的 <a href=\"https://mathjs.org/docs/datatypes/bignumbers.html#roundoff-errors\" target=\"_blank\" rel=\"noopener\">math.js</a> 等工具库。</p>\n</blockquote>\n<p>此外还有四种数字进制：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 十进制</span></span><br><span class=\"line\"><span class=\"number\">123456789</span></span><br><span class=\"line\"><span class=\"number\">0</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 二进制：前缀 0b，0B</span></span><br><span class=\"line\"><span class=\"number\">0b10000000000000000000000000000000</span> <span class=\"comment\">// 2147483648</span></span><br><span class=\"line\"><span class=\"number\">0b01111111100000000000000000000000</span> <span class=\"comment\">// 2139095040</span></span><br><span class=\"line\"><span class=\"number\">0B00000000011111111111111111111111</span> <span class=\"comment\">// 8388607</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 八进制：前缀 0o，0O（以前支持前缀 0）</span></span><br><span class=\"line\"><span class=\"number\">0o755</span> <span class=\"comment\">// 493</span></span><br><span class=\"line\"><span class=\"number\">0o644</span> <span class=\"comment\">// 420</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 十六进制：前缀 0x，0X</span></span><br><span class=\"line\"><span class=\"number\">0xFFFFFFFFFFFFFFFFF</span> <span class=\"comment\">// 295147905179352830000</span></span><br><span class=\"line\"><span class=\"number\">0x123456789ABCDEF</span>   <span class=\"comment\">// 81985529216486900</span></span><br><span class=\"line\"><span class=\"number\">0XA</span>                 <span class=\"comment\">// 10</span></span><br><span class=\"line\">复制代码</span><br></pre></td></tr></table></figure>\n<p>好了，Number 就说这么多，接下来看 JavaScript 中的位运算。</p>\n<h3 id=\"2-2-位运算\"><a href=\"#2-2-位运算\" class=\"headerlink\" title=\"2.2. 位运算\"></a>2.2. 位运算</h3><p>按位操作符将其操作数当作 32 位的比特序列（由 0 和 1 组成）操作，返回值依然是标准的 JavaScript 数值。JavaScript 中的按位操作符有：</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">运算符</th>\n<th style=\"text-align:left\">用法</th>\n<th style=\"text-align:left\">描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">按位与（AND）</td>\n<td style=\"text-align:left\"><code>a &amp; b</code></td>\n<td style=\"text-align:left\">对于每一个比特位，只有两个操作数相应的比特位都是 1 时，结果才为 1，否则为 0。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">按位或（OR）</td>\n<td style=\"text-align:left\"><code>a ｜ b</code></td>\n<td style=\"text-align:left\">对于每一个比特位，当两个操作数相应的比特位至少有一个 1 时，结果为 1，否则为 0。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">按位异或（XOR）</td>\n<td style=\"text-align:left\"><code>a ^ b</code></td>\n<td style=\"text-align:left\">对于每一个比特位，当两个操作数相应的比特位有且只有一个 1 时，结果为 1，否则为 0。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">按位非（NOT）</td>\n<td style=\"text-align:left\"><code>~a</code></td>\n<td style=\"text-align:left\">反转操作数的比特位，即 0 变成 1，1 变成 0。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">左移（Left shift）</td>\n<td style=\"text-align:left\"><code>a &lt;&lt; b</code></td>\n<td style=\"text-align:left\">将 a 的二进制形式向左移 b (&lt; 32) 比特位，右边用 0 填充。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">有符号右移</td>\n<td style=\"text-align:left\"><code>a &gt;&gt; b</code></td>\n<td style=\"text-align:left\">将 a 的二进制表示向右移 b (&lt; 32) 位，丢弃被移出的位。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">无符号右移</td>\n<td style=\"text-align:left\"><code>a &gt;&gt;&gt; b</code></td>\n<td style=\"text-align:left\">将 a 的二进制表示向右移 b (&lt; 32) 位，丢弃被移出的位，并使用 0 在左侧填充。</td>\n</tr>\n</tbody>\n</table>\n<p>下面举几个例子，主要看下 <code>AND</code> 和 <code>OR</code>：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 例子1</span><br><span class=\"line\">    A = <span class=\"number\">10001001</span></span><br><span class=\"line\">    B = <span class=\"number\">10010000</span></span><br><span class=\"line\">A | B = <span class=\"number\">10011001</span></span><br><span class=\"line\"></span><br><span class=\"line\"># 例子2</span><br><span class=\"line\">    A = <span class=\"number\">10001001</span></span><br><span class=\"line\">    C = <span class=\"number\">10001000</span></span><br><span class=\"line\">A | C = <span class=\"number\">10001001</span></span><br><span class=\"line\">复制代码</span><br><span class=\"line\"># 例子1</span><br><span class=\"line\">    A = <span class=\"number\">10001001</span></span><br><span class=\"line\">    B = <span class=\"number\">10010000</span></span><br><span class=\"line\">A &amp; B = <span class=\"number\">10000000</span></span><br><span class=\"line\"></span><br><span class=\"line\"># 例子2</span><br><span class=\"line\">    A = <span class=\"number\">10001001</span></span><br><span class=\"line\">    C = <span class=\"number\">10001000</span></span><br><span class=\"line\">A &amp; C = <span class=\"number\">10001000</span></span><br><span class=\"line\">复制代码</span><br></pre></td></tr></table></figure>\n<h2 id=\"3-位运算在权限系统中的使用\"><a href=\"#3-位运算在权限系统中的使用\" class=\"headerlink\" title=\"3. 位运算在权限系统中的使用\"></a>3. 位运算在权限系统中的使用</h2><p>传统的权限系统里，存在很多关联关系，如用户和权限的关联，用户和角色的关联。系统越大，关联关系越多，越难以维护。而引入位运算，可以巧妙的解决该问题。</p>\n<p>在讲“位运算在权限系统中的使用”之前，我们先假定两个前提，<strong>下文所有的讨论都是基于这两个前提的</strong>：</p>\n<ol>\n<li>每种权限码都是唯一的（这是显然的）</li>\n<li>所有权限码的二进制数形式，有且只有一位值为 1，其余全部为 0（<code>2^n</code>）</li>\n</ol>\n<p>如果用户权限和权限码，全部使用二级制数字表示，再结合上面 <code>AND</code> 和 <code>OR</code> 的例子，分析位运算的特点，不难发现：</p>\n<ul>\n<li><code>|</code> 可以用来赋予权限</li>\n<li><code>&amp;</code> 可以用来校验权限</li>\n</ul>\n<p>为了讲的更明白，这里用 Linux 中的实例分析下，Linux 的文件权限分为读、写和执行，有字母和数字等多种表现形式：</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">权限</th>\n<th style=\"text-align:left\">字母表示</th>\n<th style=\"text-align:left\">数字表示</th>\n<th style=\"text-align:left\">二进制</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">读</td>\n<td style=\"text-align:left\">r</td>\n<td style=\"text-align:left\">4</td>\n<td style=\"text-align:left\">0b100</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">写</td>\n<td style=\"text-align:left\">w</td>\n<td style=\"text-align:left\">2</td>\n<td style=\"text-align:left\">0b010</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">执行</td>\n<td style=\"text-align:left\">x</td>\n<td style=\"text-align:left\">1</td>\n<td style=\"text-align:left\">0b001</td>\n</tr>\n</tbody>\n</table>\n<p>可以看到，权限用 1、2、4（也就是 <code>2^n</code>）表示，转换为二进制后，都是只有一位是 1，其余为 0。我们通过几个例子看下，如何利用二进制的特点执行权限的添加，校验和删除。</p>\n<h3 id=\"3-1-添加权限\"><a href=\"#3-1-添加权限\" class=\"headerlink\" title=\"3.1. 添加权限\"></a>3.1. 添加权限</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> r = <span class=\"number\">0b100</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> w = <span class=\"number\">0b010</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> x = <span class=\"number\">0b001</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 给用户赋全部权限（使用前面讲的 | 操作）</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> user = r | w | x</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(user)</span><br><span class=\"line\"><span class=\"comment\">// 7</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(user.toString(<span class=\"number\">2</span>))</span><br><span class=\"line\"><span class=\"comment\">// 111</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//     r = 0b100</span></span><br><span class=\"line\"><span class=\"comment\">//     w = 0b010</span></span><br><span class=\"line\"><span class=\"comment\">//     r = 0b001</span></span><br><span class=\"line\"><span class=\"comment\">// r|w|x = 0b111</span></span><br><span class=\"line\">复制代码</span><br></pre></td></tr></table></figure>\n<p>可以看到，执行 <code>r | w | x</code> 后，<code>user</code> 的三位都是 1，表明拥有了全部三个权限。</p>\n<blockquote>\n<p>Linux 下出现权限问题时，最粗暴的解决方案就是 <code>chmod 777 xxx</code>，这里的 <code>7</code> 就代表了：可读，可写，可执行。而三个 <code>7</code> 分别代表：文件所有者，文件所有者所在组，所有其他用户。</p>\n</blockquote>\n<h3 id=\"3-2-校验权限\"><a href=\"#3-2-校验权限\" class=\"headerlink\" title=\"3.2. 校验权限\"></a>3.2. 校验权限</h3><p>刚才演示了权限的添加，下面演示权限校验：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> r = <span class=\"number\">0b100</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> w = <span class=\"number\">0b010</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> x = <span class=\"number\">0b001</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 给用户赋 r w 两个权限</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> user = r | w</span><br><span class=\"line\"><span class=\"comment\">// user = 6</span></span><br><span class=\"line\"><span class=\"comment\">// user = 0b110 (二进制)</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log((user &amp; r) === r) <span class=\"comment\">// true  有 r 权限</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log((user &amp; w) === w) <span class=\"comment\">// true  有 w 权限</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log((user &amp; x) === x) <span class=\"comment\">// false 没有 x 权限</span></span><br><span class=\"line\">复制代码</span><br></pre></td></tr></table></figure>\n<p>如前所料，通过 <code>用户权限 &amp; 权限 code === 权限 code</code> 就可以判断出用户是否拥有该权限。</p>\n<h3 id=\"3-3-删除权限\"><a href=\"#3-3-删除权限\" class=\"headerlink\" title=\"3.3. 删除权限\"></a>3.3. 删除权限</h3><p>我们讲了用 <code>|</code> 赋予权限，使用 <code>&amp;</code> 判断权限，那么删除权限呢？删除权限的本质其实是<strong>将指定位置上的 1 重置为 0</strong>。上个例子里用户权限是 <code>0b110</code>，拥有读和写两个权限，现在想删除读的权限，本质上就是将第三位的 1 重置为 0，变为 <code>0b010</code>：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> r = <span class=\"number\">0b100</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> w = <span class=\"number\">0b010</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> x = <span class=\"number\">0b001</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> user = <span class=\"number\">0b010</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log((user &amp; r) === r) <span class=\"comment\">// false 没有 r 权限</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log((user &amp; w) === w) <span class=\"comment\">// true  有 w 权限</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log((user &amp; x) === x) <span class=\"comment\">// false 没有 x 权限</span></span><br><span class=\"line\">复制代码</span><br></pre></td></tr></table></figure>\n<p>那么具体怎么操作呢？其实有两种方案，最简单的就是异或 <code>^</code>，按照上文的介绍“当两个操作数相应的比特位有且只有一个 1 时，结果为 1，否则为 0”，所以异或其实是 toggle 操作，无则增，有则减：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> r    = <span class=\"number\">0b100</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> w    = <span class=\"number\">0b010</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> x    = <span class=\"number\">0b001</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> user = <span class=\"number\">0b110</span> <span class=\"comment\">// 有 r w 两个权限</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 执行异或操作，删除 r 权限</span></span><br><span class=\"line\">user = user ^ r</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log((user &amp; r) === r) <span class=\"comment\">// false 没有 r 权限</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log((user &amp; w) === w) <span class=\"comment\">// true  有 w 权限</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log((user &amp; x) === x) <span class=\"comment\">// false 没有 x 权限</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(user.toString(<span class=\"number\">2</span>)) <span class=\"comment\">// 现在 user 是 0b010</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 再执行一次异或操作</span></span><br><span class=\"line\">user = user ^ r</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log((user &amp; r) === r) <span class=\"comment\">// true  有 r 权限</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log((user &amp; w) === w) <span class=\"comment\">// true  有 w 权限</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log((user &amp; x) === x) <span class=\"comment\">// false 没有 x 权限</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(user.toString(<span class=\"number\">2</span>)) <span class=\"comment\">// 现在 user 又变回 0b110</span></span><br><span class=\"line\">复制代码</span><br></pre></td></tr></table></figure>\n<p>那么如果单纯的想删除权限（而不是无则增，有则减）怎么办呢？答案是执行 <code>&amp;(~code)</code>，先取反，再执行与操作：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> r    = <span class=\"number\">0b100</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> w    = <span class=\"number\">0b010</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> x    = <span class=\"number\">0b001</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> user = <span class=\"number\">0b110</span> <span class=\"comment\">// 有 r w 两个权限</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 删除 r 权限</span></span><br><span class=\"line\">user = user &amp; (~r)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log((user &amp; r) === r) <span class=\"comment\">// false 没有 r 权限</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log((user &amp; w) === w) <span class=\"comment\">// true  有 w 权限</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log((user &amp; x) === x) <span class=\"comment\">// false 没有 x 权限</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(user.toString(<span class=\"number\">2</span>)) <span class=\"comment\">// 现在 user 是 0b010</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 再执行一次</span></span><br><span class=\"line\">user = user &amp; (~r)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log((user &amp; r) === r) <span class=\"comment\">// false 没有 r 权限</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log((user &amp; w) === w) <span class=\"comment\">// true  有 w 权限</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log((user &amp; x) === x) <span class=\"comment\">// false 没有 x 权限</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(user.toString(<span class=\"number\">2</span>)) <span class=\"comment\">// 现在 user 还是 0b010，并不会新增</span></span><br><span class=\"line\">复制代码</span><br></pre></td></tr></table></figure>\n<h2 id=\"4-局限性和解决办法\"><a href=\"#4-局限性和解决办法\" class=\"headerlink\" title=\"4. 局限性和解决办法\"></a>4. 局限性和解决办法</h2><p>前面我们回顾了 JavaScript 中的 Number 和位运算，并且了解了基于位运算的权限系统原理和 Linux 文件系统权限的实例。</p>\n<p>上述的所有都有前提条件：1、<strong>每种权限码都是唯一的</strong>；2、<strong>每个权限码的二进制数形式，有且只有一位值为 1（<code>2^n</code>）</strong>。也就是说，权限码只能是 1, 2, 4, 8,…,1024,…而上文提到，一个数字的范围只能在 -(2^53 -1) 和 2^53 -1 之间，JavaScript 的按位操作符又是将其操作数当作 <strong>32 位</strong>比特序列的。那么同一个应用下可用的权限数就非常有限了。这也是该方案的局限性。</p>\n<p>为了突破这个限制，这里提出一个叫“权限空间”的概念，既然权限数有限，那么不妨就多开辟几个空间来存放。</p>\n<p>基于权限空间，我们定义两个格式：</p>\n<ol>\n<li><strong>权限 code</strong>，字符串，形如 <code>index,pos</code>。其中 <code>pos</code> 表示 32 位二进制数中 1 的位置（其余全是 0）； <code>index</code> 表示<strong>权限空间</strong>，用于突破 JavaScript 数字位数的限制，是从 0 开始的正整数，每个权限code都要归属于一个权限空间。<code>index</code> 和 <code>pos</code> 使用英文逗号隔开。</li>\n<li><strong>用户权限</strong>，字符串，形如 <code>1,16,16</code>。英文逗号分隔每一个<strong>权限空间</strong>的权限值。例如 <code>1,16,16</code> 的意思就是，权限空间 0 的权限值是 1，权限空间 1 的权限值是 16，权限空间 2 的权限是 16。</li>\n</ol>\n<p>干说可能不好懂，直接上代码：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 用户的权限 code</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> userCode = <span class=\"string\">\"\"</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 假设系统里有这些权限</span></span><br><span class=\"line\"><span class=\"comment\">// 纯模拟，正常情况下是按顺序的，如 0,0 0,1 0,2 ...，尽可能占满一个权限空间，再使用下一个</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> permissions = &#123;</span><br><span class=\"line\">  SYS_SETTING: &#123;</span><br><span class=\"line\">    value: <span class=\"string\">\"0,0\"</span>,   <span class=\"comment\">// index = 0, pos = 0</span></span><br><span class=\"line\">    info: <span class=\"string\">\"系统权限\"</span></span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  DATA_ADMIN: &#123;</span><br><span class=\"line\">    value: <span class=\"string\">\"0,8\"</span>,</span><br><span class=\"line\">    info: <span class=\"string\">\"数据库权限\"</span></span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  USER_ADD: &#123;</span><br><span class=\"line\">    value: <span class=\"string\">\"0,22\"</span>,</span><br><span class=\"line\">    info: <span class=\"string\">\"用户新增权限\"</span></span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  USER_EDIT: &#123;</span><br><span class=\"line\">    value: <span class=\"string\">\"0,30\"</span>,</span><br><span class=\"line\">    info: <span class=\"string\">\"用户编辑权限\"</span></span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  USER_VIEW: &#123;</span><br><span class=\"line\">    value: <span class=\"string\">\"1,2\"</span>,   <span class=\"comment\">// index = 1, pos = 2</span></span><br><span class=\"line\">    info: <span class=\"string\">\"用户查看权限\"</span></span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  USER_DELETE: &#123;</span><br><span class=\"line\">    value: <span class=\"string\">\"1,17\"</span>,</span><br><span class=\"line\">    info: <span class=\"string\">\"用户删除权限\"</span></span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  POST_ADD: &#123;</span><br><span class=\"line\">    value: <span class=\"string\">\"1,28\"</span>,</span><br><span class=\"line\">    info: <span class=\"string\">\"文章新增权限\"</span></span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  POST_EDIT: &#123;</span><br><span class=\"line\">    value: <span class=\"string\">\"2,4\"</span>,</span><br><span class=\"line\">    info: <span class=\"string\">\"文章编辑权限\"</span></span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  POST_VIEW: &#123;</span><br><span class=\"line\">    value: <span class=\"string\">\"2,19\"</span>,</span><br><span class=\"line\">    info: <span class=\"string\">\"文章查看权限\"</span></span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  POST_DELETE: &#123;</span><br><span class=\"line\">    value: <span class=\"string\">\"2,26\"</span>,</span><br><span class=\"line\">    info: <span class=\"string\">\"文章删除权限\"</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 添加权限</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> addPermission = <span class=\"function\">(<span class=\"params\">userCode, permission</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> userPermission = userCode ? userCode.split(<span class=\"string\">\",\"</span>) : []</span><br><span class=\"line\">  <span class=\"keyword\">const</span> [index, pos] = permission.value.split(<span class=\"string\">\",\"</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">  userPermission[index] = (userPermission[index] || <span class=\"number\">0</span>) | <span class=\"built_in\">Math</span>.pow(<span class=\"number\">2</span>, pos)</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> userPermission.join(<span class=\"string\">\",\"</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 删除权限</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> delPermission = <span class=\"function\">(<span class=\"params\">userCode, permission</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> userPermission = userCode ? userCode.split(<span class=\"string\">\",\"</span>) : []</span><br><span class=\"line\">  <span class=\"keyword\">const</span> [index, pos] = permission.value.split(<span class=\"string\">\",\"</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">  userPermission[index] = (userPermission[index] || <span class=\"number\">0</span>) &amp; (~<span class=\"built_in\">Math</span>.pow(<span class=\"number\">2</span>, pos))</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> userPermission.join(<span class=\"string\">\",\"</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 判断是否有权限</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> hasPermission = <span class=\"function\">(<span class=\"params\">userCode, permission</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> userPermission = userCode ? userCode.split(<span class=\"string\">\",\"</span>) : []</span><br><span class=\"line\">  <span class=\"keyword\">const</span> [index, pos] = permission.value.split(<span class=\"string\">\",\"</span>)</span><br><span class=\"line\">  <span class=\"keyword\">const</span> permissionValue = <span class=\"built_in\">Math</span>.pow(<span class=\"number\">2</span>, pos)</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> (userPermission[index] &amp; permissionValue) === permissionValue</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 列出用户拥有的全部权限</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> listPermission = <span class=\"function\"><span class=\"params\">userCode</span> =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> results = []</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!userCode) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> results</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"built_in\">Object</span>.values(permissions).forEach(<span class=\"function\"><span class=\"params\">permission</span> =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (hasPermission(userCode, permission)) &#123;</span><br><span class=\"line\">      results.push(permission.info)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> results</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> log = <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">`userCode: <span class=\"subst\">$&#123;<span class=\"built_in\">JSON</span>.stringify(userCode, <span class=\"literal\">null</span>, <span class=\"string\">\" \"</span>)&#125;</span>`</span>)</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">`权限列表: <span class=\"subst\">$&#123;listPermission(userCode).join(<span class=\"string\">\"; \"</span>)&#125;</span>`</span>)</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">\"\"</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">userCode = addPermission(userCode, permissions.SYS_SETTING)</span><br><span class=\"line\">log()</span><br><span class=\"line\"><span class=\"comment\">// userCode: \"1\"</span></span><br><span class=\"line\"><span class=\"comment\">// 权限列表: 系统权限</span></span><br><span class=\"line\"></span><br><span class=\"line\">userCode = addPermission(userCode, permissions.POST_EDIT)</span><br><span class=\"line\">log()</span><br><span class=\"line\"><span class=\"comment\">// userCode: \"1,,16\"</span></span><br><span class=\"line\"><span class=\"comment\">// 权限列表: 系统权限; 文章编辑权限</span></span><br><span class=\"line\"></span><br><span class=\"line\">userCode = addPermission(userCode, permissions.USER_EDIT)</span><br><span class=\"line\">log()</span><br><span class=\"line\"><span class=\"comment\">// userCode: \"1073741825,,16\"</span></span><br><span class=\"line\"><span class=\"comment\">// 权限列表: 系统权限; 用户编辑权限; 文章编辑权限</span></span><br><span class=\"line\"></span><br><span class=\"line\">userCode = addPermission(userCode, permissions.USER_DELETE)</span><br><span class=\"line\">log()</span><br><span class=\"line\"><span class=\"comment\">// userCode: \"1073741825,131072,16\"</span></span><br><span class=\"line\"><span class=\"comment\">// 权限列表: 系统权限; 用户编辑权限; 用户删除权限; 文章编辑权限</span></span><br><span class=\"line\"></span><br><span class=\"line\">userCode = delPermission(userCode, permissions.USER_EDIT)</span><br><span class=\"line\">log()</span><br><span class=\"line\"><span class=\"comment\">// userCode: \"1,131072,16\"</span></span><br><span class=\"line\"><span class=\"comment\">// 权限列表: 系统权限; 用户删除权限; 文章编辑权限</span></span><br><span class=\"line\"></span><br><span class=\"line\">userCode = delPermission(userCode, permissions.USER_EDIT)</span><br><span class=\"line\">log()</span><br><span class=\"line\"><span class=\"comment\">// userCode: \"1,131072,16\"</span></span><br><span class=\"line\"><span class=\"comment\">// 权限列表: 系统权限; 用户删除权限; 文章编辑权限</span></span><br><span class=\"line\"></span><br><span class=\"line\">userCode = delPermission(userCode, permissions.USER_DELETE)</span><br><span class=\"line\">userCode = delPermission(userCode, permissions.SYS_SETTING)</span><br><span class=\"line\">userCode = delPermission(userCode, permissions.POST_EDIT)</span><br><span class=\"line\">log()</span><br><span class=\"line\"><span class=\"comment\">// userCode: \"0,0,0\"</span></span><br><span class=\"line\"><span class=\"comment\">// 权限列表: </span></span><br><span class=\"line\"></span><br><span class=\"line\">userCode = addPermission(userCode, permissions.SYS_SETTING)</span><br><span class=\"line\">log()</span><br><span class=\"line\"><span class=\"comment\">// userCode: \"1,0,0\"</span></span><br><span class=\"line\"><span class=\"comment\">// 权限列表: 系统权限</span></span><br><span class=\"line\">复制代码</span><br></pre></td></tr></table></figure>\n<p>除了通过引入<strong>权限空间</strong>的概念突破二进制运算的位数限制，还可以使用 <a href=\"http://mathjs.org\" target=\"_blank\" rel=\"noopener\">math.js</a> 的 <code>bignumber</code>，直接运算超过 32 位的二进制数，具体可以看它的文档，这里就不细说了。</p>\n<h2 id=\"5-适用场景和问题\"><a href=\"#5-适用场景和问题\" class=\"headerlink\" title=\"5. 适用场景和问题\"></a>5. 适用场景和问题</h2><p>如果按照当前使用最广泛的 <a href=\"https://zh.wikipedia.org/wiki/以角色為基礎的存取控制\" target=\"_blank\" rel=\"noopener\">RBAC</a> 模型设计权限系统，那么一般会有这么几个实体：应用，权限，角色，用户。用户权限可以直接来自权限，也可以来自角色：</p>\n<ul>\n<li>一个应用下有多个权限</li>\n<li>权限和角色是多对多的关系</li>\n<li>用户和角色是多对多的关系</li>\n<li>用户和权限是多对多的关系</li>\n</ul>\n<p>在此种模型下，一般会有用户与权限，用户与角色，角色与权限的对应关系表。想象一个商城后台权限管理系统，可能会有上万，甚至十几万店铺（应用），每个店铺可能会有数十个用户，角色，权限。随着业务的不断发展，刚才提到的那三张对应关系表会越来越大，越来越难以维护。</p>\n<p>而进制转换的方法则可以省略对应关系表，减少查询，节省空间。当然，省略掉对应关系不是没有坏处的，例如下面几个问题：</p>\n<ul>\n<li>如何高效的查找我的权限？</li>\n<li>如何高效的查找拥有某权限的所有用户？</li>\n<li>如何控制权限的有效期？</li>\n</ul>\n<p>所以进制转换的方案比较适合刚才提到的应用极其多，而每个应用中用户，权限，角色数量较少的场景。</p>\n<h2 id=\"6-其他方案\"><a href=\"#6-其他方案\" class=\"headerlink\" title=\"6. 其他方案\"></a>6. 其他方案</h2><p>除了二进制方案，当然还有其他方案可以达到类似的效果，例如直接使用一个1和0组成的字符串，权限点对应index，1表示拥有权限，0表示没有权限。举个例子：添加 0、删除 1、编辑 2，用户A拥有添加和编辑的权限，则 userCode 为 101；用户B拥有全部权限，userCode 为 111。这种方案比二进制转换简单，但是浪费空间。</p>\n<p>还有利用质数的方案，权限点全部为质数，用户权限为他所拥有的全部权限点的乘积。如：权限点是 2、3、5、7、11，用户权限是 5 <em> 7 </em> 11 = 385。这种方案麻烦的地方在于获取质数（新增权限点）和质因数分解（判断权限），权限点特别多的时候就快成 RSA 了，如果只有增删改查个别几个权限，倒是可以考虑。</p>\n<h2 id=\"7-参考\"><a href=\"#7-参考\" class=\"headerlink\" title=\"7. 参考\"></a>7. 参考</h2><ul>\n<li><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Numbers_and_dates\" target=\"_blank\" rel=\"noopener\">MDN：JavaScript 数字和日期</a></li>\n<li><a href=\"https://zh.wikipedia.org/wiki/雙精度浮點數\" target=\"_blank\" rel=\"noopener\">双精度浮点类型</a></li>\n<li><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Bitwise_Operators\" target=\"_blank\" rel=\"noopener\">MDN：按位操作符</a></li>\n<li><a href=\"https://www.jianshu.com/p/11f331d97ec2\" target=\"_blank\" rel=\"noopener\">【小知识大道理】被忽视的位运算</a></li>\n<li><a href=\"http://jerryzou.com/posts/do-you-really-want-use-bit-operators-in-JavaScript/\" target=\"_blank\" rel=\"noopener\">为什么不要在 JavaScript 中使用位操作符？</a></li>\n<li><a href=\"https://mp.weixin.qq.com/s/MKljuxfDMmopr_MrnYljGw\" target=\"_blank\" rel=\"noopener\">角色权限设计的100种解法</a></li>\n<li><a href=\"http://www.cnblogs.com/shijiaqi1066/p/3793894.html\" target=\"_blank\" rel=\"noopener\">权限系统与RBAC模型概述</a></li>\n<li><a href=\"https://blog.csdn.net/yingchunhua365/article/details/14090461\" target=\"_blank\" rel=\"noopener\">权限设计及算法</a></li>\n<li><a href=\"https://zh.wikipedia.org/wiki/以角色為基礎的存取控制\" target=\"_blank\" rel=\"noopener\">基于角色的访问控制</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"<h2 id=\"1-内容概要\"><a href=\"#1-内容概要\" class=\"headerlink\" title=\"1. 内容概要\"></a>1. 内容概要</h2><p>本文主要讨论以下两个问题：</p>\n<ul>\n<li>JavaScript 的位运算：先简单回顾下位运算，平时用的少，相信不少人和我一样忘的差不多了</li>\n<li>权限设计：根据位运算的特点，设计一个权限系统（添加、删除、判断等）","more":"<h2 id=\"2-JavaScript-位运算\"><a href=\"#2-JavaScript-位运算\" class=\"headerlink\" title=\"2. JavaScript 位运算\"></a>2. JavaScript 位运算</h2></li>\n</ul>\n<h3 id=\"2-1-Number\"><a href=\"#2-1-Number\" class=\"headerlink\" title=\"2.1. Number\"></a>2.1. Number</h3><p>在讲位运算之前，首先简单看下 JavaScript 中的 Number，下文需要用到。</p>\n<p>在 JavaScript 里，数字均为<a href=\"https://zh.wikipedia.org/wiki/雙精度浮點數\" target=\"_blank\" rel=\"noopener\">基于 IEEE 754 标准的双精度 64 位的浮点数</a>，引用维基百科的图片，它的结构长这样：</p>\n<p><img src=\"https://wos2.58cdn.com.cn/iJkFeDcBiJiJ/rocket/7a04aac6-45b1-43a6-b20c-cd7ff147b060.jpeg\" alt=\"img\"></p>\n<ul>\n<li>sign bit（符号）: 用来表示正负号</li>\n<li>exponent（指数）: 用来表示次方数</li>\n<li>mantissa（尾数）: 用来表示精确度</li>\n</ul>\n<p>也就是说一个数字的范围只能在 -(2^53 -1) 至 2^53 -1 之间。</p>\n<blockquote>\n<p>既然讲到这里，就多说一句：0.1 + 0.2 算不准的原因也在于此。浮点数用二进制表达时是无穷的，且最多 53 位，必须截断，进而产生误差。最简单的解决办法就是放大一定倍数变成整数，计算完成后再缩小。不过更稳妥的办法是使用下文将会提到的 <a href=\"https://mathjs.org/docs/datatypes/bignumbers.html#roundoff-errors\" target=\"_blank\" rel=\"noopener\">math.js</a> 等工具库。</p>\n</blockquote>\n<p>此外还有四种数字进制：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 十进制</span></span><br><span class=\"line\"><span class=\"number\">123456789</span></span><br><span class=\"line\"><span class=\"number\">0</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 二进制：前缀 0b，0B</span></span><br><span class=\"line\"><span class=\"number\">0b10000000000000000000000000000000</span> <span class=\"comment\">// 2147483648</span></span><br><span class=\"line\"><span class=\"number\">0b01111111100000000000000000000000</span> <span class=\"comment\">// 2139095040</span></span><br><span class=\"line\"><span class=\"number\">0B00000000011111111111111111111111</span> <span class=\"comment\">// 8388607</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 八进制：前缀 0o，0O（以前支持前缀 0）</span></span><br><span class=\"line\"><span class=\"number\">0o755</span> <span class=\"comment\">// 493</span></span><br><span class=\"line\"><span class=\"number\">0o644</span> <span class=\"comment\">// 420</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 十六进制：前缀 0x，0X</span></span><br><span class=\"line\"><span class=\"number\">0xFFFFFFFFFFFFFFFFF</span> <span class=\"comment\">// 295147905179352830000</span></span><br><span class=\"line\"><span class=\"number\">0x123456789ABCDEF</span>   <span class=\"comment\">// 81985529216486900</span></span><br><span class=\"line\"><span class=\"number\">0XA</span>                 <span class=\"comment\">// 10</span></span><br><span class=\"line\">复制代码</span><br></pre></td></tr></table></figure>\n<p>好了，Number 就说这么多，接下来看 JavaScript 中的位运算。</p>\n<h3 id=\"2-2-位运算\"><a href=\"#2-2-位运算\" class=\"headerlink\" title=\"2.2. 位运算\"></a>2.2. 位运算</h3><p>按位操作符将其操作数当作 32 位的比特序列（由 0 和 1 组成）操作，返回值依然是标准的 JavaScript 数值。JavaScript 中的按位操作符有：</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">运算符</th>\n<th style=\"text-align:left\">用法</th>\n<th style=\"text-align:left\">描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">按位与（AND）</td>\n<td style=\"text-align:left\"><code>a &amp; b</code></td>\n<td style=\"text-align:left\">对于每一个比特位，只有两个操作数相应的比特位都是 1 时，结果才为 1，否则为 0。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">按位或（OR）</td>\n<td style=\"text-align:left\"><code>a ｜ b</code></td>\n<td style=\"text-align:left\">对于每一个比特位，当两个操作数相应的比特位至少有一个 1 时，结果为 1，否则为 0。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">按位异或（XOR）</td>\n<td style=\"text-align:left\"><code>a ^ b</code></td>\n<td style=\"text-align:left\">对于每一个比特位，当两个操作数相应的比特位有且只有一个 1 时，结果为 1，否则为 0。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">按位非（NOT）</td>\n<td style=\"text-align:left\"><code>~a</code></td>\n<td style=\"text-align:left\">反转操作数的比特位，即 0 变成 1，1 变成 0。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">左移（Left shift）</td>\n<td style=\"text-align:left\"><code>a &lt;&lt; b</code></td>\n<td style=\"text-align:left\">将 a 的二进制形式向左移 b (&lt; 32) 比特位，右边用 0 填充。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">有符号右移</td>\n<td style=\"text-align:left\"><code>a &gt;&gt; b</code></td>\n<td style=\"text-align:left\">将 a 的二进制表示向右移 b (&lt; 32) 位，丢弃被移出的位。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">无符号右移</td>\n<td style=\"text-align:left\"><code>a &gt;&gt;&gt; b</code></td>\n<td style=\"text-align:left\">将 a 的二进制表示向右移 b (&lt; 32) 位，丢弃被移出的位，并使用 0 在左侧填充。</td>\n</tr>\n</tbody>\n</table>\n<p>下面举几个例子，主要看下 <code>AND</code> 和 <code>OR</code>：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 例子1</span><br><span class=\"line\">    A = <span class=\"number\">10001001</span></span><br><span class=\"line\">    B = <span class=\"number\">10010000</span></span><br><span class=\"line\">A | B = <span class=\"number\">10011001</span></span><br><span class=\"line\"></span><br><span class=\"line\"># 例子2</span><br><span class=\"line\">    A = <span class=\"number\">10001001</span></span><br><span class=\"line\">    C = <span class=\"number\">10001000</span></span><br><span class=\"line\">A | C = <span class=\"number\">10001001</span></span><br><span class=\"line\">复制代码</span><br><span class=\"line\"># 例子1</span><br><span class=\"line\">    A = <span class=\"number\">10001001</span></span><br><span class=\"line\">    B = <span class=\"number\">10010000</span></span><br><span class=\"line\">A &amp; B = <span class=\"number\">10000000</span></span><br><span class=\"line\"></span><br><span class=\"line\"># 例子2</span><br><span class=\"line\">    A = <span class=\"number\">10001001</span></span><br><span class=\"line\">    C = <span class=\"number\">10001000</span></span><br><span class=\"line\">A &amp; C = <span class=\"number\">10001000</span></span><br><span class=\"line\">复制代码</span><br></pre></td></tr></table></figure>\n<h2 id=\"3-位运算在权限系统中的使用\"><a href=\"#3-位运算在权限系统中的使用\" class=\"headerlink\" title=\"3. 位运算在权限系统中的使用\"></a>3. 位运算在权限系统中的使用</h2><p>传统的权限系统里，存在很多关联关系，如用户和权限的关联，用户和角色的关联。系统越大，关联关系越多，越难以维护。而引入位运算，可以巧妙的解决该问题。</p>\n<p>在讲“位运算在权限系统中的使用”之前，我们先假定两个前提，<strong>下文所有的讨论都是基于这两个前提的</strong>：</p>\n<ol>\n<li>每种权限码都是唯一的（这是显然的）</li>\n<li>所有权限码的二进制数形式，有且只有一位值为 1，其余全部为 0（<code>2^n</code>）</li>\n</ol>\n<p>如果用户权限和权限码，全部使用二级制数字表示，再结合上面 <code>AND</code> 和 <code>OR</code> 的例子，分析位运算的特点，不难发现：</p>\n<ul>\n<li><code>|</code> 可以用来赋予权限</li>\n<li><code>&amp;</code> 可以用来校验权限</li>\n</ul>\n<p>为了讲的更明白，这里用 Linux 中的实例分析下，Linux 的文件权限分为读、写和执行，有字母和数字等多种表现形式：</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">权限</th>\n<th style=\"text-align:left\">字母表示</th>\n<th style=\"text-align:left\">数字表示</th>\n<th style=\"text-align:left\">二进制</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">读</td>\n<td style=\"text-align:left\">r</td>\n<td style=\"text-align:left\">4</td>\n<td style=\"text-align:left\">0b100</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">写</td>\n<td style=\"text-align:left\">w</td>\n<td style=\"text-align:left\">2</td>\n<td style=\"text-align:left\">0b010</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">执行</td>\n<td style=\"text-align:left\">x</td>\n<td style=\"text-align:left\">1</td>\n<td style=\"text-align:left\">0b001</td>\n</tr>\n</tbody>\n</table>\n<p>可以看到，权限用 1、2、4（也就是 <code>2^n</code>）表示，转换为二进制后，都是只有一位是 1，其余为 0。我们通过几个例子看下，如何利用二进制的特点执行权限的添加，校验和删除。</p>\n<h3 id=\"3-1-添加权限\"><a href=\"#3-1-添加权限\" class=\"headerlink\" title=\"3.1. 添加权限\"></a>3.1. 添加权限</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> r = <span class=\"number\">0b100</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> w = <span class=\"number\">0b010</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> x = <span class=\"number\">0b001</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 给用户赋全部权限（使用前面讲的 | 操作）</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> user = r | w | x</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(user)</span><br><span class=\"line\"><span class=\"comment\">// 7</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(user.toString(<span class=\"number\">2</span>))</span><br><span class=\"line\"><span class=\"comment\">// 111</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//     r = 0b100</span></span><br><span class=\"line\"><span class=\"comment\">//     w = 0b010</span></span><br><span class=\"line\"><span class=\"comment\">//     r = 0b001</span></span><br><span class=\"line\"><span class=\"comment\">// r|w|x = 0b111</span></span><br><span class=\"line\">复制代码</span><br></pre></td></tr></table></figure>\n<p>可以看到，执行 <code>r | w | x</code> 后，<code>user</code> 的三位都是 1，表明拥有了全部三个权限。</p>\n<blockquote>\n<p>Linux 下出现权限问题时，最粗暴的解决方案就是 <code>chmod 777 xxx</code>，这里的 <code>7</code> 就代表了：可读，可写，可执行。而三个 <code>7</code> 分别代表：文件所有者，文件所有者所在组，所有其他用户。</p>\n</blockquote>\n<h3 id=\"3-2-校验权限\"><a href=\"#3-2-校验权限\" class=\"headerlink\" title=\"3.2. 校验权限\"></a>3.2. 校验权限</h3><p>刚才演示了权限的添加，下面演示权限校验：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> r = <span class=\"number\">0b100</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> w = <span class=\"number\">0b010</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> x = <span class=\"number\">0b001</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 给用户赋 r w 两个权限</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> user = r | w</span><br><span class=\"line\"><span class=\"comment\">// user = 6</span></span><br><span class=\"line\"><span class=\"comment\">// user = 0b110 (二进制)</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log((user &amp; r) === r) <span class=\"comment\">// true  有 r 权限</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log((user &amp; w) === w) <span class=\"comment\">// true  有 w 权限</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log((user &amp; x) === x) <span class=\"comment\">// false 没有 x 权限</span></span><br><span class=\"line\">复制代码</span><br></pre></td></tr></table></figure>\n<p>如前所料，通过 <code>用户权限 &amp; 权限 code === 权限 code</code> 就可以判断出用户是否拥有该权限。</p>\n<h3 id=\"3-3-删除权限\"><a href=\"#3-3-删除权限\" class=\"headerlink\" title=\"3.3. 删除权限\"></a>3.3. 删除权限</h3><p>我们讲了用 <code>|</code> 赋予权限，使用 <code>&amp;</code> 判断权限，那么删除权限呢？删除权限的本质其实是<strong>将指定位置上的 1 重置为 0</strong>。上个例子里用户权限是 <code>0b110</code>，拥有读和写两个权限，现在想删除读的权限，本质上就是将第三位的 1 重置为 0，变为 <code>0b010</code>：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> r = <span class=\"number\">0b100</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> w = <span class=\"number\">0b010</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> x = <span class=\"number\">0b001</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> user = <span class=\"number\">0b010</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log((user &amp; r) === r) <span class=\"comment\">// false 没有 r 权限</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log((user &amp; w) === w) <span class=\"comment\">// true  有 w 权限</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log((user &amp; x) === x) <span class=\"comment\">// false 没有 x 权限</span></span><br><span class=\"line\">复制代码</span><br></pre></td></tr></table></figure>\n<p>那么具体怎么操作呢？其实有两种方案，最简单的就是异或 <code>^</code>，按照上文的介绍“当两个操作数相应的比特位有且只有一个 1 时，结果为 1，否则为 0”，所以异或其实是 toggle 操作，无则增，有则减：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> r    = <span class=\"number\">0b100</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> w    = <span class=\"number\">0b010</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> x    = <span class=\"number\">0b001</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> user = <span class=\"number\">0b110</span> <span class=\"comment\">// 有 r w 两个权限</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 执行异或操作，删除 r 权限</span></span><br><span class=\"line\">user = user ^ r</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log((user &amp; r) === r) <span class=\"comment\">// false 没有 r 权限</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log((user &amp; w) === w) <span class=\"comment\">// true  有 w 权限</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log((user &amp; x) === x) <span class=\"comment\">// false 没有 x 权限</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(user.toString(<span class=\"number\">2</span>)) <span class=\"comment\">// 现在 user 是 0b010</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 再执行一次异或操作</span></span><br><span class=\"line\">user = user ^ r</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log((user &amp; r) === r) <span class=\"comment\">// true  有 r 权限</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log((user &amp; w) === w) <span class=\"comment\">// true  有 w 权限</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log((user &amp; x) === x) <span class=\"comment\">// false 没有 x 权限</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(user.toString(<span class=\"number\">2</span>)) <span class=\"comment\">// 现在 user 又变回 0b110</span></span><br><span class=\"line\">复制代码</span><br></pre></td></tr></table></figure>\n<p>那么如果单纯的想删除权限（而不是无则增，有则减）怎么办呢？答案是执行 <code>&amp;(~code)</code>，先取反，再执行与操作：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> r    = <span class=\"number\">0b100</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> w    = <span class=\"number\">0b010</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> x    = <span class=\"number\">0b001</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> user = <span class=\"number\">0b110</span> <span class=\"comment\">// 有 r w 两个权限</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 删除 r 权限</span></span><br><span class=\"line\">user = user &amp; (~r)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log((user &amp; r) === r) <span class=\"comment\">// false 没有 r 权限</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log((user &amp; w) === w) <span class=\"comment\">// true  有 w 权限</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log((user &amp; x) === x) <span class=\"comment\">// false 没有 x 权限</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(user.toString(<span class=\"number\">2</span>)) <span class=\"comment\">// 现在 user 是 0b010</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 再执行一次</span></span><br><span class=\"line\">user = user &amp; (~r)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log((user &amp; r) === r) <span class=\"comment\">// false 没有 r 权限</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log((user &amp; w) === w) <span class=\"comment\">// true  有 w 权限</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log((user &amp; x) === x) <span class=\"comment\">// false 没有 x 权限</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(user.toString(<span class=\"number\">2</span>)) <span class=\"comment\">// 现在 user 还是 0b010，并不会新增</span></span><br><span class=\"line\">复制代码</span><br></pre></td></tr></table></figure>\n<h2 id=\"4-局限性和解决办法\"><a href=\"#4-局限性和解决办法\" class=\"headerlink\" title=\"4. 局限性和解决办法\"></a>4. 局限性和解决办法</h2><p>前面我们回顾了 JavaScript 中的 Number 和位运算，并且了解了基于位运算的权限系统原理和 Linux 文件系统权限的实例。</p>\n<p>上述的所有都有前提条件：1、<strong>每种权限码都是唯一的</strong>；2、<strong>每个权限码的二进制数形式，有且只有一位值为 1（<code>2^n</code>）</strong>。也就是说，权限码只能是 1, 2, 4, 8,…,1024,…而上文提到，一个数字的范围只能在 -(2^53 -1) 和 2^53 -1 之间，JavaScript 的按位操作符又是将其操作数当作 <strong>32 位</strong>比特序列的。那么同一个应用下可用的权限数就非常有限了。这也是该方案的局限性。</p>\n<p>为了突破这个限制，这里提出一个叫“权限空间”的概念，既然权限数有限，那么不妨就多开辟几个空间来存放。</p>\n<p>基于权限空间，我们定义两个格式：</p>\n<ol>\n<li><strong>权限 code</strong>，字符串，形如 <code>index,pos</code>。其中 <code>pos</code> 表示 32 位二进制数中 1 的位置（其余全是 0）； <code>index</code> 表示<strong>权限空间</strong>，用于突破 JavaScript 数字位数的限制，是从 0 开始的正整数，每个权限code都要归属于一个权限空间。<code>index</code> 和 <code>pos</code> 使用英文逗号隔开。</li>\n<li><strong>用户权限</strong>，字符串，形如 <code>1,16,16</code>。英文逗号分隔每一个<strong>权限空间</strong>的权限值。例如 <code>1,16,16</code> 的意思就是，权限空间 0 的权限值是 1，权限空间 1 的权限值是 16，权限空间 2 的权限是 16。</li>\n</ol>\n<p>干说可能不好懂，直接上代码：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 用户的权限 code</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> userCode = <span class=\"string\">\"\"</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 假设系统里有这些权限</span></span><br><span class=\"line\"><span class=\"comment\">// 纯模拟，正常情况下是按顺序的，如 0,0 0,1 0,2 ...，尽可能占满一个权限空间，再使用下一个</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> permissions = &#123;</span><br><span class=\"line\">  SYS_SETTING: &#123;</span><br><span class=\"line\">    value: <span class=\"string\">\"0,0\"</span>,   <span class=\"comment\">// index = 0, pos = 0</span></span><br><span class=\"line\">    info: <span class=\"string\">\"系统权限\"</span></span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  DATA_ADMIN: &#123;</span><br><span class=\"line\">    value: <span class=\"string\">\"0,8\"</span>,</span><br><span class=\"line\">    info: <span class=\"string\">\"数据库权限\"</span></span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  USER_ADD: &#123;</span><br><span class=\"line\">    value: <span class=\"string\">\"0,22\"</span>,</span><br><span class=\"line\">    info: <span class=\"string\">\"用户新增权限\"</span></span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  USER_EDIT: &#123;</span><br><span class=\"line\">    value: <span class=\"string\">\"0,30\"</span>,</span><br><span class=\"line\">    info: <span class=\"string\">\"用户编辑权限\"</span></span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  USER_VIEW: &#123;</span><br><span class=\"line\">    value: <span class=\"string\">\"1,2\"</span>,   <span class=\"comment\">// index = 1, pos = 2</span></span><br><span class=\"line\">    info: <span class=\"string\">\"用户查看权限\"</span></span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  USER_DELETE: &#123;</span><br><span class=\"line\">    value: <span class=\"string\">\"1,17\"</span>,</span><br><span class=\"line\">    info: <span class=\"string\">\"用户删除权限\"</span></span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  POST_ADD: &#123;</span><br><span class=\"line\">    value: <span class=\"string\">\"1,28\"</span>,</span><br><span class=\"line\">    info: <span class=\"string\">\"文章新增权限\"</span></span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  POST_EDIT: &#123;</span><br><span class=\"line\">    value: <span class=\"string\">\"2,4\"</span>,</span><br><span class=\"line\">    info: <span class=\"string\">\"文章编辑权限\"</span></span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  POST_VIEW: &#123;</span><br><span class=\"line\">    value: <span class=\"string\">\"2,19\"</span>,</span><br><span class=\"line\">    info: <span class=\"string\">\"文章查看权限\"</span></span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  POST_DELETE: &#123;</span><br><span class=\"line\">    value: <span class=\"string\">\"2,26\"</span>,</span><br><span class=\"line\">    info: <span class=\"string\">\"文章删除权限\"</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 添加权限</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> addPermission = <span class=\"function\">(<span class=\"params\">userCode, permission</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> userPermission = userCode ? userCode.split(<span class=\"string\">\",\"</span>) : []</span><br><span class=\"line\">  <span class=\"keyword\">const</span> [index, pos] = permission.value.split(<span class=\"string\">\",\"</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">  userPermission[index] = (userPermission[index] || <span class=\"number\">0</span>) | <span class=\"built_in\">Math</span>.pow(<span class=\"number\">2</span>, pos)</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> userPermission.join(<span class=\"string\">\",\"</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 删除权限</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> delPermission = <span class=\"function\">(<span class=\"params\">userCode, permission</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> userPermission = userCode ? userCode.split(<span class=\"string\">\",\"</span>) : []</span><br><span class=\"line\">  <span class=\"keyword\">const</span> [index, pos] = permission.value.split(<span class=\"string\">\",\"</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">  userPermission[index] = (userPermission[index] || <span class=\"number\">0</span>) &amp; (~<span class=\"built_in\">Math</span>.pow(<span class=\"number\">2</span>, pos))</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> userPermission.join(<span class=\"string\">\",\"</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 判断是否有权限</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> hasPermission = <span class=\"function\">(<span class=\"params\">userCode, permission</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> userPermission = userCode ? userCode.split(<span class=\"string\">\",\"</span>) : []</span><br><span class=\"line\">  <span class=\"keyword\">const</span> [index, pos] = permission.value.split(<span class=\"string\">\",\"</span>)</span><br><span class=\"line\">  <span class=\"keyword\">const</span> permissionValue = <span class=\"built_in\">Math</span>.pow(<span class=\"number\">2</span>, pos)</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> (userPermission[index] &amp; permissionValue) === permissionValue</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 列出用户拥有的全部权限</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> listPermission = <span class=\"function\"><span class=\"params\">userCode</span> =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> results = []</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!userCode) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> results</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"built_in\">Object</span>.values(permissions).forEach(<span class=\"function\"><span class=\"params\">permission</span> =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (hasPermission(userCode, permission)) &#123;</span><br><span class=\"line\">      results.push(permission.info)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> results</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> log = <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">`userCode: <span class=\"subst\">$&#123;<span class=\"built_in\">JSON</span>.stringify(userCode, <span class=\"literal\">null</span>, <span class=\"string\">\" \"</span>)&#125;</span>`</span>)</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">`权限列表: <span class=\"subst\">$&#123;listPermission(userCode).join(<span class=\"string\">\"; \"</span>)&#125;</span>`</span>)</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">\"\"</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">userCode = addPermission(userCode, permissions.SYS_SETTING)</span><br><span class=\"line\">log()</span><br><span class=\"line\"><span class=\"comment\">// userCode: \"1\"</span></span><br><span class=\"line\"><span class=\"comment\">// 权限列表: 系统权限</span></span><br><span class=\"line\"></span><br><span class=\"line\">userCode = addPermission(userCode, permissions.POST_EDIT)</span><br><span class=\"line\">log()</span><br><span class=\"line\"><span class=\"comment\">// userCode: \"1,,16\"</span></span><br><span class=\"line\"><span class=\"comment\">// 权限列表: 系统权限; 文章编辑权限</span></span><br><span class=\"line\"></span><br><span class=\"line\">userCode = addPermission(userCode, permissions.USER_EDIT)</span><br><span class=\"line\">log()</span><br><span class=\"line\"><span class=\"comment\">// userCode: \"1073741825,,16\"</span></span><br><span class=\"line\"><span class=\"comment\">// 权限列表: 系统权限; 用户编辑权限; 文章编辑权限</span></span><br><span class=\"line\"></span><br><span class=\"line\">userCode = addPermission(userCode, permissions.USER_DELETE)</span><br><span class=\"line\">log()</span><br><span class=\"line\"><span class=\"comment\">// userCode: \"1073741825,131072,16\"</span></span><br><span class=\"line\"><span class=\"comment\">// 权限列表: 系统权限; 用户编辑权限; 用户删除权限; 文章编辑权限</span></span><br><span class=\"line\"></span><br><span class=\"line\">userCode = delPermission(userCode, permissions.USER_EDIT)</span><br><span class=\"line\">log()</span><br><span class=\"line\"><span class=\"comment\">// userCode: \"1,131072,16\"</span></span><br><span class=\"line\"><span class=\"comment\">// 权限列表: 系统权限; 用户删除权限; 文章编辑权限</span></span><br><span class=\"line\"></span><br><span class=\"line\">userCode = delPermission(userCode, permissions.USER_EDIT)</span><br><span class=\"line\">log()</span><br><span class=\"line\"><span class=\"comment\">// userCode: \"1,131072,16\"</span></span><br><span class=\"line\"><span class=\"comment\">// 权限列表: 系统权限; 用户删除权限; 文章编辑权限</span></span><br><span class=\"line\"></span><br><span class=\"line\">userCode = delPermission(userCode, permissions.USER_DELETE)</span><br><span class=\"line\">userCode = delPermission(userCode, permissions.SYS_SETTING)</span><br><span class=\"line\">userCode = delPermission(userCode, permissions.POST_EDIT)</span><br><span class=\"line\">log()</span><br><span class=\"line\"><span class=\"comment\">// userCode: \"0,0,0\"</span></span><br><span class=\"line\"><span class=\"comment\">// 权限列表: </span></span><br><span class=\"line\"></span><br><span class=\"line\">userCode = addPermission(userCode, permissions.SYS_SETTING)</span><br><span class=\"line\">log()</span><br><span class=\"line\"><span class=\"comment\">// userCode: \"1,0,0\"</span></span><br><span class=\"line\"><span class=\"comment\">// 权限列表: 系统权限</span></span><br><span class=\"line\">复制代码</span><br></pre></td></tr></table></figure>\n<p>除了通过引入<strong>权限空间</strong>的概念突破二进制运算的位数限制，还可以使用 <a href=\"http://mathjs.org\" target=\"_blank\" rel=\"noopener\">math.js</a> 的 <code>bignumber</code>，直接运算超过 32 位的二进制数，具体可以看它的文档，这里就不细说了。</p>\n<h2 id=\"5-适用场景和问题\"><a href=\"#5-适用场景和问题\" class=\"headerlink\" title=\"5. 适用场景和问题\"></a>5. 适用场景和问题</h2><p>如果按照当前使用最广泛的 <a href=\"https://zh.wikipedia.org/wiki/以角色為基礎的存取控制\" target=\"_blank\" rel=\"noopener\">RBAC</a> 模型设计权限系统，那么一般会有这么几个实体：应用，权限，角色，用户。用户权限可以直接来自权限，也可以来自角色：</p>\n<ul>\n<li>一个应用下有多个权限</li>\n<li>权限和角色是多对多的关系</li>\n<li>用户和角色是多对多的关系</li>\n<li>用户和权限是多对多的关系</li>\n</ul>\n<p>在此种模型下，一般会有用户与权限，用户与角色，角色与权限的对应关系表。想象一个商城后台权限管理系统，可能会有上万，甚至十几万店铺（应用），每个店铺可能会有数十个用户，角色，权限。随着业务的不断发展，刚才提到的那三张对应关系表会越来越大，越来越难以维护。</p>\n<p>而进制转换的方法则可以省略对应关系表，减少查询，节省空间。当然，省略掉对应关系不是没有坏处的，例如下面几个问题：</p>\n<ul>\n<li>如何高效的查找我的权限？</li>\n<li>如何高效的查找拥有某权限的所有用户？</li>\n<li>如何控制权限的有效期？</li>\n</ul>\n<p>所以进制转换的方案比较适合刚才提到的应用极其多，而每个应用中用户，权限，角色数量较少的场景。</p>\n<h2 id=\"6-其他方案\"><a href=\"#6-其他方案\" class=\"headerlink\" title=\"6. 其他方案\"></a>6. 其他方案</h2><p>除了二进制方案，当然还有其他方案可以达到类似的效果，例如直接使用一个1和0组成的字符串，权限点对应index，1表示拥有权限，0表示没有权限。举个例子：添加 0、删除 1、编辑 2，用户A拥有添加和编辑的权限，则 userCode 为 101；用户B拥有全部权限，userCode 为 111。这种方案比二进制转换简单，但是浪费空间。</p>\n<p>还有利用质数的方案，权限点全部为质数，用户权限为他所拥有的全部权限点的乘积。如：权限点是 2、3、5、7、11，用户权限是 5 <em> 7 </em> 11 = 385。这种方案麻烦的地方在于获取质数（新增权限点）和质因数分解（判断权限），权限点特别多的时候就快成 RSA 了，如果只有增删改查个别几个权限，倒是可以考虑。</p>\n<h2 id=\"7-参考\"><a href=\"#7-参考\" class=\"headerlink\" title=\"7. 参考\"></a>7. 参考</h2><ul>\n<li><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Numbers_and_dates\" target=\"_blank\" rel=\"noopener\">MDN：JavaScript 数字和日期</a></li>\n<li><a href=\"https://zh.wikipedia.org/wiki/雙精度浮點數\" target=\"_blank\" rel=\"noopener\">双精度浮点类型</a></li>\n<li><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Bitwise_Operators\" target=\"_blank\" rel=\"noopener\">MDN：按位操作符</a></li>\n<li><a href=\"https://www.jianshu.com/p/11f331d97ec2\" target=\"_blank\" rel=\"noopener\">【小知识大道理】被忽视的位运算</a></li>\n<li><a href=\"http://jerryzou.com/posts/do-you-really-want-use-bit-operators-in-JavaScript/\" target=\"_blank\" rel=\"noopener\">为什么不要在 JavaScript 中使用位操作符？</a></li>\n<li><a href=\"https://mp.weixin.qq.com/s/MKljuxfDMmopr_MrnYljGw\" target=\"_blank\" rel=\"noopener\">角色权限设计的100种解法</a></li>\n<li><a href=\"http://www.cnblogs.com/shijiaqi1066/p/3793894.html\" target=\"_blank\" rel=\"noopener\">权限系统与RBAC模型概述</a></li>\n<li><a href=\"https://blog.csdn.net/yingchunhua365/article/details/14090461\" target=\"_blank\" rel=\"noopener\">权限设计及算法</a></li>\n<li><a href=\"https://zh.wikipedia.org/wiki/以角色為基礎的存取控制\" target=\"_blank\" rel=\"noopener\">基于角色的访问控制</a></li>\n</ul>"},{"title":"Composition API归纳","date":"2020-09-01T08:00:00.000Z","_content":"\n# 前言\n\n## 动机与目的\n\n#### 更好的逻辑复用与代码组织\n\n Vue 当前 API编程模型的限制：\n\n1. 随着功能的增长，复杂组件的代码变得越来越难以阅读和理解。这种情况在开发人员阅读他人编写的代码时尤为常见。根本原因是 Vue 现有的 API 迫使我们通过选项组织代码，但是有的时候通过逻辑关系组织代码更有意义。\n2. 目前缺少一种简洁且低成本的机制来提取和重用多个组件之间的逻辑。\n\n#### 更好的类型推导\n\n大型项目开发者的常见需求是更好的 TypeScript 支持\n<!-- more -->\n# API\n\n## `setup`\n\n**理解**\n\nsetup()函数是vue3中新增的方法，可以理解为Composition Api的入口.\n\n**执行时机**\n\n在beforeCreate之前执行.\n\n**模板中使用**\n\n如果 `setup` 返回一个对象，则对象的属性将会被合并到组件模板的渲染上下文：\n\n```html\n<template>\n  <div>{{ count }} {{ object.foo }}</div>\n</template>\n\n<script>\n  import { ref, reactive } from 'vue'\n\n  export default {\n    setup() {\n      const count = ref(0)\n      const object = reactive({ foo: 'bar' })\n      // 暴露给模板\n      return {\n        count,\n        object,\n      }\n    },\n  }\n</script>\n```\n\n**接收props数据**\n\n然而**不要**解构 `props` 对象，那样会使其失去响应性：\n\n```javascript\nexport default {\n  props: {\n    msg: {\n      type: String,\n      default: () => {}\n    }\n  },\n  setup(props) {   // 不要写成setup({ msg })\n    console.log(props.msg);\n  }\n}\n```\n\n## 响应式系统 API\n\n### `reactive`\n\n接收一个普通对象然后返回该普通对象的响应式代理。等同于 2.x 的 `Vue.observable()`\n\n```js\nconst obj = reactive({ count: 0 })\n```\n\n### `ref`\n\n接受一个参数值并返回一个响应式且可改变的 ref 对象。ref 对象拥有一个指向内部值的单一属性 `.value`。\n\n```js\nconst count = ref(0)\nconsole.log(count.value) // 0\n\ncount.value++\nconsole.log(count.value) // 1\n```\n\n如果传入 ref 的是一个对象，将调用 `reactive` 方法进行深层响应转换。\n\n**模板中访问**\n\n当 ref 作为渲染上下文的属性返回（即在`setup()` 返回的对象中）并在模板中使用时，它会自动解套，无需在模板内额外书写 `.value`：\n\n```html\n<template>\n  <div>{{ count }}</div>\n</template>\n\n<script>\n  export default {\n    setup() {\n      return {\n        count: ref(0),\n      }\n    },\n  }\n</script>\n```\n\n### `computed`\n\n传入一个 getter 函数，返回一个默认不可手动修改的 ref 对象。\n\n```js\nconst count = ref(1)\nconst plusOne = computed(() => count.value + 1)\n\nconsole.log(plusOne.value) // 2\n\nplusOne.value++ // 错误！\n```\n\n或者传入一个拥有 `get` 和 `set` 函数的对象，创建一个可手动修改的计算状态。\n\n```js\nconst count = ref(1)\nconst plusOne = computed({\n  get: () => count.value + 1,\n  set: (val) => {\n    count.value = val - 1\n  },\n})\n\nplusOne.value = 1\nconsole.log(count.value) // 0\n```\n\n### `watchEffect`\n\n立即执行传入的一个函数，并响应式追踪其依赖，并在其依赖变更时重新运行该函数。\n\n```js\nconst count = ref(0)\n\nwatchEffect(() => console.log(count.value))\n// -> 打印出 0\n\nsetTimeout(() => {\n  count.value++\n  // -> 打印出 1\n}, 100)\n```\n\n#### 停止侦听\n\n当 `watchEffect` 在组件的 `setup()` 函数或生命周期钩子被调用时， 侦听器会被链接到该组件的生命周期，并在组件卸载时自动停止。\n\n在一些情况下，也可以显式调用返回值以停止侦听：\n\n```js\nconst stop = watchEffect(() => {\n  /* ... */\n})\n\n// 之后\nstop()\n```\n\n### `watch`\n\n`watch` API 完全等效于 2.x `this.$watch` （以及 `watch` 中相应的选项）。`watch` 需要侦听特定的数据源，并在回调函数中执行副作用。默认情况是懒执行的，也就是说仅在侦听的源变更时才执行回调。\n\n- 对比 `watchEffect`，`watch` 允许我们：\n  - 懒执行副作用；\n  - 更明确哪些状态的改变会触发侦听器重新运行副作用；\n  - 访问侦听状态变化前后的值。\n\n- **侦听单个数据源**\n\n  侦听器的数据源可以是一个拥有返回值的 getter 函数，也可以是 ref：\n\n  ```js\n  // 侦听一个 getter\n  const state = reactive({ count: 0 })\n  watch(\n    () => state.count,\n    (count, prevCount) => {\n      /* ... */\n    }\n  )\n  \n  // 直接侦听一个 ref\n  const count = ref(0)\n  watch(count, (count, prevCount) => {\n    /* ... */\n  })\n  ```\n\n- **侦听多个数据源**\n\n  `watcher` 也可以使用数组来同时侦听多个源：\n\n  ```js\n  watch([fooRef, barRef], ([foo, bar], [prevFoo, prevBar]) => {\n    /* ... */\n  })\n  ```\n\n## 生命周期钩子函数\n\n可以直接导入 `onXXX` 一族的函数来注册生命周期钩子：\n\n```js\nimport { onMounted, onUpdated, onUnmounted } from 'vue'\n\nconst MyComponent = {\n  setup() {\n    onMounted(() => {\n      console.log('mounted!')\n    })\n    onUpdated(() => {\n      console.log('updated!')\n    })\n    onUnmounted(() => {\n      console.log('unmounted!')\n    })\n  },\n}\n```\n\n这些生命周期钩子注册函数只能在 `setup()` 期间同步使用， 因为它们依赖于内部的全局状态来定位当前组件实例（正在调用 `setup()` 的组件实例）, 不在当前组件下调用这些函数会抛出一个错误。\n\n**与 2.x 版本生命周期相对应的组合式 API**\n\n- ~~`beforeCreate`~~ -> 使用 `setup()`\n- ~~`created`~~ -> 使用 `setup()`\n- `beforeMount` -> `onBeforeMount`\n- `mounted` -> `onMounted`\n- `beforeUpdate` -> `onBeforeUpdate`\n- `updated` -> `onUpdated`\n- `beforeDestroy` -> `onBeforeUnmount`\n- `destroyed` -> `onUnmounted`\n- `errorCaptured` -> `onErrorCaptured`\n\n**新增的钩子函数**\n\n除了和 2.x 生命周期等效项之外，组合式 API 还提供了以下调试钩子函数：\n\n- `onRenderTracked`\n- `onRenderTriggered`\n\n两个钩子函数都接收一个 `DebuggerEvent`\n\n## 依赖注入\n\n`provide` 和 `inject` 提供依赖注入，功能类似 2.x 的 `provide/inject`。两者都只能在当前活动组件实例的 `setup()` 中调用。\n\n```js\nimport { provide, inject } from 'vue'\n\nconst ThemeSymbol = Symbol()\n\nconst Ancestor = {\n  setup() {\n    provide(ThemeSymbol, 'dark')\n  },\n}\n\nconst Descendent = {\n  setup() {\n    const theme = inject(ThemeSymbol, 'light' /* optional default value */)\n    return {\n      theme,\n    }\n  },\n}\n```\n\n`inject` 接受一个可选的的默认值作为第二个参数。如果未提供默认值，并且在 provide 上下文中未找到该属性，则 `inject` 返回 `undefined`。\n\n**注入的响应性**\n\n可以使用 `ref` 来保证 `provided` 和 `injected` 之间值的响应：\n\n```js\n// 提供者：\nconst themeRef = ref('dark')\nprovide(ThemeSymbol, themeRef)\n\n// 使用者：\nconst theme = inject(ThemeSymbol, ref('light'))\nwatchEffect(() => {\n  console.log(`theme set to: ${theme.value}`)\n})\n```\n\n如果注入一个响应式对象，则它的状态变化也可以被侦听。\n\n## 模板 Refs\n\n当使用组合式 API 时，*reactive refs* 和 *template refs* 的概念已经是统一的。为了获得对模板内元素或组件实例的引用，我们可以像往常一样在 `setup()` 中声明一个 ref 并返回它：\n\n```html\n<template>\n  <div ref=\"rootRef\">{{ b }}</div>\n</template>\n\n<script>\n  import { ref, onMounted } from 'vue'\n\n  export default {\n    setup() {\n      const rootRef = ref(null)\n      cosnt b = ref(1)\n      onMounted(() => {\n        // 在渲染完成后, 这个 div DOM 会被赋值给 root ref 对象\n        console.log(root.value) // <div/>\n      })\n\n      return {\n        rootRef,\n        b\n      }\n    },\n  }\n</script>\n```\n\n这里我们将 `root` 暴露在渲染上下文中，并通过 `ref=\"root\"` 绑定到 `div` 作为其 `ref`。 在 Virtual DOM patch 算法中，如果一个 VNode 的 `ref` 对应一个渲染上下文中的 ref，则该 VNode 对应的元素或组件实例将被分配给该 ref。 这是在 Virtual DOM 的 mount / patch 过程中执行的，因此模板 ref 仅在渲染初始化后才能访问。\n\nref 被用在模板中时和其他 ref 一样：都是响应式的，并可以传递进组合函数（或从其中返回）。\n\n**配合 render 函数 / JSX 的用法**\n\n```js\nexport default {\n  setup() {\n    const root = ref(null)\n\n    return () =>\n      h('div', {\n        ref: root,\n      })\n\n    // 使用 JSX\n    return () => <div ref={root} />\n  },\n}\n```\n\n**在 `v-for` 中使用**\n\n模板 ref 在 `v-for` 中使用 vue 没有做特殊处理，需要使用**函数型的 ref**（3.0 提供的新功能）来自定义处理方式：\n\n```html\n<template>\n  <div v-for=\"(item, i) in list\" :ref=\"el => { divs[i] = el }\">\n    {{ item }}\n  </div>\n</template>\n\n<script>\n  import { ref, reactive, onBeforeUpdate } from 'vue'\n\n  export default {\n    setup() {\n      const list = reactive([1, 2, 3])\n      const divs = ref([])\n\n      // 确保在每次变更之前重置引用\n      onBeforeUpdate(() => {\n        divs.value = []\n      })\n\n      return {\n        list,\n        divs,\n      }\n    },\n  }\n</script>\n```\n\n## 响应式系统工具集\n\n### `isRef`\n\n检查一个值是否为一个 ref 对象。\n\n### `unref`\n\n如果参数是一个 ref 则返回它的 `value`，否则返回参数本身。它是 `val = isRef(val) ? val.value : val` 的语法糖。\n\n### `toRef`\n\n`toRef` 可以用来为一个 reactive 对象的属性创建一个 ref。这个 ref 可以被传递并且能够保持响应性。\n\n```js\nconst state = reactive({\n  foo: 1,\n  bar: 2,\n})\n\nconst fooRef = toRef(state, 'foo')\n\nfooRef.value++\nconsole.log(state.foo) // 2\n\nstate.foo++\nconsole.log(fooRef.value) // 3\n```\n\n当您要将一个 prop 中的属性作为 ref 传给组合逻辑函数时，`toRef` 就派上了用场：\n\n```js\nexport default {\n  setup(props) {\n    useSomeFeature(toRef(props, 'foo'))\n  },\n}\n```\n\n### `toRefs`\n\n把一个响应式对象转换成普通对象，该普通对象的每个 property 都是一个 ref ，和响应式对象 property 一一对应。\n\n```js\nconst state = reactive({\n  foo: 1,\n  bar: 2,\n})\n\nconst stateAsRefs = toRefs(state)\n\n// ref 对象 与 原属性的引用是 \"链接\" 上的\nstate.foo++\nconsole.log(stateAsRefs.foo.value) // 2\n\nstateAsRefs.foo.value++\nconsole.log(state.foo) // 3\n```\n\n当想要从一个组合逻辑函数中返回响应式对象时，用 `toRefs` 是很有效的，该 API 让消费组件可以 解构 / 扩展（使用 `...` 操作符）返回的对象，并不会丢失响应性：\n\n```js\nfunction useFeatureX() {\n  const state = reactive({\n    foo: 1,\n    bar: 2,\n  })\n  // 返回时将属性都转为 ref\n  return toRefs(state)\n}\n\nexport default {\n  setup() {\n    // 可以解构，不会丢失响应性\n    const { foo, bar } = useFeatureX()\n\n    return {\n      foo,\n      bar,\n    }\n  },\n}\n```\n\n### `isProxy`\n\n检查一个对象是否是由 `reactive` 或者 `readonly` 方法创建的代理。\n\n### `isReactive`\n\n检查一个对象是否是由 `reactive` 创建的响应式代理。\n\n\n\n# 讨论点\n\n### 代码组织\n\n通过上面的API我们已经将组件的基于选项的 API 复制成了一些被导入的函数，但是这么做的目的是什么？用选项来定义组件看上去比用一个混入所有东西的大函数更具组织性！\n\n但是实际上Composition API 实际上能够为你的代码带来*更*好组织结构，尤其是在复杂的组件中。\n\n#### 有组织的代码\n\n有组织的代码的最终目标应该是让代码更可读、更容易被理解。\n\n当要去理解一个组件时，我们更加关心的是“这个组件是要干什么” (即代码背后的意图) 而不是“这个组件用到了什么选项”。基于选项的 API 撰写出来的代码自然采用了后者的表述方式，然而对前者的表述并不好。\n\n#### 逻辑关注点 vs. 选项类型\n\n我们不妨将组件处理的“X、Y 和 Z”定义为**逻辑关注点**。可读性的问题基本不会存在于小的、单一用途的组件中，因为整个组件都在处理同一个逻辑关注点。然而这个问题在复杂的用例中会变得突出。以 [Vue CLI UI 文件浏览器](https://github.com/vuejs/vue-cli/blob/a09407dd5b9f18ace7501ddb603b95e31d6d93c0/packages/@vue/cli-ui/src/components/folder/FolderExplorer.vue#L198-L404)为例，这个组件有非常多的逻辑关注点：\n\n- 追踪监听当前文件夹的状态并展示其中的内容\n- 处理文件夹的操作（打开、关闭、刷新...）\n- 处理新建文件夹的创建\n- 是否只展示收藏文件夹\n- 是否只展示隐藏文件夹\n- 处理当前工作目录的变化\n\n你能通过阅读基于选项的代码直接梳理出各个逻辑关注点么？显然是十分困难的。你会发现到与各个逻辑关注点相关的代码是分散在各处的。\n\n例如“创建新文件夹”的功能使用到了[两个数据 property](https://github.com/vuejs/vue-cli/blob/a09407dd5b9f18ace7501ddb603b95e31d6d93c0/packages/@vue/cli-ui/src/components/folder/FolderExplorer.vue#L221-L222)、[一个计算属性](https://github.com/vuejs/vue-cli/blob/a09407dd5b9f18ace7501ddb603b95e31d6d93c0/packages/@vue/cli-ui/src/components/folder/FolderExplorer.vue#L240)和[一个方法](https://github.com/vuejs/vue-cli/blob/a09407dd5b9f18ace7501ddb603b95e31d6d93c0/packages/@vue/cli-ui/src/components/folder/FolderExplorer.vue#L387)，而方法的定义在距离数据 property 约一百多行的位置。\n\n如果我们对这些逻辑关注点进行染色，我们会注意到它们在用组件选项表示时是多么分散:\n\n![file explorer (before)](https://wos2.58cdn.com.cn/iJkFeDcBiJiJ/rocket/9407bcca-bbc4-4c27-95ab-0ba35afe20b2.jpeg)\n\n正是这种碎片化使得理解和维护一个复杂的组件变得非常困难。选项的强行分离为展示背后的逻辑关注点设置了障碍。此外，在处理单个逻辑关注点时，我们必须不断地在选项代码块之间“跳转”，以找到与该关注点相关的部分。\n\n如果我们能够将相同逻辑关注点的代码并列在一起，那就再好不过了。这正是组合式 API 所能做到的，“创建新文件夹”功能可以这样写：\n\n```js\nfunction useCreateFolder(openFolder) {  // 组合函数建议使用 use 作为函数名的开头\n  // 原来的数据 property\n  const showNewFolder = ref(false)\n  const newFolderName = ref('')\n\n  // 原来的计算属性\n  const newFolderValid = computed(() => isValidMultiName(newFolderName.value))\n\n  // 原来的一个方法\n  async function createFolder() {\n    if (!newFolderValid.value) return\n    const result = await mutate({\n      mutation: FOLDER_CREATE,\n      variables: {\n        name: newFolderName.value,\n      },\n    })\n    openFolder(result.data.folderCreate.path)\n    newFolderName.value = ''\n    showNewFolder.value = false\n  }\n\n  return {\n    showNewFolder,\n    newFolderName,\n    newFolderValid,\n    createFolder,\n  }\n}\n```\n\n此模式可用于该组件的所有其它逻辑关注点，最终成为一些良好解耦的函数:\n\n![file explorer (comparison)](https://wos2.58cdn.com.cn/iJkFeDcBiJiJ/rocket/5b63f225-3fb3-43f0-9ba2-4737f4990a3f.jpeg)\n\n每个逻辑关注点的代码现在都被组合进了一个组合函数。这大大减少了在处理大型组件时不断“跳转”的需要。同时组合函数也可以在编辑器中折叠起来，使组件更容易浏览:\n\n```js\nexport default {\n  setup() {\n    // ...\n  },\n}\n\nfunction useCurrentFolderData(networkState) {\n  // ...\n}\n\nfunction useFolderNavigation({ networkState, currentFolderData }) {\n  // ...\n}\n\nfunction useFavoriteFolder(currentFolderData) {\n  // ...\n}\n\nfunction useHiddenFolders() {\n  // ...\n}\n\nfunction useCreateFolder(openFolder) {\n  // ...\n}\n```\n\n同样的功能、两套组件定义呈现出对内在逻辑的不同的表达方式。基于选项的 API 促使我们通过 *选项类型* 组织代码，而组合式 API 让我们可以基于*逻辑关注点*组织代码。\n\n### 与 React Hooks 相比\n\n基于函数的组合式 API 提供了与 React Hooks 同等级别的逻辑组合能力，但是与它还是有很大不同：组合式 API 的 `setup()` 函数只会被调用一次，这意味着使用 Vue 组合式 API 的代码会是：\n\n- 一般来说更符合惯用的 JavaScript 代码的直觉；\n- 不需要顾虑调用顺序，也可以用在条件语句中；\n- 不会在每次渲染时重复执行，以降低垃圾回收的压力；\n- 不存在内联处理函数导致子组件永远更新的问题，也不需要 `useCallback`；\n- 不存在忘记记录依赖的问题，也不需要“useEffect”和“useMemo”并传入依赖数组以捕获过时的变量。Vue 的自动依赖跟踪可以确保侦听器和计算值总是准确无误。\n\n我们感谢 React Hooks 的创造性，它也是本提案的主要灵感来源，然而上面提到的一些问题存在于其设计之中，且我们发现 Vue 的响应式模型恰好为解决这些问题提供了一种思路。\n\n### why-the-composition-api\n\n- **Less code**（更少的代码）\n\n- **Familiar functions**（熟悉的功能）\n\n- **Extremely flexible**（极其灵活）\n\n- **Tooling friendly**（工具友好）\n\n- **Advanced syntax**（高级语法）\n\n<p align=\"right\">—引自Vue Mastery</p>\n\n","source":"_posts/Composition API.md","raw":"---\ntitle: Composition API归纳\ndate: 2020-09-01 16:00:00\ntags:\n    -vue3\ncategories:\n    - 技术分享\n---\n\n# 前言\n\n## 动机与目的\n\n#### 更好的逻辑复用与代码组织\n\n Vue 当前 API编程模型的限制：\n\n1. 随着功能的增长，复杂组件的代码变得越来越难以阅读和理解。这种情况在开发人员阅读他人编写的代码时尤为常见。根本原因是 Vue 现有的 API 迫使我们通过选项组织代码，但是有的时候通过逻辑关系组织代码更有意义。\n2. 目前缺少一种简洁且低成本的机制来提取和重用多个组件之间的逻辑。\n\n#### 更好的类型推导\n\n大型项目开发者的常见需求是更好的 TypeScript 支持\n<!-- more -->\n# API\n\n## `setup`\n\n**理解**\n\nsetup()函数是vue3中新增的方法，可以理解为Composition Api的入口.\n\n**执行时机**\n\n在beforeCreate之前执行.\n\n**模板中使用**\n\n如果 `setup` 返回一个对象，则对象的属性将会被合并到组件模板的渲染上下文：\n\n```html\n<template>\n  <div>{{ count }} {{ object.foo }}</div>\n</template>\n\n<script>\n  import { ref, reactive } from 'vue'\n\n  export default {\n    setup() {\n      const count = ref(0)\n      const object = reactive({ foo: 'bar' })\n      // 暴露给模板\n      return {\n        count,\n        object,\n      }\n    },\n  }\n</script>\n```\n\n**接收props数据**\n\n然而**不要**解构 `props` 对象，那样会使其失去响应性：\n\n```javascript\nexport default {\n  props: {\n    msg: {\n      type: String,\n      default: () => {}\n    }\n  },\n  setup(props) {   // 不要写成setup({ msg })\n    console.log(props.msg);\n  }\n}\n```\n\n## 响应式系统 API\n\n### `reactive`\n\n接收一个普通对象然后返回该普通对象的响应式代理。等同于 2.x 的 `Vue.observable()`\n\n```js\nconst obj = reactive({ count: 0 })\n```\n\n### `ref`\n\n接受一个参数值并返回一个响应式且可改变的 ref 对象。ref 对象拥有一个指向内部值的单一属性 `.value`。\n\n```js\nconst count = ref(0)\nconsole.log(count.value) // 0\n\ncount.value++\nconsole.log(count.value) // 1\n```\n\n如果传入 ref 的是一个对象，将调用 `reactive` 方法进行深层响应转换。\n\n**模板中访问**\n\n当 ref 作为渲染上下文的属性返回（即在`setup()` 返回的对象中）并在模板中使用时，它会自动解套，无需在模板内额外书写 `.value`：\n\n```html\n<template>\n  <div>{{ count }}</div>\n</template>\n\n<script>\n  export default {\n    setup() {\n      return {\n        count: ref(0),\n      }\n    },\n  }\n</script>\n```\n\n### `computed`\n\n传入一个 getter 函数，返回一个默认不可手动修改的 ref 对象。\n\n```js\nconst count = ref(1)\nconst plusOne = computed(() => count.value + 1)\n\nconsole.log(plusOne.value) // 2\n\nplusOne.value++ // 错误！\n```\n\n或者传入一个拥有 `get` 和 `set` 函数的对象，创建一个可手动修改的计算状态。\n\n```js\nconst count = ref(1)\nconst plusOne = computed({\n  get: () => count.value + 1,\n  set: (val) => {\n    count.value = val - 1\n  },\n})\n\nplusOne.value = 1\nconsole.log(count.value) // 0\n```\n\n### `watchEffect`\n\n立即执行传入的一个函数，并响应式追踪其依赖，并在其依赖变更时重新运行该函数。\n\n```js\nconst count = ref(0)\n\nwatchEffect(() => console.log(count.value))\n// -> 打印出 0\n\nsetTimeout(() => {\n  count.value++\n  // -> 打印出 1\n}, 100)\n```\n\n#### 停止侦听\n\n当 `watchEffect` 在组件的 `setup()` 函数或生命周期钩子被调用时， 侦听器会被链接到该组件的生命周期，并在组件卸载时自动停止。\n\n在一些情况下，也可以显式调用返回值以停止侦听：\n\n```js\nconst stop = watchEffect(() => {\n  /* ... */\n})\n\n// 之后\nstop()\n```\n\n### `watch`\n\n`watch` API 完全等效于 2.x `this.$watch` （以及 `watch` 中相应的选项）。`watch` 需要侦听特定的数据源，并在回调函数中执行副作用。默认情况是懒执行的，也就是说仅在侦听的源变更时才执行回调。\n\n- 对比 `watchEffect`，`watch` 允许我们：\n  - 懒执行副作用；\n  - 更明确哪些状态的改变会触发侦听器重新运行副作用；\n  - 访问侦听状态变化前后的值。\n\n- **侦听单个数据源**\n\n  侦听器的数据源可以是一个拥有返回值的 getter 函数，也可以是 ref：\n\n  ```js\n  // 侦听一个 getter\n  const state = reactive({ count: 0 })\n  watch(\n    () => state.count,\n    (count, prevCount) => {\n      /* ... */\n    }\n  )\n  \n  // 直接侦听一个 ref\n  const count = ref(0)\n  watch(count, (count, prevCount) => {\n    /* ... */\n  })\n  ```\n\n- **侦听多个数据源**\n\n  `watcher` 也可以使用数组来同时侦听多个源：\n\n  ```js\n  watch([fooRef, barRef], ([foo, bar], [prevFoo, prevBar]) => {\n    /* ... */\n  })\n  ```\n\n## 生命周期钩子函数\n\n可以直接导入 `onXXX` 一族的函数来注册生命周期钩子：\n\n```js\nimport { onMounted, onUpdated, onUnmounted } from 'vue'\n\nconst MyComponent = {\n  setup() {\n    onMounted(() => {\n      console.log('mounted!')\n    })\n    onUpdated(() => {\n      console.log('updated!')\n    })\n    onUnmounted(() => {\n      console.log('unmounted!')\n    })\n  },\n}\n```\n\n这些生命周期钩子注册函数只能在 `setup()` 期间同步使用， 因为它们依赖于内部的全局状态来定位当前组件实例（正在调用 `setup()` 的组件实例）, 不在当前组件下调用这些函数会抛出一个错误。\n\n**与 2.x 版本生命周期相对应的组合式 API**\n\n- ~~`beforeCreate`~~ -> 使用 `setup()`\n- ~~`created`~~ -> 使用 `setup()`\n- `beforeMount` -> `onBeforeMount`\n- `mounted` -> `onMounted`\n- `beforeUpdate` -> `onBeforeUpdate`\n- `updated` -> `onUpdated`\n- `beforeDestroy` -> `onBeforeUnmount`\n- `destroyed` -> `onUnmounted`\n- `errorCaptured` -> `onErrorCaptured`\n\n**新增的钩子函数**\n\n除了和 2.x 生命周期等效项之外，组合式 API 还提供了以下调试钩子函数：\n\n- `onRenderTracked`\n- `onRenderTriggered`\n\n两个钩子函数都接收一个 `DebuggerEvent`\n\n## 依赖注入\n\n`provide` 和 `inject` 提供依赖注入，功能类似 2.x 的 `provide/inject`。两者都只能在当前活动组件实例的 `setup()` 中调用。\n\n```js\nimport { provide, inject } from 'vue'\n\nconst ThemeSymbol = Symbol()\n\nconst Ancestor = {\n  setup() {\n    provide(ThemeSymbol, 'dark')\n  },\n}\n\nconst Descendent = {\n  setup() {\n    const theme = inject(ThemeSymbol, 'light' /* optional default value */)\n    return {\n      theme,\n    }\n  },\n}\n```\n\n`inject` 接受一个可选的的默认值作为第二个参数。如果未提供默认值，并且在 provide 上下文中未找到该属性，则 `inject` 返回 `undefined`。\n\n**注入的响应性**\n\n可以使用 `ref` 来保证 `provided` 和 `injected` 之间值的响应：\n\n```js\n// 提供者：\nconst themeRef = ref('dark')\nprovide(ThemeSymbol, themeRef)\n\n// 使用者：\nconst theme = inject(ThemeSymbol, ref('light'))\nwatchEffect(() => {\n  console.log(`theme set to: ${theme.value}`)\n})\n```\n\n如果注入一个响应式对象，则它的状态变化也可以被侦听。\n\n## 模板 Refs\n\n当使用组合式 API 时，*reactive refs* 和 *template refs* 的概念已经是统一的。为了获得对模板内元素或组件实例的引用，我们可以像往常一样在 `setup()` 中声明一个 ref 并返回它：\n\n```html\n<template>\n  <div ref=\"rootRef\">{{ b }}</div>\n</template>\n\n<script>\n  import { ref, onMounted } from 'vue'\n\n  export default {\n    setup() {\n      const rootRef = ref(null)\n      cosnt b = ref(1)\n      onMounted(() => {\n        // 在渲染完成后, 这个 div DOM 会被赋值给 root ref 对象\n        console.log(root.value) // <div/>\n      })\n\n      return {\n        rootRef,\n        b\n      }\n    },\n  }\n</script>\n```\n\n这里我们将 `root` 暴露在渲染上下文中，并通过 `ref=\"root\"` 绑定到 `div` 作为其 `ref`。 在 Virtual DOM patch 算法中，如果一个 VNode 的 `ref` 对应一个渲染上下文中的 ref，则该 VNode 对应的元素或组件实例将被分配给该 ref。 这是在 Virtual DOM 的 mount / patch 过程中执行的，因此模板 ref 仅在渲染初始化后才能访问。\n\nref 被用在模板中时和其他 ref 一样：都是响应式的，并可以传递进组合函数（或从其中返回）。\n\n**配合 render 函数 / JSX 的用法**\n\n```js\nexport default {\n  setup() {\n    const root = ref(null)\n\n    return () =>\n      h('div', {\n        ref: root,\n      })\n\n    // 使用 JSX\n    return () => <div ref={root} />\n  },\n}\n```\n\n**在 `v-for` 中使用**\n\n模板 ref 在 `v-for` 中使用 vue 没有做特殊处理，需要使用**函数型的 ref**（3.0 提供的新功能）来自定义处理方式：\n\n```html\n<template>\n  <div v-for=\"(item, i) in list\" :ref=\"el => { divs[i] = el }\">\n    {{ item }}\n  </div>\n</template>\n\n<script>\n  import { ref, reactive, onBeforeUpdate } from 'vue'\n\n  export default {\n    setup() {\n      const list = reactive([1, 2, 3])\n      const divs = ref([])\n\n      // 确保在每次变更之前重置引用\n      onBeforeUpdate(() => {\n        divs.value = []\n      })\n\n      return {\n        list,\n        divs,\n      }\n    },\n  }\n</script>\n```\n\n## 响应式系统工具集\n\n### `isRef`\n\n检查一个值是否为一个 ref 对象。\n\n### `unref`\n\n如果参数是一个 ref 则返回它的 `value`，否则返回参数本身。它是 `val = isRef(val) ? val.value : val` 的语法糖。\n\n### `toRef`\n\n`toRef` 可以用来为一个 reactive 对象的属性创建一个 ref。这个 ref 可以被传递并且能够保持响应性。\n\n```js\nconst state = reactive({\n  foo: 1,\n  bar: 2,\n})\n\nconst fooRef = toRef(state, 'foo')\n\nfooRef.value++\nconsole.log(state.foo) // 2\n\nstate.foo++\nconsole.log(fooRef.value) // 3\n```\n\n当您要将一个 prop 中的属性作为 ref 传给组合逻辑函数时，`toRef` 就派上了用场：\n\n```js\nexport default {\n  setup(props) {\n    useSomeFeature(toRef(props, 'foo'))\n  },\n}\n```\n\n### `toRefs`\n\n把一个响应式对象转换成普通对象，该普通对象的每个 property 都是一个 ref ，和响应式对象 property 一一对应。\n\n```js\nconst state = reactive({\n  foo: 1,\n  bar: 2,\n})\n\nconst stateAsRefs = toRefs(state)\n\n// ref 对象 与 原属性的引用是 \"链接\" 上的\nstate.foo++\nconsole.log(stateAsRefs.foo.value) // 2\n\nstateAsRefs.foo.value++\nconsole.log(state.foo) // 3\n```\n\n当想要从一个组合逻辑函数中返回响应式对象时，用 `toRefs` 是很有效的，该 API 让消费组件可以 解构 / 扩展（使用 `...` 操作符）返回的对象，并不会丢失响应性：\n\n```js\nfunction useFeatureX() {\n  const state = reactive({\n    foo: 1,\n    bar: 2,\n  })\n  // 返回时将属性都转为 ref\n  return toRefs(state)\n}\n\nexport default {\n  setup() {\n    // 可以解构，不会丢失响应性\n    const { foo, bar } = useFeatureX()\n\n    return {\n      foo,\n      bar,\n    }\n  },\n}\n```\n\n### `isProxy`\n\n检查一个对象是否是由 `reactive` 或者 `readonly` 方法创建的代理。\n\n### `isReactive`\n\n检查一个对象是否是由 `reactive` 创建的响应式代理。\n\n\n\n# 讨论点\n\n### 代码组织\n\n通过上面的API我们已经将组件的基于选项的 API 复制成了一些被导入的函数，但是这么做的目的是什么？用选项来定义组件看上去比用一个混入所有东西的大函数更具组织性！\n\n但是实际上Composition API 实际上能够为你的代码带来*更*好组织结构，尤其是在复杂的组件中。\n\n#### 有组织的代码\n\n有组织的代码的最终目标应该是让代码更可读、更容易被理解。\n\n当要去理解一个组件时，我们更加关心的是“这个组件是要干什么” (即代码背后的意图) 而不是“这个组件用到了什么选项”。基于选项的 API 撰写出来的代码自然采用了后者的表述方式，然而对前者的表述并不好。\n\n#### 逻辑关注点 vs. 选项类型\n\n我们不妨将组件处理的“X、Y 和 Z”定义为**逻辑关注点**。可读性的问题基本不会存在于小的、单一用途的组件中，因为整个组件都在处理同一个逻辑关注点。然而这个问题在复杂的用例中会变得突出。以 [Vue CLI UI 文件浏览器](https://github.com/vuejs/vue-cli/blob/a09407dd5b9f18ace7501ddb603b95e31d6d93c0/packages/@vue/cli-ui/src/components/folder/FolderExplorer.vue#L198-L404)为例，这个组件有非常多的逻辑关注点：\n\n- 追踪监听当前文件夹的状态并展示其中的内容\n- 处理文件夹的操作（打开、关闭、刷新...）\n- 处理新建文件夹的创建\n- 是否只展示收藏文件夹\n- 是否只展示隐藏文件夹\n- 处理当前工作目录的变化\n\n你能通过阅读基于选项的代码直接梳理出各个逻辑关注点么？显然是十分困难的。你会发现到与各个逻辑关注点相关的代码是分散在各处的。\n\n例如“创建新文件夹”的功能使用到了[两个数据 property](https://github.com/vuejs/vue-cli/blob/a09407dd5b9f18ace7501ddb603b95e31d6d93c0/packages/@vue/cli-ui/src/components/folder/FolderExplorer.vue#L221-L222)、[一个计算属性](https://github.com/vuejs/vue-cli/blob/a09407dd5b9f18ace7501ddb603b95e31d6d93c0/packages/@vue/cli-ui/src/components/folder/FolderExplorer.vue#L240)和[一个方法](https://github.com/vuejs/vue-cli/blob/a09407dd5b9f18ace7501ddb603b95e31d6d93c0/packages/@vue/cli-ui/src/components/folder/FolderExplorer.vue#L387)，而方法的定义在距离数据 property 约一百多行的位置。\n\n如果我们对这些逻辑关注点进行染色，我们会注意到它们在用组件选项表示时是多么分散:\n\n![file explorer (before)](https://wos2.58cdn.com.cn/iJkFeDcBiJiJ/rocket/9407bcca-bbc4-4c27-95ab-0ba35afe20b2.jpeg)\n\n正是这种碎片化使得理解和维护一个复杂的组件变得非常困难。选项的强行分离为展示背后的逻辑关注点设置了障碍。此外，在处理单个逻辑关注点时，我们必须不断地在选项代码块之间“跳转”，以找到与该关注点相关的部分。\n\n如果我们能够将相同逻辑关注点的代码并列在一起，那就再好不过了。这正是组合式 API 所能做到的，“创建新文件夹”功能可以这样写：\n\n```js\nfunction useCreateFolder(openFolder) {  // 组合函数建议使用 use 作为函数名的开头\n  // 原来的数据 property\n  const showNewFolder = ref(false)\n  const newFolderName = ref('')\n\n  // 原来的计算属性\n  const newFolderValid = computed(() => isValidMultiName(newFolderName.value))\n\n  // 原来的一个方法\n  async function createFolder() {\n    if (!newFolderValid.value) return\n    const result = await mutate({\n      mutation: FOLDER_CREATE,\n      variables: {\n        name: newFolderName.value,\n      },\n    })\n    openFolder(result.data.folderCreate.path)\n    newFolderName.value = ''\n    showNewFolder.value = false\n  }\n\n  return {\n    showNewFolder,\n    newFolderName,\n    newFolderValid,\n    createFolder,\n  }\n}\n```\n\n此模式可用于该组件的所有其它逻辑关注点，最终成为一些良好解耦的函数:\n\n![file explorer (comparison)](https://wos2.58cdn.com.cn/iJkFeDcBiJiJ/rocket/5b63f225-3fb3-43f0-9ba2-4737f4990a3f.jpeg)\n\n每个逻辑关注点的代码现在都被组合进了一个组合函数。这大大减少了在处理大型组件时不断“跳转”的需要。同时组合函数也可以在编辑器中折叠起来，使组件更容易浏览:\n\n```js\nexport default {\n  setup() {\n    // ...\n  },\n}\n\nfunction useCurrentFolderData(networkState) {\n  // ...\n}\n\nfunction useFolderNavigation({ networkState, currentFolderData }) {\n  // ...\n}\n\nfunction useFavoriteFolder(currentFolderData) {\n  // ...\n}\n\nfunction useHiddenFolders() {\n  // ...\n}\n\nfunction useCreateFolder(openFolder) {\n  // ...\n}\n```\n\n同样的功能、两套组件定义呈现出对内在逻辑的不同的表达方式。基于选项的 API 促使我们通过 *选项类型* 组织代码，而组合式 API 让我们可以基于*逻辑关注点*组织代码。\n\n### 与 React Hooks 相比\n\n基于函数的组合式 API 提供了与 React Hooks 同等级别的逻辑组合能力，但是与它还是有很大不同：组合式 API 的 `setup()` 函数只会被调用一次，这意味着使用 Vue 组合式 API 的代码会是：\n\n- 一般来说更符合惯用的 JavaScript 代码的直觉；\n- 不需要顾虑调用顺序，也可以用在条件语句中；\n- 不会在每次渲染时重复执行，以降低垃圾回收的压力；\n- 不存在内联处理函数导致子组件永远更新的问题，也不需要 `useCallback`；\n- 不存在忘记记录依赖的问题，也不需要“useEffect”和“useMemo”并传入依赖数组以捕获过时的变量。Vue 的自动依赖跟踪可以确保侦听器和计算值总是准确无误。\n\n我们感谢 React Hooks 的创造性，它也是本提案的主要灵感来源，然而上面提到的一些问题存在于其设计之中，且我们发现 Vue 的响应式模型恰好为解决这些问题提供了一种思路。\n\n### why-the-composition-api\n\n- **Less code**（更少的代码）\n\n- **Familiar functions**（熟悉的功能）\n\n- **Extremely flexible**（极其灵活）\n\n- **Tooling friendly**（工具友好）\n\n- **Advanced syntax**（高级语法）\n\n<p align=\"right\">—引自Vue Mastery</p>\n\n","slug":"Composition API","published":1,"updated":"2020-09-04T03:15:08.600Z","_id":"ckennwa7j0000na9mtwcobp0x","comments":1,"layout":"post","photos":[],"link":"","content":"<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h1><h2 id=\"动机与目的\"><a href=\"#动机与目的\" class=\"headerlink\" title=\"动机与目的\"></a>动机与目的</h2><h4 id=\"更好的逻辑复用与代码组织\"><a href=\"#更好的逻辑复用与代码组织\" class=\"headerlink\" title=\"更好的逻辑复用与代码组织\"></a>更好的逻辑复用与代码组织</h4><p> Vue 当前 API编程模型的限制：</p>\n<ol>\n<li>随着功能的增长，复杂组件的代码变得越来越难以阅读和理解。这种情况在开发人员阅读他人编写的代码时尤为常见。根本原因是 Vue 现有的 API 迫使我们通过选项组织代码，但是有的时候通过逻辑关系组织代码更有意义。</li>\n<li>目前缺少一种简洁且低成本的机制来提取和重用多个组件之间的逻辑。</li>\n</ol>\n<h4 id=\"更好的类型推导\"><a href=\"#更好的类型推导\" class=\"headerlink\" title=\"更好的类型推导\"></a>更好的类型推导</h4><p>大型项目开发者的常见需求是更好的 TypeScript 支持<br><a id=\"more\"></a></p>\n<h1 id=\"API\"><a href=\"#API\" class=\"headerlink\" title=\"API\"></a>API</h1><h2 id=\"setup\"><a href=\"#setup\" class=\"headerlink\" title=\"setup\"></a><code>setup</code></h2><p><strong>理解</strong></p>\n<p>setup()函数是vue3中新增的方法，可以理解为Composition Api的入口.</p>\n<p><strong>执行时机</strong></p>\n<p>在beforeCreate之前执行.</p>\n<p><strong>模板中使用</strong></p>\n<p>如果 <code>setup</code> 返回一个对象，则对象的属性将会被合并到组件模板的渲染上下文：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">template</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span>&#123;&#123; count &#125;&#125; &#123;&#123; object.foo &#125;&#125;<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">template</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span>&gt;</span><span class=\"undefined\"></span></span><br><span class=\"line\"><span class=\"undefined\">  import &#123; ref, reactive &#125; from 'vue'</span></span><br><span class=\"line\"><span class=\"undefined\"></span></span><br><span class=\"line\"><span class=\"undefined\">  export default &#123;</span></span><br><span class=\"line\"><span class=\"undefined\">    setup() &#123;</span></span><br><span class=\"line\"><span class=\"undefined\">      const count = ref(0)</span></span><br><span class=\"line\"><span class=\"undefined\">      const object = reactive(&#123; foo: 'bar' &#125;)</span></span><br><span class=\"line\"><span class=\"undefined\">      // 暴露给模板</span></span><br><span class=\"line\"><span class=\"undefined\">      return &#123;</span></span><br><span class=\"line\"><span class=\"undefined\">        count,</span></span><br><span class=\"line\"><span class=\"undefined\">        object,</span></span><br><span class=\"line\"><span class=\"undefined\">      &#125;</span></span><br><span class=\"line\"><span class=\"undefined\">    &#125;,</span></span><br><span class=\"line\"><span class=\"undefined\">  &#125;</span></span><br><span class=\"line\"><span class=\"undefined\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p><strong>接收props数据</strong></p>\n<p>然而<strong>不要</strong>解构 <code>props</code> 对象，那样会使其失去响应性：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> &#123;</span><br><span class=\"line\">  props: &#123;</span><br><span class=\"line\">    msg: &#123;</span><br><span class=\"line\">      type: <span class=\"built_in\">String</span>,</span><br><span class=\"line\">      <span class=\"keyword\">default</span>: <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;&#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  setup(props) &#123;   <span class=\"comment\">// 不要写成setup(&#123; msg &#125;)</span></span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(props.msg);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"响应式系统-API\"><a href=\"#响应式系统-API\" class=\"headerlink\" title=\"响应式系统 API\"></a>响应式系统 API</h2><h3 id=\"reactive\"><a href=\"#reactive\" class=\"headerlink\" title=\"reactive\"></a><code>reactive</code></h3><p>接收一个普通对象然后返回该普通对象的响应式代理。等同于 2.x 的 <code>Vue.observable()</code></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> obj = reactive(&#123; <span class=\"attr\">count</span>: <span class=\"number\">0</span> &#125;)</span><br></pre></td></tr></table></figure>\n<h3 id=\"ref\"><a href=\"#ref\" class=\"headerlink\" title=\"ref\"></a><code>ref</code></h3><p>接受一个参数值并返回一个响应式且可改变的 ref 对象。ref 对象拥有一个指向内部值的单一属性 <code>.value</code>。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> count = ref(<span class=\"number\">0</span>)</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(count.value) <span class=\"comment\">// 0</span></span><br><span class=\"line\"></span><br><span class=\"line\">count.value++</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(count.value) <span class=\"comment\">// 1</span></span><br></pre></td></tr></table></figure>\n<p>如果传入 ref 的是一个对象，将调用 <code>reactive</code> 方法进行深层响应转换。</p>\n<p><strong>模板中访问</strong></p>\n<p>当 ref 作为渲染上下文的属性返回（即在<code>setup()</code> 返回的对象中）并在模板中使用时，它会自动解套，无需在模板内额外书写 <code>.value</code>：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">template</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span>&#123;&#123; count &#125;&#125;<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">template</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span>&gt;</span><span class=\"undefined\"></span></span><br><span class=\"line\"><span class=\"javascript\">  <span class=\"keyword\">export</span> <span class=\"keyword\">default</span> &#123;</span></span><br><span class=\"line\"><span class=\"undefined\">    setup() &#123;</span></span><br><span class=\"line\"><span class=\"javascript\">      <span class=\"keyword\">return</span> &#123;</span></span><br><span class=\"line\"><span class=\"undefined\">        count: ref(0),</span></span><br><span class=\"line\"><span class=\"undefined\">      &#125;</span></span><br><span class=\"line\"><span class=\"undefined\">    &#125;,</span></span><br><span class=\"line\"><span class=\"undefined\">  &#125;</span></span><br><span class=\"line\"><span class=\"undefined\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"computed\"><a href=\"#computed\" class=\"headerlink\" title=\"computed\"></a><code>computed</code></h3><p>传入一个 getter 函数，返回一个默认不可手动修改的 ref 对象。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> count = ref(<span class=\"number\">1</span>)</span><br><span class=\"line\"><span class=\"keyword\">const</span> plusOne = computed(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> count.value + <span class=\"number\">1</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(plusOne.value) <span class=\"comment\">// 2</span></span><br><span class=\"line\"></span><br><span class=\"line\">plusOne.value++ <span class=\"comment\">// 错误！</span></span><br></pre></td></tr></table></figure>\n<p>或者传入一个拥有 <code>get</code> 和 <code>set</code> 函数的对象，创建一个可手动修改的计算状态。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> count = ref(<span class=\"number\">1</span>)</span><br><span class=\"line\"><span class=\"keyword\">const</span> plusOne = computed(&#123;</span><br><span class=\"line\">  get: <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> count.value + <span class=\"number\">1</span>,</span><br><span class=\"line\">  set: <span class=\"function\">(<span class=\"params\">val</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    count.value = val - <span class=\"number\">1</span></span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">plusOne.value = <span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(count.value) <span class=\"comment\">// 0</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"watchEffect\"><a href=\"#watchEffect\" class=\"headerlink\" title=\"watchEffect\"></a><code>watchEffect</code></h3><p>立即执行传入的一个函数，并响应式追踪其依赖，并在其依赖变更时重新运行该函数。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> count = ref(<span class=\"number\">0</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">watchEffect(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> <span class=\"built_in\">console</span>.log(count.value))</span><br><span class=\"line\"><span class=\"comment\">// -&gt; 打印出 0</span></span><br><span class=\"line\"></span><br><span class=\"line\">setTimeout(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">  count.value++</span><br><span class=\"line\">  <span class=\"comment\">// -&gt; 打印出 1</span></span><br><span class=\"line\">&#125;, <span class=\"number\">100</span>)</span><br></pre></td></tr></table></figure>\n<h4 id=\"停止侦听\"><a href=\"#停止侦听\" class=\"headerlink\" title=\"停止侦听\"></a>停止侦听</h4><p>当 <code>watchEffect</code> 在组件的 <code>setup()</code> 函数或生命周期钩子被调用时， 侦听器会被链接到该组件的生命周期，并在组件卸载时自动停止。</p>\n<p>在一些情况下，也可以显式调用返回值以停止侦听：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> stop = watchEffect(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">/* ... */</span></span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 之后</span></span><br><span class=\"line\">stop()</span><br></pre></td></tr></table></figure>\n<h3 id=\"watch\"><a href=\"#watch\" class=\"headerlink\" title=\"watch\"></a><code>watch</code></h3><p><code>watch</code> API 完全等效于 2.x <code>this.$watch</code> （以及 <code>watch</code> 中相应的选项）。<code>watch</code> 需要侦听特定的数据源，并在回调函数中执行副作用。默认情况是懒执行的，也就是说仅在侦听的源变更时才执行回调。</p>\n<ul>\n<li><p>对比 <code>watchEffect</code>，<code>watch</code> 允许我们：</p>\n<ul>\n<li>懒执行副作用；</li>\n<li>更明确哪些状态的改变会触发侦听器重新运行副作用；</li>\n<li>访问侦听状态变化前后的值。</li>\n</ul>\n</li>\n<li><p><strong>侦听单个数据源</strong></p>\n<p>侦听器的数据源可以是一个拥有返回值的 getter 函数，也可以是 ref：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 侦听一个 getter</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> state = reactive(&#123; <span class=\"attr\">count</span>: <span class=\"number\">0</span> &#125;)</span><br><span class=\"line\">watch(</span><br><span class=\"line\">  () =&gt; state.count,</span><br><span class=\"line\">  (count, prevCount) =&gt; &#123;</span><br><span class=\"line\">    <span class=\"comment\">/* ... */</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 直接侦听一个 ref</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> count = ref(<span class=\"number\">0</span>)</span><br><span class=\"line\">watch(count, (count, prevCount) =&gt; &#123;</span><br><span class=\"line\">  <span class=\"comment\">/* ... */</span></span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n</li>\n<li><p><strong>侦听多个数据源</strong></p>\n<p><code>watcher</code> 也可以使用数组来同时侦听多个源：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">watch([fooRef, barRef], ([foo, bar], [prevFoo, prevBar]) =&gt; &#123;</span><br><span class=\"line\">  <span class=\"comment\">/* ... */</span></span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h2 id=\"生命周期钩子函数\"><a href=\"#生命周期钩子函数\" class=\"headerlink\" title=\"生命周期钩子函数\"></a>生命周期钩子函数</h2><p>可以直接导入 <code>onXXX</code> 一族的函数来注册生命周期钩子：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; onMounted, onUpdated, onUnmounted &#125; <span class=\"keyword\">from</span> <span class=\"string\">'vue'</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> MyComponent = &#123;</span><br><span class=\"line\">  setup() &#123;</span><br><span class=\"line\">    onMounted(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">      <span class=\"built_in\">console</span>.log(<span class=\"string\">'mounted!'</span>)</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">    onUpdated(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">      <span class=\"built_in\">console</span>.log(<span class=\"string\">'updated!'</span>)</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">    onUnmounted(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">      <span class=\"built_in\">console</span>.log(<span class=\"string\">'unmounted!'</span>)</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这些生命周期钩子注册函数只能在 <code>setup()</code> 期间同步使用， 因为它们依赖于内部的全局状态来定位当前组件实例（正在调用 <code>setup()</code> 的组件实例）, 不在当前组件下调用这些函数会抛出一个错误。</p>\n<p><strong>与 2.x 版本生命周期相对应的组合式 API</strong></p>\n<ul>\n<li><del><code>beforeCreate</code></del> -&gt; 使用 <code>setup()</code></li>\n<li><del><code>created</code></del> -&gt; 使用 <code>setup()</code></li>\n<li><code>beforeMount</code> -&gt; <code>onBeforeMount</code></li>\n<li><code>mounted</code> -&gt; <code>onMounted</code></li>\n<li><code>beforeUpdate</code> -&gt; <code>onBeforeUpdate</code></li>\n<li><code>updated</code> -&gt; <code>onUpdated</code></li>\n<li><code>beforeDestroy</code> -&gt; <code>onBeforeUnmount</code></li>\n<li><code>destroyed</code> -&gt; <code>onUnmounted</code></li>\n<li><code>errorCaptured</code> -&gt; <code>onErrorCaptured</code></li>\n</ul>\n<p><strong>新增的钩子函数</strong></p>\n<p>除了和 2.x 生命周期等效项之外，组合式 API 还提供了以下调试钩子函数：</p>\n<ul>\n<li><code>onRenderTracked</code></li>\n<li><code>onRenderTriggered</code></li>\n</ul>\n<p>两个钩子函数都接收一个 <code>DebuggerEvent</code></p>\n<h2 id=\"依赖注入\"><a href=\"#依赖注入\" class=\"headerlink\" title=\"依赖注入\"></a>依赖注入</h2><p><code>provide</code> 和 <code>inject</code> 提供依赖注入，功能类似 2.x 的 <code>provide/inject</code>。两者都只能在当前活动组件实例的 <code>setup()</code> 中调用。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; provide, inject &#125; <span class=\"keyword\">from</span> <span class=\"string\">'vue'</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> ThemeSymbol = <span class=\"built_in\">Symbol</span>()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> Ancestor = &#123;</span><br><span class=\"line\">  setup() &#123;</span><br><span class=\"line\">    provide(ThemeSymbol, <span class=\"string\">'dark'</span>)</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> Descendent = &#123;</span><br><span class=\"line\">  setup() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> theme = inject(ThemeSymbol, <span class=\"string\">'light'</span> <span class=\"comment\">/* optional default value */</span>)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">      theme,</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>inject</code> 接受一个可选的的默认值作为第二个参数。如果未提供默认值，并且在 provide 上下文中未找到该属性，则 <code>inject</code> 返回 <code>undefined</code>。</p>\n<p><strong>注入的响应性</strong></p>\n<p>可以使用 <code>ref</code> 来保证 <code>provided</code> 和 <code>injected</code> 之间值的响应：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 提供者：</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> themeRef = ref(<span class=\"string\">'dark'</span>)</span><br><span class=\"line\">provide(ThemeSymbol, themeRef)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 使用者：</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> theme = inject(ThemeSymbol, ref(<span class=\"string\">'light'</span>))</span><br><span class=\"line\">watchEffect(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">`theme set to: <span class=\"subst\">$&#123;theme.value&#125;</span>`</span>)</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<p>如果注入一个响应式对象，则它的状态变化也可以被侦听。</p>\n<h2 id=\"模板-Refs\"><a href=\"#模板-Refs\" class=\"headerlink\" title=\"模板 Refs\"></a>模板 Refs</h2><p>当使用组合式 API 时，<em>reactive refs</em> 和 <em>template refs</em> 的概念已经是统一的。为了获得对模板内元素或组件实例的引用，我们可以像往常一样在 <code>setup()</code> 中声明一个 ref 并返回它：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">template</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">ref</span>=<span class=\"string\">\"rootRef\"</span>&gt;</span>&#123;&#123; b &#125;&#125;<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">template</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span>&gt;</span><span class=\"undefined\"></span></span><br><span class=\"line\"><span class=\"javascript\">  <span class=\"keyword\">import</span> &#123; ref, onMounted &#125; <span class=\"keyword\">from</span> <span class=\"string\">'vue'</span></span></span><br><span class=\"line\"><span class=\"undefined\"></span></span><br><span class=\"line\"><span class=\"javascript\">  <span class=\"keyword\">export</span> <span class=\"keyword\">default</span> &#123;</span></span><br><span class=\"line\"><span class=\"undefined\">    setup() &#123;</span></span><br><span class=\"line\"><span class=\"javascript\">      <span class=\"keyword\">const</span> rootRef = ref(<span class=\"literal\">null</span>)</span></span><br><span class=\"line\"><span class=\"undefined\">      cosnt b = ref(1)</span></span><br><span class=\"line\"><span class=\"javascript\">      onMounted(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span></span><br><span class=\"line\"><span class=\"javascript\">        <span class=\"comment\">// 在渲染完成后, 这个 div DOM 会被赋值给 root ref 对象</span></span></span><br><span class=\"line\"><span class=\"javascript\">        <span class=\"built_in\">console</span>.log(root.value) <span class=\"comment\">// &lt;div/&gt;</span></span></span><br><span class=\"line\"><span class=\"undefined\">      &#125;)</span></span><br><span class=\"line\"><span class=\"undefined\"></span></span><br><span class=\"line\"><span class=\"javascript\">      <span class=\"keyword\">return</span> &#123;</span></span><br><span class=\"line\"><span class=\"undefined\">        rootRef,</span></span><br><span class=\"line\"><span class=\"undefined\">        b</span></span><br><span class=\"line\"><span class=\"undefined\">      &#125;</span></span><br><span class=\"line\"><span class=\"undefined\">    &#125;,</span></span><br><span class=\"line\"><span class=\"undefined\">  &#125;</span></span><br><span class=\"line\"><span class=\"undefined\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>这里我们将 <code>root</code> 暴露在渲染上下文中，并通过 <code>ref=&quot;root&quot;</code> 绑定到 <code>div</code> 作为其 <code>ref</code>。 在 Virtual DOM patch 算法中，如果一个 VNode 的 <code>ref</code> 对应一个渲染上下文中的 ref，则该 VNode 对应的元素或组件实例将被分配给该 ref。 这是在 Virtual DOM 的 mount / patch 过程中执行的，因此模板 ref 仅在渲染初始化后才能访问。</p>\n<p>ref 被用在模板中时和其他 ref 一样：都是响应式的，并可以传递进组合函数（或从其中返回）。</p>\n<p><strong>配合 render 函数 / JSX 的用法</strong></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> &#123;</span><br><span class=\"line\">  setup() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> root = ref(<span class=\"literal\">null</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"params\">()</span> =&gt;</span></span><br><span class=\"line\">      h(<span class=\"string\">'div'</span>, &#123;</span><br><span class=\"line\">        ref: root,</span><br><span class=\"line\">      &#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 使用 JSX</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &lt;div ref=&#123;root&#125; /&gt;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>在 <code>v-for</code> 中使用</strong></p>\n<p>模板 ref 在 <code>v-for</code> 中使用 vue 没有做特殊处理，需要使用<strong>函数型的 ref</strong>（3.0 提供的新功能）来自定义处理方式：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">template</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">v-for</span>=<span class=\"string\">\"(item, i) in list\"</span> <span class=\"attr\">:ref</span>=<span class=\"string\">\"el =&gt; &#123; divs[i] = el &#125;\"</span>&gt;</span></span><br><span class=\"line\">    &#123;&#123; item &#125;&#125;</span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">template</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span>&gt;</span><span class=\"undefined\"></span></span><br><span class=\"line\"><span class=\"javascript\">  <span class=\"keyword\">import</span> &#123; ref, reactive, onBeforeUpdate &#125; <span class=\"keyword\">from</span> <span class=\"string\">'vue'</span></span></span><br><span class=\"line\"><span class=\"undefined\"></span></span><br><span class=\"line\"><span class=\"javascript\">  <span class=\"keyword\">export</span> <span class=\"keyword\">default</span> &#123;</span></span><br><span class=\"line\"><span class=\"undefined\">    setup() &#123;</span></span><br><span class=\"line\"><span class=\"javascript\">      <span class=\"keyword\">const</span> list = reactive([<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>])</span></span><br><span class=\"line\"><span class=\"javascript\">      <span class=\"keyword\">const</span> divs = ref([])</span></span><br><span class=\"line\"><span class=\"undefined\"></span></span><br><span class=\"line\"><span class=\"javascript\">      <span class=\"comment\">// 确保在每次变更之前重置引用</span></span></span><br><span class=\"line\"><span class=\"javascript\">      onBeforeUpdate(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span></span><br><span class=\"line\"><span class=\"undefined\">        divs.value = []</span></span><br><span class=\"line\"><span class=\"undefined\">      &#125;)</span></span><br><span class=\"line\"><span class=\"undefined\"></span></span><br><span class=\"line\"><span class=\"javascript\">      <span class=\"keyword\">return</span> &#123;</span></span><br><span class=\"line\"><span class=\"undefined\">        list,</span></span><br><span class=\"line\"><span class=\"undefined\">        divs,</span></span><br><span class=\"line\"><span class=\"undefined\">      &#125;</span></span><br><span class=\"line\"><span class=\"undefined\">    &#125;,</span></span><br><span class=\"line\"><span class=\"undefined\">  &#125;</span></span><br><span class=\"line\"><span class=\"undefined\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"响应式系统工具集\"><a href=\"#响应式系统工具集\" class=\"headerlink\" title=\"响应式系统工具集\"></a>响应式系统工具集</h2><h3 id=\"isRef\"><a href=\"#isRef\" class=\"headerlink\" title=\"isRef\"></a><code>isRef</code></h3><p>检查一个值是否为一个 ref 对象。</p>\n<h3 id=\"unref\"><a href=\"#unref\" class=\"headerlink\" title=\"unref\"></a><code>unref</code></h3><p>如果参数是一个 ref 则返回它的 <code>value</code>，否则返回参数本身。它是 <code>val = isRef(val) ? val.value : val</code> 的语法糖。</p>\n<h3 id=\"toRef\"><a href=\"#toRef\" class=\"headerlink\" title=\"toRef\"></a><code>toRef</code></h3><p><code>toRef</code> 可以用来为一个 reactive 对象的属性创建一个 ref。这个 ref 可以被传递并且能够保持响应性。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> state = reactive(&#123;</span><br><span class=\"line\">  foo: <span class=\"number\">1</span>,</span><br><span class=\"line\">  bar: <span class=\"number\">2</span>,</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> fooRef = toRef(state, <span class=\"string\">'foo'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">fooRef.value++</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(state.foo) <span class=\"comment\">// 2</span></span><br><span class=\"line\"></span><br><span class=\"line\">state.foo++</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(fooRef.value) <span class=\"comment\">// 3</span></span><br></pre></td></tr></table></figure>\n<p>当您要将一个 prop 中的属性作为 ref 传给组合逻辑函数时，<code>toRef</code> 就派上了用场：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> &#123;</span><br><span class=\"line\">  setup(props) &#123;</span><br><span class=\"line\">    useSomeFeature(toRef(props, <span class=\"string\">'foo'</span>))</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"toRefs\"><a href=\"#toRefs\" class=\"headerlink\" title=\"toRefs\"></a><code>toRefs</code></h3><p>把一个响应式对象转换成普通对象，该普通对象的每个 property 都是一个 ref ，和响应式对象 property 一一对应。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> state = reactive(&#123;</span><br><span class=\"line\">  foo: <span class=\"number\">1</span>,</span><br><span class=\"line\">  bar: <span class=\"number\">2</span>,</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> stateAsRefs = toRefs(state)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// ref 对象 与 原属性的引用是 \"链接\" 上的</span></span><br><span class=\"line\">state.foo++</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(stateAsRefs.foo.value) <span class=\"comment\">// 2</span></span><br><span class=\"line\"></span><br><span class=\"line\">stateAsRefs.foo.value++</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(state.foo) <span class=\"comment\">// 3</span></span><br></pre></td></tr></table></figure>\n<p>当想要从一个组合逻辑函数中返回响应式对象时，用 <code>toRefs</code> 是很有效的，该 API 让消费组件可以 解构 / 扩展（使用 <code>...</code> 操作符）返回的对象，并不会丢失响应性：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">useFeatureX</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> state = reactive(&#123;</span><br><span class=\"line\">    foo: <span class=\"number\">1</span>,</span><br><span class=\"line\">    bar: <span class=\"number\">2</span>,</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">  <span class=\"comment\">// 返回时将属性都转为 ref</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> toRefs(state)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> &#123;</span><br><span class=\"line\">  setup() &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 可以解构，不会丢失响应性</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> &#123; foo, bar &#125; = useFeatureX()</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">      foo,</span><br><span class=\"line\">      bar,</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"isProxy\"><a href=\"#isProxy\" class=\"headerlink\" title=\"isProxy\"></a><code>isProxy</code></h3><p>检查一个对象是否是由 <code>reactive</code> 或者 <code>readonly</code> 方法创建的代理。</p>\n<h3 id=\"isReactive\"><a href=\"#isReactive\" class=\"headerlink\" title=\"isReactive\"></a><code>isReactive</code></h3><p>检查一个对象是否是由 <code>reactive</code> 创建的响应式代理。</p>\n<h1 id=\"讨论点\"><a href=\"#讨论点\" class=\"headerlink\" title=\"讨论点\"></a>讨论点</h1><h3 id=\"代码组织\"><a href=\"#代码组织\" class=\"headerlink\" title=\"代码组织\"></a>代码组织</h3><p>通过上面的API我们已经将组件的基于选项的 API 复制成了一些被导入的函数，但是这么做的目的是什么？用选项来定义组件看上去比用一个混入所有东西的大函数更具组织性！</p>\n<p>但是实际上Composition API 实际上能够为你的代码带来<em>更</em>好组织结构，尤其是在复杂的组件中。</p>\n<h4 id=\"有组织的代码\"><a href=\"#有组织的代码\" class=\"headerlink\" title=\"有组织的代码\"></a>有组织的代码</h4><p>有组织的代码的最终目标应该是让代码更可读、更容易被理解。</p>\n<p>当要去理解一个组件时，我们更加关心的是“这个组件是要干什么” (即代码背后的意图) 而不是“这个组件用到了什么选项”。基于选项的 API 撰写出来的代码自然采用了后者的表述方式，然而对前者的表述并不好。</p>\n<h4 id=\"逻辑关注点-vs-选项类型\"><a href=\"#逻辑关注点-vs-选项类型\" class=\"headerlink\" title=\"逻辑关注点 vs. 选项类型\"></a>逻辑关注点 vs. 选项类型</h4><p>我们不妨将组件处理的“X、Y 和 Z”定义为<strong>逻辑关注点</strong>。可读性的问题基本不会存在于小的、单一用途的组件中，因为整个组件都在处理同一个逻辑关注点。然而这个问题在复杂的用例中会变得突出。以 <a href=\"https://github.com/vuejs/vue-cli/blob/a09407dd5b9f18ace7501ddb603b95e31d6d93c0/packages/@vue/cli-ui/src/components/folder/FolderExplorer.vue#L198-L404\" target=\"_blank\" rel=\"noopener\">Vue CLI UI 文件浏览器</a>为例，这个组件有非常多的逻辑关注点：</p>\n<ul>\n<li>追踪监听当前文件夹的状态并展示其中的内容</li>\n<li>处理文件夹的操作（打开、关闭、刷新…）</li>\n<li>处理新建文件夹的创建</li>\n<li>是否只展示收藏文件夹</li>\n<li>是否只展示隐藏文件夹</li>\n<li>处理当前工作目录的变化</li>\n</ul>\n<p>你能通过阅读基于选项的代码直接梳理出各个逻辑关注点么？显然是十分困难的。你会发现到与各个逻辑关注点相关的代码是分散在各处的。</p>\n<p>例如“创建新文件夹”的功能使用到了<a href=\"https://github.com/vuejs/vue-cli/blob/a09407dd5b9f18ace7501ddb603b95e31d6d93c0/packages/@vue/cli-ui/src/components/folder/FolderExplorer.vue#L221-L222\" target=\"_blank\" rel=\"noopener\">两个数据 property</a>、<a href=\"https://github.com/vuejs/vue-cli/blob/a09407dd5b9f18ace7501ddb603b95e31d6d93c0/packages/@vue/cli-ui/src/components/folder/FolderExplorer.vue#L240\" target=\"_blank\" rel=\"noopener\">一个计算属性</a>和<a href=\"https://github.com/vuejs/vue-cli/blob/a09407dd5b9f18ace7501ddb603b95e31d6d93c0/packages/@vue/cli-ui/src/components/folder/FolderExplorer.vue#L387\" target=\"_blank\" rel=\"noopener\">一个方法</a>，而方法的定义在距离数据 property 约一百多行的位置。</p>\n<p>如果我们对这些逻辑关注点进行染色，我们会注意到它们在用组件选项表示时是多么分散:</p>\n<p><img src=\"https://wos2.58cdn.com.cn/iJkFeDcBiJiJ/rocket/9407bcca-bbc4-4c27-95ab-0ba35afe20b2.jpeg\" alt=\"file explorer (before)\"></p>\n<p>正是这种碎片化使得理解和维护一个复杂的组件变得非常困难。选项的强行分离为展示背后的逻辑关注点设置了障碍。此外，在处理单个逻辑关注点时，我们必须不断地在选项代码块之间“跳转”，以找到与该关注点相关的部分。</p>\n<p>如果我们能够将相同逻辑关注点的代码并列在一起，那就再好不过了。这正是组合式 API 所能做到的，“创建新文件夹”功能可以这样写：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">useCreateFolder</span>(<span class=\"params\">openFolder</span>) </span>&#123;  <span class=\"comment\">// 组合函数建议使用 use 作为函数名的开头</span></span><br><span class=\"line\">  <span class=\"comment\">// 原来的数据 property</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> showNewFolder = ref(<span class=\"literal\">false</span>)</span><br><span class=\"line\">  <span class=\"keyword\">const</span> newFolderName = ref(<span class=\"string\">''</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 原来的计算属性</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> newFolderValid = computed(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> isValidMultiName(newFolderName.value))</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 原来的一个方法</span></span><br><span class=\"line\">  <span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">createFolder</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!newFolderValid.value) <span class=\"keyword\">return</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> result = <span class=\"keyword\">await</span> mutate(&#123;</span><br><span class=\"line\">      mutation: FOLDER_CREATE,</span><br><span class=\"line\">      variables: &#123;</span><br><span class=\"line\">        name: newFolderName.value,</span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">    openFolder(result.data.folderCreate.path)</span><br><span class=\"line\">    newFolderName.value = <span class=\"string\">''</span></span><br><span class=\"line\">    showNewFolder.value = <span class=\"literal\">false</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">    showNewFolder,</span><br><span class=\"line\">    newFolderName,</span><br><span class=\"line\">    newFolderValid,</span><br><span class=\"line\">    createFolder,</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>此模式可用于该组件的所有其它逻辑关注点，最终成为一些良好解耦的函数:</p>\n<p><img src=\"https://wos2.58cdn.com.cn/iJkFeDcBiJiJ/rocket/5b63f225-3fb3-43f0-9ba2-4737f4990a3f.jpeg\" alt=\"file explorer (comparison)\"></p>\n<p>每个逻辑关注点的代码现在都被组合进了一个组合函数。这大大减少了在处理大型组件时不断“跳转”的需要。同时组合函数也可以在编辑器中折叠起来，使组件更容易浏览:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> &#123;</span><br><span class=\"line\">  setup() &#123;</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">useCurrentFolderData</span>(<span class=\"params\">networkState</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">useFolderNavigation</span>(<span class=\"params\">&#123; networkState, currentFolderData &#125;</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">useFavoriteFolder</span>(<span class=\"params\">currentFolderData</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">useHiddenFolders</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">useCreateFolder</span>(<span class=\"params\">openFolder</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>同样的功能、两套组件定义呈现出对内在逻辑的不同的表达方式。基于选项的 API 促使我们通过 <em>选项类型</em> 组织代码，而组合式 API 让我们可以基于<em>逻辑关注点</em>组织代码。</p>\n<h3 id=\"与-React-Hooks-相比\"><a href=\"#与-React-Hooks-相比\" class=\"headerlink\" title=\"与 React Hooks 相比\"></a>与 React Hooks 相比</h3><p>基于函数的组合式 API 提供了与 React Hooks 同等级别的逻辑组合能力，但是与它还是有很大不同：组合式 API 的 <code>setup()</code> 函数只会被调用一次，这意味着使用 Vue 组合式 API 的代码会是：</p>\n<ul>\n<li>一般来说更符合惯用的 JavaScript 代码的直觉；</li>\n<li>不需要顾虑调用顺序，也可以用在条件语句中；</li>\n<li>不会在每次渲染时重复执行，以降低垃圾回收的压力；</li>\n<li>不存在内联处理函数导致子组件永远更新的问题，也不需要 <code>useCallback</code>；</li>\n<li>不存在忘记记录依赖的问题，也不需要“useEffect”和“useMemo”并传入依赖数组以捕获过时的变量。Vue 的自动依赖跟踪可以确保侦听器和计算值总是准确无误。</li>\n</ul>\n<p>我们感谢 React Hooks 的创造性，它也是本提案的主要灵感来源，然而上面提到的一些问题存在于其设计之中，且我们发现 Vue 的响应式模型恰好为解决这些问题提供了一种思路。</p>\n<h3 id=\"why-the-composition-api\"><a href=\"#why-the-composition-api\" class=\"headerlink\" title=\"why-the-composition-api\"></a>why-the-composition-api</h3><ul>\n<li><p><strong>Less code</strong>（更少的代码）</p>\n</li>\n<li><p><strong>Familiar functions</strong>（熟悉的功能）</p>\n</li>\n<li><p><strong>Extremely flexible</strong>（极其灵活）</p>\n</li>\n<li><p><strong>Tooling friendly</strong>（工具友好）</p>\n</li>\n<li><p><strong>Advanced syntax</strong>（高级语法）</p>\n</li>\n</ul>\n<p align=\"right\">—引自Vue Mastery</p>\n\n","site":{"data":{}},"excerpt":"<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h1><h2 id=\"动机与目的\"><a href=\"#动机与目的\" class=\"headerlink\" title=\"动机与目的\"></a>动机与目的</h2><h4 id=\"更好的逻辑复用与代码组织\"><a href=\"#更好的逻辑复用与代码组织\" class=\"headerlink\" title=\"更好的逻辑复用与代码组织\"></a>更好的逻辑复用与代码组织</h4><p> Vue 当前 API编程模型的限制：</p>\n<ol>\n<li>随着功能的增长，复杂组件的代码变得越来越难以阅读和理解。这种情况在开发人员阅读他人编写的代码时尤为常见。根本原因是 Vue 现有的 API 迫使我们通过选项组织代码，但是有的时候通过逻辑关系组织代码更有意义。</li>\n<li>目前缺少一种简洁且低成本的机制来提取和重用多个组件之间的逻辑。</li>\n</ol>\n<h4 id=\"更好的类型推导\"><a href=\"#更好的类型推导\" class=\"headerlink\" title=\"更好的类型推导\"></a>更好的类型推导</h4><p>大型项目开发者的常见需求是更好的 TypeScript 支持<br>","more":"</p>\n<h1 id=\"API\"><a href=\"#API\" class=\"headerlink\" title=\"API\"></a>API</h1><h2 id=\"setup\"><a href=\"#setup\" class=\"headerlink\" title=\"setup\"></a><code>setup</code></h2><p><strong>理解</strong></p>\n<p>setup()函数是vue3中新增的方法，可以理解为Composition Api的入口.</p>\n<p><strong>执行时机</strong></p>\n<p>在beforeCreate之前执行.</p>\n<p><strong>模板中使用</strong></p>\n<p>如果 <code>setup</code> 返回一个对象，则对象的属性将会被合并到组件模板的渲染上下文：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">template</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span>&#123;&#123; count &#125;&#125; &#123;&#123; object.foo &#125;&#125;<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">template</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span>&gt;</span><span class=\"undefined\"></span></span><br><span class=\"line\"><span class=\"undefined\">  import &#123; ref, reactive &#125; from 'vue'</span></span><br><span class=\"line\"><span class=\"undefined\"></span></span><br><span class=\"line\"><span class=\"undefined\">  export default &#123;</span></span><br><span class=\"line\"><span class=\"undefined\">    setup() &#123;</span></span><br><span class=\"line\"><span class=\"undefined\">      const count = ref(0)</span></span><br><span class=\"line\"><span class=\"undefined\">      const object = reactive(&#123; foo: 'bar' &#125;)</span></span><br><span class=\"line\"><span class=\"undefined\">      // 暴露给模板</span></span><br><span class=\"line\"><span class=\"undefined\">      return &#123;</span></span><br><span class=\"line\"><span class=\"undefined\">        count,</span></span><br><span class=\"line\"><span class=\"undefined\">        object,</span></span><br><span class=\"line\"><span class=\"undefined\">      &#125;</span></span><br><span class=\"line\"><span class=\"undefined\">    &#125;,</span></span><br><span class=\"line\"><span class=\"undefined\">  &#125;</span></span><br><span class=\"line\"><span class=\"undefined\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p><strong>接收props数据</strong></p>\n<p>然而<strong>不要</strong>解构 <code>props</code> 对象，那样会使其失去响应性：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> &#123;</span><br><span class=\"line\">  props: &#123;</span><br><span class=\"line\">    msg: &#123;</span><br><span class=\"line\">      type: <span class=\"built_in\">String</span>,</span><br><span class=\"line\">      <span class=\"keyword\">default</span>: <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;&#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  setup(props) &#123;   <span class=\"comment\">// 不要写成setup(&#123; msg &#125;)</span></span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(props.msg);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"响应式系统-API\"><a href=\"#响应式系统-API\" class=\"headerlink\" title=\"响应式系统 API\"></a>响应式系统 API</h2><h3 id=\"reactive\"><a href=\"#reactive\" class=\"headerlink\" title=\"reactive\"></a><code>reactive</code></h3><p>接收一个普通对象然后返回该普通对象的响应式代理。等同于 2.x 的 <code>Vue.observable()</code></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> obj = reactive(&#123; <span class=\"attr\">count</span>: <span class=\"number\">0</span> &#125;)</span><br></pre></td></tr></table></figure>\n<h3 id=\"ref\"><a href=\"#ref\" class=\"headerlink\" title=\"ref\"></a><code>ref</code></h3><p>接受一个参数值并返回一个响应式且可改变的 ref 对象。ref 对象拥有一个指向内部值的单一属性 <code>.value</code>。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> count = ref(<span class=\"number\">0</span>)</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(count.value) <span class=\"comment\">// 0</span></span><br><span class=\"line\"></span><br><span class=\"line\">count.value++</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(count.value) <span class=\"comment\">// 1</span></span><br></pre></td></tr></table></figure>\n<p>如果传入 ref 的是一个对象，将调用 <code>reactive</code> 方法进行深层响应转换。</p>\n<p><strong>模板中访问</strong></p>\n<p>当 ref 作为渲染上下文的属性返回（即在<code>setup()</code> 返回的对象中）并在模板中使用时，它会自动解套，无需在模板内额外书写 <code>.value</code>：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">template</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span>&#123;&#123; count &#125;&#125;<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">template</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span>&gt;</span><span class=\"undefined\"></span></span><br><span class=\"line\"><span class=\"javascript\">  <span class=\"keyword\">export</span> <span class=\"keyword\">default</span> &#123;</span></span><br><span class=\"line\"><span class=\"undefined\">    setup() &#123;</span></span><br><span class=\"line\"><span class=\"javascript\">      <span class=\"keyword\">return</span> &#123;</span></span><br><span class=\"line\"><span class=\"undefined\">        count: ref(0),</span></span><br><span class=\"line\"><span class=\"undefined\">      &#125;</span></span><br><span class=\"line\"><span class=\"undefined\">    &#125;,</span></span><br><span class=\"line\"><span class=\"undefined\">  &#125;</span></span><br><span class=\"line\"><span class=\"undefined\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"computed\"><a href=\"#computed\" class=\"headerlink\" title=\"computed\"></a><code>computed</code></h3><p>传入一个 getter 函数，返回一个默认不可手动修改的 ref 对象。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> count = ref(<span class=\"number\">1</span>)</span><br><span class=\"line\"><span class=\"keyword\">const</span> plusOne = computed(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> count.value + <span class=\"number\">1</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(plusOne.value) <span class=\"comment\">// 2</span></span><br><span class=\"line\"></span><br><span class=\"line\">plusOne.value++ <span class=\"comment\">// 错误！</span></span><br></pre></td></tr></table></figure>\n<p>或者传入一个拥有 <code>get</code> 和 <code>set</code> 函数的对象，创建一个可手动修改的计算状态。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> count = ref(<span class=\"number\">1</span>)</span><br><span class=\"line\"><span class=\"keyword\">const</span> plusOne = computed(&#123;</span><br><span class=\"line\">  get: <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> count.value + <span class=\"number\">1</span>,</span><br><span class=\"line\">  set: <span class=\"function\">(<span class=\"params\">val</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    count.value = val - <span class=\"number\">1</span></span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">plusOne.value = <span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(count.value) <span class=\"comment\">// 0</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"watchEffect\"><a href=\"#watchEffect\" class=\"headerlink\" title=\"watchEffect\"></a><code>watchEffect</code></h3><p>立即执行传入的一个函数，并响应式追踪其依赖，并在其依赖变更时重新运行该函数。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> count = ref(<span class=\"number\">0</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">watchEffect(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> <span class=\"built_in\">console</span>.log(count.value))</span><br><span class=\"line\"><span class=\"comment\">// -&gt; 打印出 0</span></span><br><span class=\"line\"></span><br><span class=\"line\">setTimeout(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">  count.value++</span><br><span class=\"line\">  <span class=\"comment\">// -&gt; 打印出 1</span></span><br><span class=\"line\">&#125;, <span class=\"number\">100</span>)</span><br></pre></td></tr></table></figure>\n<h4 id=\"停止侦听\"><a href=\"#停止侦听\" class=\"headerlink\" title=\"停止侦听\"></a>停止侦听</h4><p>当 <code>watchEffect</code> 在组件的 <code>setup()</code> 函数或生命周期钩子被调用时， 侦听器会被链接到该组件的生命周期，并在组件卸载时自动停止。</p>\n<p>在一些情况下，也可以显式调用返回值以停止侦听：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> stop = watchEffect(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">/* ... */</span></span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 之后</span></span><br><span class=\"line\">stop()</span><br></pre></td></tr></table></figure>\n<h3 id=\"watch\"><a href=\"#watch\" class=\"headerlink\" title=\"watch\"></a><code>watch</code></h3><p><code>watch</code> API 完全等效于 2.x <code>this.$watch</code> （以及 <code>watch</code> 中相应的选项）。<code>watch</code> 需要侦听特定的数据源，并在回调函数中执行副作用。默认情况是懒执行的，也就是说仅在侦听的源变更时才执行回调。</p>\n<ul>\n<li><p>对比 <code>watchEffect</code>，<code>watch</code> 允许我们：</p>\n<ul>\n<li>懒执行副作用；</li>\n<li>更明确哪些状态的改变会触发侦听器重新运行副作用；</li>\n<li>访问侦听状态变化前后的值。</li>\n</ul>\n</li>\n<li><p><strong>侦听单个数据源</strong></p>\n<p>侦听器的数据源可以是一个拥有返回值的 getter 函数，也可以是 ref：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 侦听一个 getter</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> state = reactive(&#123; <span class=\"attr\">count</span>: <span class=\"number\">0</span> &#125;)</span><br><span class=\"line\">watch(</span><br><span class=\"line\">  () =&gt; state.count,</span><br><span class=\"line\">  (count, prevCount) =&gt; &#123;</span><br><span class=\"line\">    <span class=\"comment\">/* ... */</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 直接侦听一个 ref</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> count = ref(<span class=\"number\">0</span>)</span><br><span class=\"line\">watch(count, (count, prevCount) =&gt; &#123;</span><br><span class=\"line\">  <span class=\"comment\">/* ... */</span></span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n</li>\n<li><p><strong>侦听多个数据源</strong></p>\n<p><code>watcher</code> 也可以使用数组来同时侦听多个源：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">watch([fooRef, barRef], ([foo, bar], [prevFoo, prevBar]) =&gt; &#123;</span><br><span class=\"line\">  <span class=\"comment\">/* ... */</span></span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h2 id=\"生命周期钩子函数\"><a href=\"#生命周期钩子函数\" class=\"headerlink\" title=\"生命周期钩子函数\"></a>生命周期钩子函数</h2><p>可以直接导入 <code>onXXX</code> 一族的函数来注册生命周期钩子：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; onMounted, onUpdated, onUnmounted &#125; <span class=\"keyword\">from</span> <span class=\"string\">'vue'</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> MyComponent = &#123;</span><br><span class=\"line\">  setup() &#123;</span><br><span class=\"line\">    onMounted(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">      <span class=\"built_in\">console</span>.log(<span class=\"string\">'mounted!'</span>)</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">    onUpdated(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">      <span class=\"built_in\">console</span>.log(<span class=\"string\">'updated!'</span>)</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">    onUnmounted(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">      <span class=\"built_in\">console</span>.log(<span class=\"string\">'unmounted!'</span>)</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这些生命周期钩子注册函数只能在 <code>setup()</code> 期间同步使用， 因为它们依赖于内部的全局状态来定位当前组件实例（正在调用 <code>setup()</code> 的组件实例）, 不在当前组件下调用这些函数会抛出一个错误。</p>\n<p><strong>与 2.x 版本生命周期相对应的组合式 API</strong></p>\n<ul>\n<li><del><code>beforeCreate</code></del> -&gt; 使用 <code>setup()</code></li>\n<li><del><code>created</code></del> -&gt; 使用 <code>setup()</code></li>\n<li><code>beforeMount</code> -&gt; <code>onBeforeMount</code></li>\n<li><code>mounted</code> -&gt; <code>onMounted</code></li>\n<li><code>beforeUpdate</code> -&gt; <code>onBeforeUpdate</code></li>\n<li><code>updated</code> -&gt; <code>onUpdated</code></li>\n<li><code>beforeDestroy</code> -&gt; <code>onBeforeUnmount</code></li>\n<li><code>destroyed</code> -&gt; <code>onUnmounted</code></li>\n<li><code>errorCaptured</code> -&gt; <code>onErrorCaptured</code></li>\n</ul>\n<p><strong>新增的钩子函数</strong></p>\n<p>除了和 2.x 生命周期等效项之外，组合式 API 还提供了以下调试钩子函数：</p>\n<ul>\n<li><code>onRenderTracked</code></li>\n<li><code>onRenderTriggered</code></li>\n</ul>\n<p>两个钩子函数都接收一个 <code>DebuggerEvent</code></p>\n<h2 id=\"依赖注入\"><a href=\"#依赖注入\" class=\"headerlink\" title=\"依赖注入\"></a>依赖注入</h2><p><code>provide</code> 和 <code>inject</code> 提供依赖注入，功能类似 2.x 的 <code>provide/inject</code>。两者都只能在当前活动组件实例的 <code>setup()</code> 中调用。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; provide, inject &#125; <span class=\"keyword\">from</span> <span class=\"string\">'vue'</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> ThemeSymbol = <span class=\"built_in\">Symbol</span>()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> Ancestor = &#123;</span><br><span class=\"line\">  setup() &#123;</span><br><span class=\"line\">    provide(ThemeSymbol, <span class=\"string\">'dark'</span>)</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> Descendent = &#123;</span><br><span class=\"line\">  setup() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> theme = inject(ThemeSymbol, <span class=\"string\">'light'</span> <span class=\"comment\">/* optional default value */</span>)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">      theme,</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>inject</code> 接受一个可选的的默认值作为第二个参数。如果未提供默认值，并且在 provide 上下文中未找到该属性，则 <code>inject</code> 返回 <code>undefined</code>。</p>\n<p><strong>注入的响应性</strong></p>\n<p>可以使用 <code>ref</code> 来保证 <code>provided</code> 和 <code>injected</code> 之间值的响应：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 提供者：</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> themeRef = ref(<span class=\"string\">'dark'</span>)</span><br><span class=\"line\">provide(ThemeSymbol, themeRef)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 使用者：</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> theme = inject(ThemeSymbol, ref(<span class=\"string\">'light'</span>))</span><br><span class=\"line\">watchEffect(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">`theme set to: <span class=\"subst\">$&#123;theme.value&#125;</span>`</span>)</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<p>如果注入一个响应式对象，则它的状态变化也可以被侦听。</p>\n<h2 id=\"模板-Refs\"><a href=\"#模板-Refs\" class=\"headerlink\" title=\"模板 Refs\"></a>模板 Refs</h2><p>当使用组合式 API 时，<em>reactive refs</em> 和 <em>template refs</em> 的概念已经是统一的。为了获得对模板内元素或组件实例的引用，我们可以像往常一样在 <code>setup()</code> 中声明一个 ref 并返回它：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">template</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">ref</span>=<span class=\"string\">\"rootRef\"</span>&gt;</span>&#123;&#123; b &#125;&#125;<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">template</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span>&gt;</span><span class=\"undefined\"></span></span><br><span class=\"line\"><span class=\"javascript\">  <span class=\"keyword\">import</span> &#123; ref, onMounted &#125; <span class=\"keyword\">from</span> <span class=\"string\">'vue'</span></span></span><br><span class=\"line\"><span class=\"undefined\"></span></span><br><span class=\"line\"><span class=\"javascript\">  <span class=\"keyword\">export</span> <span class=\"keyword\">default</span> &#123;</span></span><br><span class=\"line\"><span class=\"undefined\">    setup() &#123;</span></span><br><span class=\"line\"><span class=\"javascript\">      <span class=\"keyword\">const</span> rootRef = ref(<span class=\"literal\">null</span>)</span></span><br><span class=\"line\"><span class=\"undefined\">      cosnt b = ref(1)</span></span><br><span class=\"line\"><span class=\"javascript\">      onMounted(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span></span><br><span class=\"line\"><span class=\"javascript\">        <span class=\"comment\">// 在渲染完成后, 这个 div DOM 会被赋值给 root ref 对象</span></span></span><br><span class=\"line\"><span class=\"javascript\">        <span class=\"built_in\">console</span>.log(root.value) <span class=\"comment\">// &lt;div/&gt;</span></span></span><br><span class=\"line\"><span class=\"undefined\">      &#125;)</span></span><br><span class=\"line\"><span class=\"undefined\"></span></span><br><span class=\"line\"><span class=\"javascript\">      <span class=\"keyword\">return</span> &#123;</span></span><br><span class=\"line\"><span class=\"undefined\">        rootRef,</span></span><br><span class=\"line\"><span class=\"undefined\">        b</span></span><br><span class=\"line\"><span class=\"undefined\">      &#125;</span></span><br><span class=\"line\"><span class=\"undefined\">    &#125;,</span></span><br><span class=\"line\"><span class=\"undefined\">  &#125;</span></span><br><span class=\"line\"><span class=\"undefined\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>这里我们将 <code>root</code> 暴露在渲染上下文中，并通过 <code>ref=&quot;root&quot;</code> 绑定到 <code>div</code> 作为其 <code>ref</code>。 在 Virtual DOM patch 算法中，如果一个 VNode 的 <code>ref</code> 对应一个渲染上下文中的 ref，则该 VNode 对应的元素或组件实例将被分配给该 ref。 这是在 Virtual DOM 的 mount / patch 过程中执行的，因此模板 ref 仅在渲染初始化后才能访问。</p>\n<p>ref 被用在模板中时和其他 ref 一样：都是响应式的，并可以传递进组合函数（或从其中返回）。</p>\n<p><strong>配合 render 函数 / JSX 的用法</strong></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> &#123;</span><br><span class=\"line\">  setup() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> root = ref(<span class=\"literal\">null</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"params\">()</span> =&gt;</span></span><br><span class=\"line\">      h(<span class=\"string\">'div'</span>, &#123;</span><br><span class=\"line\">        ref: root,</span><br><span class=\"line\">      &#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 使用 JSX</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &lt;div ref=&#123;root&#125; /&gt;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>在 <code>v-for</code> 中使用</strong></p>\n<p>模板 ref 在 <code>v-for</code> 中使用 vue 没有做特殊处理，需要使用<strong>函数型的 ref</strong>（3.0 提供的新功能）来自定义处理方式：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">template</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">v-for</span>=<span class=\"string\">\"(item, i) in list\"</span> <span class=\"attr\">:ref</span>=<span class=\"string\">\"el =&gt; &#123; divs[i] = el &#125;\"</span>&gt;</span></span><br><span class=\"line\">    &#123;&#123; item &#125;&#125;</span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">template</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span>&gt;</span><span class=\"undefined\"></span></span><br><span class=\"line\"><span class=\"javascript\">  <span class=\"keyword\">import</span> &#123; ref, reactive, onBeforeUpdate &#125; <span class=\"keyword\">from</span> <span class=\"string\">'vue'</span></span></span><br><span class=\"line\"><span class=\"undefined\"></span></span><br><span class=\"line\"><span class=\"javascript\">  <span class=\"keyword\">export</span> <span class=\"keyword\">default</span> &#123;</span></span><br><span class=\"line\"><span class=\"undefined\">    setup() &#123;</span></span><br><span class=\"line\"><span class=\"javascript\">      <span class=\"keyword\">const</span> list = reactive([<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>])</span></span><br><span class=\"line\"><span class=\"javascript\">      <span class=\"keyword\">const</span> divs = ref([])</span></span><br><span class=\"line\"><span class=\"undefined\"></span></span><br><span class=\"line\"><span class=\"javascript\">      <span class=\"comment\">// 确保在每次变更之前重置引用</span></span></span><br><span class=\"line\"><span class=\"javascript\">      onBeforeUpdate(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span></span><br><span class=\"line\"><span class=\"undefined\">        divs.value = []</span></span><br><span class=\"line\"><span class=\"undefined\">      &#125;)</span></span><br><span class=\"line\"><span class=\"undefined\"></span></span><br><span class=\"line\"><span class=\"javascript\">      <span class=\"keyword\">return</span> &#123;</span></span><br><span class=\"line\"><span class=\"undefined\">        list,</span></span><br><span class=\"line\"><span class=\"undefined\">        divs,</span></span><br><span class=\"line\"><span class=\"undefined\">      &#125;</span></span><br><span class=\"line\"><span class=\"undefined\">    &#125;,</span></span><br><span class=\"line\"><span class=\"undefined\">  &#125;</span></span><br><span class=\"line\"><span class=\"undefined\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"响应式系统工具集\"><a href=\"#响应式系统工具集\" class=\"headerlink\" title=\"响应式系统工具集\"></a>响应式系统工具集</h2><h3 id=\"isRef\"><a href=\"#isRef\" class=\"headerlink\" title=\"isRef\"></a><code>isRef</code></h3><p>检查一个值是否为一个 ref 对象。</p>\n<h3 id=\"unref\"><a href=\"#unref\" class=\"headerlink\" title=\"unref\"></a><code>unref</code></h3><p>如果参数是一个 ref 则返回它的 <code>value</code>，否则返回参数本身。它是 <code>val = isRef(val) ? val.value : val</code> 的语法糖。</p>\n<h3 id=\"toRef\"><a href=\"#toRef\" class=\"headerlink\" title=\"toRef\"></a><code>toRef</code></h3><p><code>toRef</code> 可以用来为一个 reactive 对象的属性创建一个 ref。这个 ref 可以被传递并且能够保持响应性。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> state = reactive(&#123;</span><br><span class=\"line\">  foo: <span class=\"number\">1</span>,</span><br><span class=\"line\">  bar: <span class=\"number\">2</span>,</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> fooRef = toRef(state, <span class=\"string\">'foo'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">fooRef.value++</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(state.foo) <span class=\"comment\">// 2</span></span><br><span class=\"line\"></span><br><span class=\"line\">state.foo++</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(fooRef.value) <span class=\"comment\">// 3</span></span><br></pre></td></tr></table></figure>\n<p>当您要将一个 prop 中的属性作为 ref 传给组合逻辑函数时，<code>toRef</code> 就派上了用场：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> &#123;</span><br><span class=\"line\">  setup(props) &#123;</span><br><span class=\"line\">    useSomeFeature(toRef(props, <span class=\"string\">'foo'</span>))</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"toRefs\"><a href=\"#toRefs\" class=\"headerlink\" title=\"toRefs\"></a><code>toRefs</code></h3><p>把一个响应式对象转换成普通对象，该普通对象的每个 property 都是一个 ref ，和响应式对象 property 一一对应。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> state = reactive(&#123;</span><br><span class=\"line\">  foo: <span class=\"number\">1</span>,</span><br><span class=\"line\">  bar: <span class=\"number\">2</span>,</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> stateAsRefs = toRefs(state)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// ref 对象 与 原属性的引用是 \"链接\" 上的</span></span><br><span class=\"line\">state.foo++</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(stateAsRefs.foo.value) <span class=\"comment\">// 2</span></span><br><span class=\"line\"></span><br><span class=\"line\">stateAsRefs.foo.value++</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(state.foo) <span class=\"comment\">// 3</span></span><br></pre></td></tr></table></figure>\n<p>当想要从一个组合逻辑函数中返回响应式对象时，用 <code>toRefs</code> 是很有效的，该 API 让消费组件可以 解构 / 扩展（使用 <code>...</code> 操作符）返回的对象，并不会丢失响应性：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">useFeatureX</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> state = reactive(&#123;</span><br><span class=\"line\">    foo: <span class=\"number\">1</span>,</span><br><span class=\"line\">    bar: <span class=\"number\">2</span>,</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">  <span class=\"comment\">// 返回时将属性都转为 ref</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> toRefs(state)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> &#123;</span><br><span class=\"line\">  setup() &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 可以解构，不会丢失响应性</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> &#123; foo, bar &#125; = useFeatureX()</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">      foo,</span><br><span class=\"line\">      bar,</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"isProxy\"><a href=\"#isProxy\" class=\"headerlink\" title=\"isProxy\"></a><code>isProxy</code></h3><p>检查一个对象是否是由 <code>reactive</code> 或者 <code>readonly</code> 方法创建的代理。</p>\n<h3 id=\"isReactive\"><a href=\"#isReactive\" class=\"headerlink\" title=\"isReactive\"></a><code>isReactive</code></h3><p>检查一个对象是否是由 <code>reactive</code> 创建的响应式代理。</p>\n<h1 id=\"讨论点\"><a href=\"#讨论点\" class=\"headerlink\" title=\"讨论点\"></a>讨论点</h1><h3 id=\"代码组织\"><a href=\"#代码组织\" class=\"headerlink\" title=\"代码组织\"></a>代码组织</h3><p>通过上面的API我们已经将组件的基于选项的 API 复制成了一些被导入的函数，但是这么做的目的是什么？用选项来定义组件看上去比用一个混入所有东西的大函数更具组织性！</p>\n<p>但是实际上Composition API 实际上能够为你的代码带来<em>更</em>好组织结构，尤其是在复杂的组件中。</p>\n<h4 id=\"有组织的代码\"><a href=\"#有组织的代码\" class=\"headerlink\" title=\"有组织的代码\"></a>有组织的代码</h4><p>有组织的代码的最终目标应该是让代码更可读、更容易被理解。</p>\n<p>当要去理解一个组件时，我们更加关心的是“这个组件是要干什么” (即代码背后的意图) 而不是“这个组件用到了什么选项”。基于选项的 API 撰写出来的代码自然采用了后者的表述方式，然而对前者的表述并不好。</p>\n<h4 id=\"逻辑关注点-vs-选项类型\"><a href=\"#逻辑关注点-vs-选项类型\" class=\"headerlink\" title=\"逻辑关注点 vs. 选项类型\"></a>逻辑关注点 vs. 选项类型</h4><p>我们不妨将组件处理的“X、Y 和 Z”定义为<strong>逻辑关注点</strong>。可读性的问题基本不会存在于小的、单一用途的组件中，因为整个组件都在处理同一个逻辑关注点。然而这个问题在复杂的用例中会变得突出。以 <a href=\"https://github.com/vuejs/vue-cli/blob/a09407dd5b9f18ace7501ddb603b95e31d6d93c0/packages/@vue/cli-ui/src/components/folder/FolderExplorer.vue#L198-L404\" target=\"_blank\" rel=\"noopener\">Vue CLI UI 文件浏览器</a>为例，这个组件有非常多的逻辑关注点：</p>\n<ul>\n<li>追踪监听当前文件夹的状态并展示其中的内容</li>\n<li>处理文件夹的操作（打开、关闭、刷新…）</li>\n<li>处理新建文件夹的创建</li>\n<li>是否只展示收藏文件夹</li>\n<li>是否只展示隐藏文件夹</li>\n<li>处理当前工作目录的变化</li>\n</ul>\n<p>你能通过阅读基于选项的代码直接梳理出各个逻辑关注点么？显然是十分困难的。你会发现到与各个逻辑关注点相关的代码是分散在各处的。</p>\n<p>例如“创建新文件夹”的功能使用到了<a href=\"https://github.com/vuejs/vue-cli/blob/a09407dd5b9f18ace7501ddb603b95e31d6d93c0/packages/@vue/cli-ui/src/components/folder/FolderExplorer.vue#L221-L222\" target=\"_blank\" rel=\"noopener\">两个数据 property</a>、<a href=\"https://github.com/vuejs/vue-cli/blob/a09407dd5b9f18ace7501ddb603b95e31d6d93c0/packages/@vue/cli-ui/src/components/folder/FolderExplorer.vue#L240\" target=\"_blank\" rel=\"noopener\">一个计算属性</a>和<a href=\"https://github.com/vuejs/vue-cli/blob/a09407dd5b9f18ace7501ddb603b95e31d6d93c0/packages/@vue/cli-ui/src/components/folder/FolderExplorer.vue#L387\" target=\"_blank\" rel=\"noopener\">一个方法</a>，而方法的定义在距离数据 property 约一百多行的位置。</p>\n<p>如果我们对这些逻辑关注点进行染色，我们会注意到它们在用组件选项表示时是多么分散:</p>\n<p><img src=\"https://wos2.58cdn.com.cn/iJkFeDcBiJiJ/rocket/9407bcca-bbc4-4c27-95ab-0ba35afe20b2.jpeg\" alt=\"file explorer (before)\"></p>\n<p>正是这种碎片化使得理解和维护一个复杂的组件变得非常困难。选项的强行分离为展示背后的逻辑关注点设置了障碍。此外，在处理单个逻辑关注点时，我们必须不断地在选项代码块之间“跳转”，以找到与该关注点相关的部分。</p>\n<p>如果我们能够将相同逻辑关注点的代码并列在一起，那就再好不过了。这正是组合式 API 所能做到的，“创建新文件夹”功能可以这样写：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">useCreateFolder</span>(<span class=\"params\">openFolder</span>) </span>&#123;  <span class=\"comment\">// 组合函数建议使用 use 作为函数名的开头</span></span><br><span class=\"line\">  <span class=\"comment\">// 原来的数据 property</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> showNewFolder = ref(<span class=\"literal\">false</span>)</span><br><span class=\"line\">  <span class=\"keyword\">const</span> newFolderName = ref(<span class=\"string\">''</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 原来的计算属性</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> newFolderValid = computed(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> isValidMultiName(newFolderName.value))</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 原来的一个方法</span></span><br><span class=\"line\">  <span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">createFolder</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!newFolderValid.value) <span class=\"keyword\">return</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> result = <span class=\"keyword\">await</span> mutate(&#123;</span><br><span class=\"line\">      mutation: FOLDER_CREATE,</span><br><span class=\"line\">      variables: &#123;</span><br><span class=\"line\">        name: newFolderName.value,</span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">    openFolder(result.data.folderCreate.path)</span><br><span class=\"line\">    newFolderName.value = <span class=\"string\">''</span></span><br><span class=\"line\">    showNewFolder.value = <span class=\"literal\">false</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">    showNewFolder,</span><br><span class=\"line\">    newFolderName,</span><br><span class=\"line\">    newFolderValid,</span><br><span class=\"line\">    createFolder,</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>此模式可用于该组件的所有其它逻辑关注点，最终成为一些良好解耦的函数:</p>\n<p><img src=\"https://wos2.58cdn.com.cn/iJkFeDcBiJiJ/rocket/5b63f225-3fb3-43f0-9ba2-4737f4990a3f.jpeg\" alt=\"file explorer (comparison)\"></p>\n<p>每个逻辑关注点的代码现在都被组合进了一个组合函数。这大大减少了在处理大型组件时不断“跳转”的需要。同时组合函数也可以在编辑器中折叠起来，使组件更容易浏览:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> &#123;</span><br><span class=\"line\">  setup() &#123;</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">useCurrentFolderData</span>(<span class=\"params\">networkState</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">useFolderNavigation</span>(<span class=\"params\">&#123; networkState, currentFolderData &#125;</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">useFavoriteFolder</span>(<span class=\"params\">currentFolderData</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">useHiddenFolders</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">useCreateFolder</span>(<span class=\"params\">openFolder</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>同样的功能、两套组件定义呈现出对内在逻辑的不同的表达方式。基于选项的 API 促使我们通过 <em>选项类型</em> 组织代码，而组合式 API 让我们可以基于<em>逻辑关注点</em>组织代码。</p>\n<h3 id=\"与-React-Hooks-相比\"><a href=\"#与-React-Hooks-相比\" class=\"headerlink\" title=\"与 React Hooks 相比\"></a>与 React Hooks 相比</h3><p>基于函数的组合式 API 提供了与 React Hooks 同等级别的逻辑组合能力，但是与它还是有很大不同：组合式 API 的 <code>setup()</code> 函数只会被调用一次，这意味着使用 Vue 组合式 API 的代码会是：</p>\n<ul>\n<li>一般来说更符合惯用的 JavaScript 代码的直觉；</li>\n<li>不需要顾虑调用顺序，也可以用在条件语句中；</li>\n<li>不会在每次渲染时重复执行，以降低垃圾回收的压力；</li>\n<li>不存在内联处理函数导致子组件永远更新的问题，也不需要 <code>useCallback</code>；</li>\n<li>不存在忘记记录依赖的问题，也不需要“useEffect”和“useMemo”并传入依赖数组以捕获过时的变量。Vue 的自动依赖跟踪可以确保侦听器和计算值总是准确无误。</li>\n</ul>\n<p>我们感谢 React Hooks 的创造性，它也是本提案的主要灵感来源，然而上面提到的一些问题存在于其设计之中，且我们发现 Vue 的响应式模型恰好为解决这些问题提供了一种思路。</p>\n<h3 id=\"why-the-composition-api\"><a href=\"#why-the-composition-api\" class=\"headerlink\" title=\"why-the-composition-api\"></a>why-the-composition-api</h3><ul>\n<li><p><strong>Less code</strong>（更少的代码）</p>\n</li>\n<li><p><strong>Familiar functions</strong>（熟悉的功能）</p>\n</li>\n<li><p><strong>Extremely flexible</strong>（极其灵活）</p>\n</li>\n<li><p><strong>Tooling friendly</strong>（工具友好）</p>\n</li>\n<li><p><strong>Advanced syntax</strong>（高级语法）</p>\n</li>\n</ul>\n<p align=\"right\">—引自Vue Mastery</p>"}],"PostAsset":[],"PostCategory":[{"post_id":"cjhbjw6q20000fx9mikq9aoto","category_id":"cjhbjw6qc0004fx9m3uwjnf91","_id":"cjhbjw6qo000ffx9mi4egrd85"},{"post_id":"cjhbjw6qh0008fx9mlz73630w","category_id":"cjhbjw6qc0004fx9m3uwjnf91","_id":"cjhbjw6qp000ifx9monykk7i1"},{"post_id":"cjhbjw6qe0006fx9mihfl79m9","category_id":"cjhbjw6qc0004fx9m3uwjnf91","_id":"cjhbjw6qr000lfx9mltvqbqp0"},{"post_id":"cjhbjw6qp000hfx9mrktuj8za","category_id":"cjhbjw6qc0004fx9m3uwjnf91","_id":"cjhbjw6qt000qfx9mui9c7rpa"},{"post_id":"cjhbjw6qg0007fx9mdumumgxz","category_id":"cjhbjw6qo000efx9m5friox20","_id":"cjhbjw6qu000tfx9mdqqy7f8j"},{"post_id":"cjhbjw6qm000dfx9mkpde7hw5","category_id":"cjhbjw6qo000efx9m5friox20","_id":"cjhbjw6qw000yfx9mr87ecdpv"},{"post_id":"cjhbjw6qq000kfx9m6z8pw1ds","category_id":"cjhbjw6qo000efx9m5friox20","_id":"cjhbjw6qx0013fx9mc3bsmhs8"},{"post_id":"cjhbjw6qq000kfx9m6z8pw1ds","category_id":"cjhbjw6qv000vfx9ma61rlopx","_id":"cjhbjw6qx0014fx9mr8aavjrg"},{"post_id":"cjhbjw6qk000cfx9m5jybcra7","category_id":"cjhbjw6qo000efx9m5friox20","_id":"cjhbjw6qy0019fx9mmi12s6vd"},{"post_id":"cjhbjw6qk000cfx9m5jybcra7","category_id":"cjhbjw6qv000vfx9ma61rlopx","_id":"cjhbjw6qy001afx9majrx5wlh"},{"post_id":"cjhbjw6qs000ofx9maji0i8cm","category_id":"cjhbjw6qo000efx9m5friox20","_id":"cjhbjw6qy001cfx9mff674k42"},{"post_id":"cjhbjw6qs000ofx9maji0i8cm","category_id":"cjhbjw6qv000vfx9ma61rlopx","_id":"cjhbjw6qy001dfx9mdsxdjlpi"},{"post_id":"cjhbjw6qs000ofx9maji0i8cm","category_id":"cjhbjw6qx0017fx9matm0pqpk","_id":"cjhbjw6qz001ffx9mws3pusmr"},{"post_id":"cjwssormh0000eg9m5ntsej3k","category_id":"cjhbjw6qc0004fx9m3uwjnf91","_id":"cjwssormv0002eg9m4rgnuk3y"},{"post_id":"ck4kqm42200000w9mpunh8jr8","category_id":"cjhbjw6qc0004fx9m3uwjnf91","_id":"ck4kqm42a00020w9m8hps3kvz"},{"post_id":"ck4kqm47600050w9mxclgtwqp","category_id":"cjhbjw6qc0004fx9m3uwjnf91","_id":"ck4kqm47b00070w9m480qsgeu"},{"post_id":"ck4kqm46x00040w9m8q8qpiy8","category_id":"cjhbjw6qc0004fx9m3uwjnf91","_id":"ck4kqqnkl0001pv9mb6kx01s3"},{"post_id":"ck8r36s7d0000ah9m9anjl3qt","category_id":"cjhbjw6qc0004fx9m3uwjnf91","_id":"ck8r36s7q0002ah9m43g3ydie"},{"post_id":"cka7sznsc0000tu9mrvkhir5n","category_id":"cjhbjw6qc0004fx9m3uwjnf91","_id":"cka7sznsl0002tu9mig98zz49"},{"post_id":"cka7sznxa0004tu9mg5mm2kb4","category_id":"cjhbjw6qc0004fx9m3uwjnf91","_id":"cka7sznxp0006tu9m4rjrad7w"},{"post_id":"ckennwa7j0000na9mtwcobp0x","category_id":"cjhbjw6qc0004fx9m3uwjnf91","_id":"ckennwa7z0002na9mw285874y"}],"PostTag":[{"post_id":"cjhbjw6q20000fx9mikq9aoto","tag_id":"cjhbjw6qe0005fx9mahav63sr","_id":"cjhbjw6qk000bfx9mxfl17vu7"},{"post_id":"cjhbjw6q90002fx9m5pxe6tan","tag_id":"cjhbjw6qi000afx9moljzeo8e","_id":"cjhbjw6qq000jfx9m5yk3j4w3"},{"post_id":"cjhbjw6qe0006fx9mihfl79m9","tag_id":"cjhbjw6qo000gfx9m28jk57xy","_id":"cjhbjw6qt000pfx9mpanyx75x"},{"post_id":"cjhbjw6qg0007fx9mdumumgxz","tag_id":"cjhbjw6qs000nfx9mmfxvtxrf","_id":"cjhbjw6qv000ufx9moloehtx1"},{"post_id":"cjhbjw6qk000cfx9m5jybcra7","tag_id":"cjhbjw6qu000sfx9mgd93yp1m","_id":"cjhbjw6qv000xfx9mtn3qxiay"},{"post_id":"cjhbjw6qm000dfx9mkpde7hw5","tag_id":"cjhbjw6qv000wfx9m3cti2cy6","_id":"cjhbjw6qw0011fx9mkkzwdvt1"},{"post_id":"cjhbjw6qp000hfx9mrktuj8za","tag_id":"cjhbjw6qw0010fx9mtuco32m5","_id":"cjhbjw6qx0016fx9mi0a7nh4r"},{"post_id":"cjhbjw6qq000kfx9m6z8pw1ds","tag_id":"cjhbjw6qx0015fx9mt4k4ajo6","_id":"cjhbjw6qz001gfx9mtm6xuyb6"},{"post_id":"cjhbjw6qq000kfx9m6z8pw1ds","tag_id":"cjhbjw6qy0018fx9ms6ucap3x","_id":"cjhbjw6qz001hfx9m9qjc2iwi"},{"post_id":"cjhbjw6qq000kfx9m6z8pw1ds","tag_id":"cjhbjw6qy001bfx9mf3zk2ayl","_id":"cjhbjw6qz001ifx9mdxlxhye4"},{"post_id":"cjhbjw6qs000ofx9maji0i8cm","tag_id":"cjhbjw6qz001efx9mo13opzrq","_id":"cjhbjw6qz001jfx9m2vuetnwf"},{"post_id":"cjwssormh0000eg9m5ntsej3k","tag_id":"cjwssormq0001eg9mhp23z0ly","_id":"cjwssormw0003eg9m3qxn2r77"},{"post_id":"ck4kqm42200000w9mpunh8jr8","tag_id":"ck4kqm42800010w9m6t4px6h3","_id":"ck4kqm42c00030w9mle3ueyfn"},{"post_id":"ck4kqm46x00040w9m8q8qpiy8","tag_id":"ck4kqqnk70000pv9m64wbdbm3","_id":"ck4kqqnkq0002pv9mgenv2maw"},{"post_id":"ck4kqm47600050w9mxclgtwqp","tag_id":"ck4kwdxgj0000m09m372ny8wx","_id":"ck4kwdxgo0001m09m1iwb13bv"},{"post_id":"ck8r36s7d0000ah9m9anjl3qt","tag_id":"ck8r3bg1y0000689mww0izlpk","_id":"ck8r3bg230002689mxnku9ndo"},{"post_id":"ck8r36s7d0000ah9m9anjl3qt","tag_id":"ck8r3bg230001689mk97wikna","_id":"ck8r3bg230003689mbrnoi7g2"},{"post_id":"cka7sznsc0000tu9mrvkhir5n","tag_id":"cka7sznsh0001tu9m1xsp41tu","_id":"cka7sznsm0003tu9mvs7n08gk"},{"post_id":"cka7sznxa0004tu9mg5mm2kb4","tag_id":"cka7sznxo0005tu9mz78lqt8e","_id":"cka7sznxq0007tu9mskdoty5i"},{"post_id":"ckennwa7j0000na9mtwcobp0x","tag_id":"ckeno12400000h69m1uewm22d","_id":"ckeno124m0001h69mi0izm9rc"}],"Tag":[{"name":"git","_id":"cjhbjw6qe0005fx9mahav63sr"},{"name":"Bower","_id":"cjhbjw6qi000afx9moljzeo8e"},{"name":"indexOf","_id":"cjhbjw6qo000gfx9m28jk57xy"},{"name":"javascript深克隆","_id":"cjhbjw6qs000nfx9mmfxvtxrf"},{"name":"route","_id":"cjhbjw6qu000sfx9mgd93yp1m"},{"name":"javascript数据类型","_id":"cjhbjw6qv000wfx9m3cti2cy6"},{"name":"-markdown","_id":"cjhbjw6qw0010fx9mtuco32m5"},{"name":"vue","_id":"cjhbjw6qx0015fx9mt4k4ajo6"},{"name":"proxy","_id":"cjhbjw6qy0018fx9ms6ucap3x"},{"name":"defineproperty","_id":"cjhbjw6qy001bfx9mf3zk2ayl"},{"name":"Event Bus","_id":"cjhbjw6qz001efx9mo13opzrq"},{"name":"-排序","_id":"cjwssormq0001eg9mhp23z0ly"},{"name":"-bfc","_id":"ck4kqm42800010w9m6t4px6h3"},{"name":"算法 diff","_id":"ck4kqm47a00060w9mtgqk1d83"},{"name":"hook","_id":"ck4kqqnk70000pv9m64wbdbm3"},{"name":"算法","_id":"ck4kwdxgj0000m09m372ny8wx"},{"name":"-dfs -bfs","_id":"ck8r36s7m0001ah9mjw41mtpo"},{"name":"dfs","_id":"ck8r3bg1y0000689mww0izlpk"},{"name":"bfs","_id":"ck8r3bg230001689mk97wikna"},{"name":"-浏览器渲染","_id":"cka7sznsh0001tu9m1xsp41tu"},{"name":"-算法","_id":"cka7sznxo0005tu9mz78lqt8e"},{"name":"-vue3","_id":"ckeno12400000h69m1uewm22d"}]}}