[{"title":"Composition API归纳","date":"2020-09-01T08:00:00.000Z","path":"2020/09/01/Composition API/","text":"前言动机与目的更好的逻辑复用与代码组织 Vue 当前 API编程模型的限制： 随着功能的增长，复杂组件的代码变得越来越难以阅读和理解。这种情况在开发人员阅读他人编写的代码时尤为常见。根本原因是 Vue 现有的 API 迫使我们通过选项组织代码，但是有的时候通过逻辑关系组织代码更有意义。 目前缺少一种简洁且低成本的机制来提取和重用多个组件之间的逻辑。 更好的类型推导大型项目开发者的常见需求是更好的 TypeScript 支持 APIsetup理解 setup()函数是vue3中新增的方法，可以理解为Composition Api的入口. 执行时机 在beforeCreate之前执行. 模板中使用 如果 setup 返回一个对象，则对象的属性将会被合并到组件模板的渲染上下文： 12345678910111213141516171819&lt;template&gt; &lt;div&gt;&#123;&#123; count &#125;&#125; &#123;&#123; object.foo &#125;&#125;&lt;/div&gt;&lt;/template&gt;&lt;script&gt; import &#123; ref, reactive &#125; from 'vue' export default &#123; setup() &#123; const count = ref(0) const object = reactive(&#123; foo: 'bar' &#125;) // 暴露给模板 return &#123; count, object, &#125; &#125;, &#125;&lt;/script&gt; 接收props数据 然而不要解构 props 对象，那样会使其失去响应性： 1234567891011export default &#123; props: &#123; msg: &#123; type: String, default: () =&gt; &#123;&#125; &#125; &#125;, setup(props) &#123; // 不要写成setup(&#123; msg &#125;) console.log(props.msg); &#125;&#125; 响应式系统 APIreactive接收一个普通对象然后返回该普通对象的响应式代理。等同于 2.x 的 Vue.observable() 1const obj = reactive(&#123; count: 0 &#125;) ref接受一个参数值并返回一个响应式且可改变的 ref 对象。ref 对象拥有一个指向内部值的单一属性 .value。 12345const count = ref(0)console.log(count.value) // 0count.value++console.log(count.value) // 1 如果传入 ref 的是一个对象，将调用 reactive 方法进行深层响应转换。 模板中访问 当 ref 作为渲染上下文的属性返回（即在setup() 返回的对象中）并在模板中使用时，它会自动解套，无需在模板内额外书写 .value： 12345678910111213&lt;template&gt; &lt;div&gt;&#123;&#123; count &#125;&#125;&lt;/div&gt;&lt;/template&gt;&lt;script&gt; export default &#123; setup() &#123; return &#123; count: ref(0), &#125; &#125;, &#125;&lt;/script&gt; computed传入一个 getter 函数，返回一个默认不可手动修改的 ref 对象。 123456const count = ref(1)const plusOne = computed(() =&gt; count.value + 1)console.log(plusOne.value) // 2plusOne.value++ // 错误！ 或者传入一个拥有 get 和 set 函数的对象，创建一个可手动修改的计算状态。 12345678910const count = ref(1)const plusOne = computed(&#123; get: () =&gt; count.value + 1, set: (val) =&gt; &#123; count.value = val - 1 &#125;,&#125;)plusOne.value = 1console.log(count.value) // 0 watchEffect立即执行传入的一个函数，并响应式追踪其依赖，并在其依赖变更时重新运行该函数。 123456789const count = ref(0)watchEffect(() =&gt; console.log(count.value))// -&gt; 打印出 0setTimeout(() =&gt; &#123; count.value++ // -&gt; 打印出 1&#125;, 100) 停止侦听当 watchEffect 在组件的 setup() 函数或生命周期钩子被调用时， 侦听器会被链接到该组件的生命周期，并在组件卸载时自动停止。 在一些情况下，也可以显式调用返回值以停止侦听： 123456const stop = watchEffect(() =&gt; &#123; /* ... */&#125;)// 之后stop() watchwatch API 完全等效于 2.x this.$watch （以及 watch 中相应的选项）。watch 需要侦听特定的数据源，并在回调函数中执行副作用。默认情况是懒执行的，也就是说仅在侦听的源变更时才执行回调。 对比 watchEffect，watch 允许我们： 懒执行副作用； 更明确哪些状态的改变会触发侦听器重新运行副作用； 访问侦听状态变化前后的值。 侦听单个数据源 侦听器的数据源可以是一个拥有返回值的 getter 函数，也可以是 ref： 1234567891011121314// 侦听一个 getterconst state = reactive(&#123; count: 0 &#125;)watch( () =&gt; state.count, (count, prevCount) =&gt; &#123; /* ... */ &#125;)// 直接侦听一个 refconst count = ref(0)watch(count, (count, prevCount) =&gt; &#123; /* ... */&#125;) 侦听多个数据源 watcher 也可以使用数组来同时侦听多个源： 123watch([fooRef, barRef], ([foo, bar], [prevFoo, prevBar]) =&gt; &#123; /* ... */&#125;) 生命周期钩子函数可以直接导入 onXXX 一族的函数来注册生命周期钩子： 123456789101112131415import &#123; onMounted, onUpdated, onUnmounted &#125; from 'vue'const MyComponent = &#123; setup() &#123; onMounted(() =&gt; &#123; console.log('mounted!') &#125;) onUpdated(() =&gt; &#123; console.log('updated!') &#125;) onUnmounted(() =&gt; &#123; console.log('unmounted!') &#125;) &#125;,&#125; 这些生命周期钩子注册函数只能在 setup() 期间同步使用， 因为它们依赖于内部的全局状态来定位当前组件实例（正在调用 setup() 的组件实例）, 不在当前组件下调用这些函数会抛出一个错误。 与 2.x 版本生命周期相对应的组合式 API beforeCreate -&gt; 使用 setup() created -&gt; 使用 setup() beforeMount -&gt; onBeforeMount mounted -&gt; onMounted beforeUpdate -&gt; onBeforeUpdate updated -&gt; onUpdated beforeDestroy -&gt; onBeforeUnmount destroyed -&gt; onUnmounted errorCaptured -&gt; onErrorCaptured 新增的钩子函数 除了和 2.x 生命周期等效项之外，组合式 API 还提供了以下调试钩子函数： onRenderTracked onRenderTriggered 两个钩子函数都接收一个 DebuggerEvent 依赖注入provide 和 inject 提供依赖注入，功能类似 2.x 的 provide/inject。两者都只能在当前活动组件实例的 setup() 中调用。 123456789101112131415161718import &#123; provide, inject &#125; from 'vue'const ThemeSymbol = Symbol()const Ancestor = &#123; setup() &#123; provide(ThemeSymbol, 'dark') &#125;,&#125;const Descendent = &#123; setup() &#123; const theme = inject(ThemeSymbol, 'light' /* optional default value */) return &#123; theme, &#125; &#125;,&#125; inject 接受一个可选的的默认值作为第二个参数。如果未提供默认值，并且在 provide 上下文中未找到该属性，则 inject 返回 undefined。 注入的响应性 可以使用 ref 来保证 provided 和 injected 之间值的响应： 123456789// 提供者：const themeRef = ref('dark')provide(ThemeSymbol, themeRef)// 使用者：const theme = inject(ThemeSymbol, ref('light'))watchEffect(() =&gt; &#123; console.log(`theme set to: $&#123;theme.value&#125;`)&#125;) 如果注入一个响应式对象，则它的状态变化也可以被侦听。 模板 Refs当使用组合式 API 时，reactive refs 和 template refs 的概念已经是统一的。为了获得对模板内元素或组件实例的引用，我们可以像往常一样在 setup() 中声明一个 ref 并返回它： 1234567891011121314151617181920212223&lt;template&gt; &lt;div ref=\"rootRef\"&gt;&#123;&#123; b &#125;&#125;&lt;/div&gt;&lt;/template&gt;&lt;script&gt; import &#123; ref, onMounted &#125; from 'vue' export default &#123; setup() &#123; const rootRef = ref(null) cosnt b = ref(1) onMounted(() =&gt; &#123; // 在渲染完成后, 这个 div DOM 会被赋值给 root ref 对象 console.log(root.value) // &lt;div/&gt; &#125;) return &#123; rootRef, b &#125; &#125;, &#125;&lt;/script&gt; 这里我们将 root 暴露在渲染上下文中，并通过 ref=&quot;root&quot; 绑定到 div 作为其 ref。 在 Virtual DOM patch 算法中，如果一个 VNode 的 ref 对应一个渲染上下文中的 ref，则该 VNode 对应的元素或组件实例将被分配给该 ref。 这是在 Virtual DOM 的 mount / patch 过程中执行的，因此模板 ref 仅在渲染初始化后才能访问。 ref 被用在模板中时和其他 ref 一样：都是响应式的，并可以传递进组合函数（或从其中返回）。 配合 render 函数 / JSX 的用法 12345678910111213export default &#123; setup() &#123; const root = ref(null) return () =&gt; h('div', &#123; ref: root, &#125;) // 使用 JSX return () =&gt; &lt;div ref=&#123;root&#125; /&gt; &#125;,&#125; 在 v-for 中使用 模板 ref 在 v-for 中使用 vue 没有做特殊处理，需要使用函数型的 ref（3.0 提供的新功能）来自定义处理方式： 1234567891011121314151617181920212223242526&lt;template&gt; &lt;div v-for=\"(item, i) in list\" :ref=\"el =&gt; &#123; divs[i] = el &#125;\"&gt; &#123;&#123; item &#125;&#125; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; import &#123; ref, reactive, onBeforeUpdate &#125; from 'vue' export default &#123; setup() &#123; const list = reactive([1, 2, 3]) const divs = ref([]) // 确保在每次变更之前重置引用 onBeforeUpdate(() =&gt; &#123; divs.value = [] &#125;) return &#123; list, divs, &#125; &#125;, &#125;&lt;/script&gt; 响应式系统工具集isRef检查一个值是否为一个 ref 对象。 unref如果参数是一个 ref 则返回它的 value，否则返回参数本身。它是 val = isRef(val) ? val.value : val 的语法糖。 toReftoRef 可以用来为一个 reactive 对象的属性创建一个 ref。这个 ref 可以被传递并且能够保持响应性。 123456789101112const state = reactive(&#123; foo: 1, bar: 2,&#125;)const fooRef = toRef(state, 'foo')fooRef.value++console.log(state.foo) // 2state.foo++console.log(fooRef.value) // 3 当您要将一个 prop 中的属性作为 ref 传给组合逻辑函数时，toRef 就派上了用场： 12345export default &#123; setup(props) &#123; useSomeFeature(toRef(props, 'foo')) &#125;,&#125; toRefs把一个响应式对象转换成普通对象，该普通对象的每个 property 都是一个 ref ，和响应式对象 property 一一对应。 12345678910111213const state = reactive(&#123; foo: 1, bar: 2,&#125;)const stateAsRefs = toRefs(state)// ref 对象 与 原属性的引用是 \"链接\" 上的state.foo++console.log(stateAsRefs.foo.value) // 2stateAsRefs.foo.value++console.log(state.foo) // 3 当想要从一个组合逻辑函数中返回响应式对象时，用 toRefs 是很有效的，该 API 让消费组件可以 解构 / 扩展（使用 ... 操作符）返回的对象，并不会丢失响应性： 1234567891011121314151617181920function useFeatureX() &#123; const state = reactive(&#123; foo: 1, bar: 2, &#125;) // 返回时将属性都转为 ref return toRefs(state)&#125;export default &#123; setup() &#123; // 可以解构，不会丢失响应性 const &#123; foo, bar &#125; = useFeatureX() return &#123; foo, bar, &#125; &#125;,&#125; isProxy检查一个对象是否是由 reactive 或者 readonly 方法创建的代理。 isReactive检查一个对象是否是由 reactive 创建的响应式代理。 讨论点代码组织通过上面的API我们已经将组件的基于选项的 API 复制成了一些被导入的函数，但是这么做的目的是什么？用选项来定义组件看上去比用一个混入所有东西的大函数更具组织性！ 但是实际上Composition API 实际上能够为你的代码带来更好组织结构，尤其是在复杂的组件中。 有组织的代码有组织的代码的最终目标应该是让代码更可读、更容易被理解。 当要去理解一个组件时，我们更加关心的是“这个组件是要干什么” (即代码背后的意图) 而不是“这个组件用到了什么选项”。基于选项的 API 撰写出来的代码自然采用了后者的表述方式，然而对前者的表述并不好。 逻辑关注点 vs. 选项类型我们不妨将组件处理的“X、Y 和 Z”定义为逻辑关注点。可读性的问题基本不会存在于小的、单一用途的组件中，因为整个组件都在处理同一个逻辑关注点。然而这个问题在复杂的用例中会变得突出。以 Vue CLI UI 文件浏览器为例，这个组件有非常多的逻辑关注点： 追踪监听当前文件夹的状态并展示其中的内容 处理文件夹的操作（打开、关闭、刷新…） 处理新建文件夹的创建 是否只展示收藏文件夹 是否只展示隐藏文件夹 处理当前工作目录的变化 你能通过阅读基于选项的代码直接梳理出各个逻辑关注点么？显然是十分困难的。你会发现到与各个逻辑关注点相关的代码是分散在各处的。 例如“创建新文件夹”的功能使用到了两个数据 property、一个计算属性和一个方法，而方法的定义在距离数据 property 约一百多行的位置。 如果我们对这些逻辑关注点进行染色，我们会注意到它们在用组件选项表示时是多么分散: 正是这种碎片化使得理解和维护一个复杂的组件变得非常困难。选项的强行分离为展示背后的逻辑关注点设置了障碍。此外，在处理单个逻辑关注点时，我们必须不断地在选项代码块之间“跳转”，以找到与该关注点相关的部分。 如果我们能够将相同逻辑关注点的代码并列在一起，那就再好不过了。这正是组合式 API 所能做到的，“创建新文件夹”功能可以这样写： 1234567891011121314151617181920212223242526272829function useCreateFolder(openFolder) &#123; // 组合函数建议使用 use 作为函数名的开头 // 原来的数据 property const showNewFolder = ref(false) const newFolderName = ref('') // 原来的计算属性 const newFolderValid = computed(() =&gt; isValidMultiName(newFolderName.value)) // 原来的一个方法 async function createFolder() &#123; if (!newFolderValid.value) return const result = await mutate(&#123; mutation: FOLDER_CREATE, variables: &#123; name: newFolderName.value, &#125;, &#125;) openFolder(result.data.folderCreate.path) newFolderName.value = '' showNewFolder.value = false &#125; return &#123; showNewFolder, newFolderName, newFolderValid, createFolder, &#125;&#125; 此模式可用于该组件的所有其它逻辑关注点，最终成为一些良好解耦的函数: 每个逻辑关注点的代码现在都被组合进了一个组合函数。这大大减少了在处理大型组件时不断“跳转”的需要。同时组合函数也可以在编辑器中折叠起来，使组件更容易浏览: 12345678910111213141516171819202122232425export default &#123; setup() &#123; // ... &#125;,&#125;function useCurrentFolderData(networkState) &#123; // ...&#125;function useFolderNavigation(&#123; networkState, currentFolderData &#125;) &#123; // ...&#125;function useFavoriteFolder(currentFolderData) &#123; // ...&#125;function useHiddenFolders() &#123; // ...&#125;function useCreateFolder(openFolder) &#123; // ...&#125; 同样的功能、两套组件定义呈现出对内在逻辑的不同的表达方式。基于选项的 API 促使我们通过 选项类型 组织代码，而组合式 API 让我们可以基于逻辑关注点组织代码。 与 React Hooks 相比基于函数的组合式 API 提供了与 React Hooks 同等级别的逻辑组合能力，但是与它还是有很大不同：组合式 API 的 setup() 函数只会被调用一次，这意味着使用 Vue 组合式 API 的代码会是： 一般来说更符合惯用的 JavaScript 代码的直觉； 不需要顾虑调用顺序，也可以用在条件语句中； 不会在每次渲染时重复执行，以降低垃圾回收的压力； 不存在内联处理函数导致子组件永远更新的问题，也不需要 useCallback； 不存在忘记记录依赖的问题，也不需要“useEffect”和“useMemo”并传入依赖数组以捕获过时的变量。Vue 的自动依赖跟踪可以确保侦听器和计算值总是准确无误。 我们感谢 React Hooks 的创造性，它也是本提案的主要灵感来源，然而上面提到的一些问题存在于其设计之中，且我们发现 Vue 的响应式模型恰好为解决这些问题提供了一种思路。 why-the-composition-api Less code（更少的代码） Familiar functions（熟悉的功能） Extremely flexible（极其灵活） Tooling friendly（工具友好） Advanced syntax（高级语法） —引自Vue Mastery","tags":[{"name":"-vue3","slug":"vue3","permalink":"http://www.leqikeji.com/blog/tags/vue3/"}]},{"title":"JavaScript 中的位运算和权限设计","date":"2020-04-12T07:56:40.000Z","path":"2020/04/12/JavaScript 中的位运算和权限设计/","text":"1. 内容概要本文主要讨论以下两个问题： JavaScript 的位运算：先简单回顾下位运算，平时用的少，相信不少人和我一样忘的差不多了 权限设计：根据位运算的特点，设计一个权限系统（添加、删除、判断等） 2. JavaScript 位运算 2.1. Number在讲位运算之前，首先简单看下 JavaScript 中的 Number，下文需要用到。 在 JavaScript 里，数字均为基于 IEEE 754 标准的双精度 64 位的浮点数，引用维基百科的图片，它的结构长这样： sign bit（符号）: 用来表示正负号 exponent（指数）: 用来表示次方数 mantissa（尾数）: 用来表示精确度 也就是说一个数字的范围只能在 -(2^53 -1) 至 2^53 -1 之间。 既然讲到这里，就多说一句：0.1 + 0.2 算不准的原因也在于此。浮点数用二进制表达时是无穷的，且最多 53 位，必须截断，进而产生误差。最简单的解决办法就是放大一定倍数变成整数，计算完成后再缩小。不过更稳妥的办法是使用下文将会提到的 math.js 等工具库。 此外还有四种数字进制： 123456789101112131415161718// 十进制1234567890// 二进制：前缀 0b，0B0b10000000000000000000000000000000 // 21474836480b01111111100000000000000000000000 // 21390950400B00000000011111111111111111111111 // 8388607// 八进制：前缀 0o，0O（以前支持前缀 0）0o755 // 4930o644 // 420// 十六进制：前缀 0x，0X0xFFFFFFFFFFFFFFFFF // 2951479051793528300000x123456789ABCDEF // 819855292164869000XA // 10复制代码 好了，Number 就说这么多，接下来看 JavaScript 中的位运算。 2.2. 位运算按位操作符将其操作数当作 32 位的比特序列（由 0 和 1 组成）操作，返回值依然是标准的 JavaScript 数值。JavaScript 中的按位操作符有： 运算符 用法 描述 按位与（AND） a &amp; b 对于每一个比特位，只有两个操作数相应的比特位都是 1 时，结果才为 1，否则为 0。 按位或（OR） a ｜ b 对于每一个比特位，当两个操作数相应的比特位至少有一个 1 时，结果为 1，否则为 0。 按位异或（XOR） a ^ b 对于每一个比特位，当两个操作数相应的比特位有且只有一个 1 时，结果为 1，否则为 0。 按位非（NOT） ~a 反转操作数的比特位，即 0 变成 1，1 变成 0。 左移（Left shift） a &lt;&lt; b 将 a 的二进制形式向左移 b (&lt; 32) 比特位，右边用 0 填充。 有符号右移 a &gt;&gt; b 将 a 的二进制表示向右移 b (&lt; 32) 位，丢弃被移出的位。 无符号右移 a &gt;&gt;&gt; b 将 a 的二进制表示向右移 b (&lt; 32) 位，丢弃被移出的位，并使用 0 在左侧填充。 下面举几个例子，主要看下 AND 和 OR： 1234567891011121314151617181920# 例子1 A = 10001001 B = 10010000A | B = 10011001# 例子2 A = 10001001 C = 10001000A | C = 10001001复制代码# 例子1 A = 10001001 B = 10010000A &amp; B = 10000000# 例子2 A = 10001001 C = 10001000A &amp; C = 10001000复制代码 3. 位运算在权限系统中的使用传统的权限系统里，存在很多关联关系，如用户和权限的关联，用户和角色的关联。系统越大，关联关系越多，越难以维护。而引入位运算，可以巧妙的解决该问题。 在讲“位运算在权限系统中的使用”之前，我们先假定两个前提，下文所有的讨论都是基于这两个前提的： 每种权限码都是唯一的（这是显然的） 所有权限码的二进制数形式，有且只有一位值为 1，其余全部为 0（2^n） 如果用户权限和权限码，全部使用二级制数字表示，再结合上面 AND 和 OR 的例子，分析位运算的特点，不难发现： | 可以用来赋予权限 &amp; 可以用来校验权限 为了讲的更明白，这里用 Linux 中的实例分析下，Linux 的文件权限分为读、写和执行，有字母和数字等多种表现形式： 权限 字母表示 数字表示 二进制 读 r 4 0b100 写 w 2 0b010 执行 x 1 0b001 可以看到，权限用 1、2、4（也就是 2^n）表示，转换为二进制后，都是只有一位是 1，其余为 0。我们通过几个例子看下，如何利用二进制的特点执行权限的添加，校验和删除。 3.1. 添加权限123456789101112131415161718let r = 0b100let w = 0b010let x = 0b001// 给用户赋全部权限（使用前面讲的 | 操作）let user = r | w | xconsole.log(user)// 7console.log(user.toString(2))// 111// r = 0b100// w = 0b010// r = 0b001// r|w|x = 0b111复制代码 可以看到，执行 r | w | x 后，user 的三位都是 1，表明拥有了全部三个权限。 Linux 下出现权限问题时，最粗暴的解决方案就是 chmod 777 xxx，这里的 7 就代表了：可读，可写，可执行。而三个 7 分别代表：文件所有者，文件所有者所在组，所有其他用户。 3.2. 校验权限刚才演示了权限的添加，下面演示权限校验： 12345678910111213let r = 0b100let w = 0b010let x = 0b001// 给用户赋 r w 两个权限let user = r | w// user = 6// user = 0b110 (二进制)console.log((user &amp; r) === r) // true 有 r 权限console.log((user &amp; w) === w) // true 有 w 权限console.log((user &amp; x) === x) // false 没有 x 权限复制代码 如前所料，通过 用户权限 &amp; 权限 code === 权限 code 就可以判断出用户是否拥有该权限。 3.3. 删除权限我们讲了用 | 赋予权限，使用 &amp; 判断权限，那么删除权限呢？删除权限的本质其实是将指定位置上的 1 重置为 0。上个例子里用户权限是 0b110，拥有读和写两个权限，现在想删除读的权限，本质上就是将第三位的 1 重置为 0，变为 0b010： 12345678910let r = 0b100let w = 0b010let x = 0b001let user = 0b010;console.log((user &amp; r) === r) // false 没有 r 权限console.log((user &amp; w) === w) // true 有 w 权限console.log((user &amp; x) === x) // false 没有 x 权限复制代码 那么具体怎么操作呢？其实有两种方案，最简单的就是异或 ^，按照上文的介绍“当两个操作数相应的比特位有且只有一个 1 时，结果为 1，否则为 0”，所以异或其实是 toggle 操作，无则增，有则减： 1234567891011121314151617181920212223let r = 0b100let w = 0b010let x = 0b001let user = 0b110 // 有 r w 两个权限// 执行异或操作，删除 r 权限user = user ^ rconsole.log((user &amp; r) === r) // false 没有 r 权限console.log((user &amp; w) === w) // true 有 w 权限console.log((user &amp; x) === x) // false 没有 x 权限console.log(user.toString(2)) // 现在 user 是 0b010// 再执行一次异或操作user = user ^ rconsole.log((user &amp; r) === r) // true 有 r 权限console.log((user &amp; w) === w) // true 有 w 权限console.log((user &amp; x) === x) // false 没有 x 权限console.log(user.toString(2)) // 现在 user 又变回 0b110复制代码 那么如果单纯的想删除权限（而不是无则增，有则减）怎么办呢？答案是执行 &amp;(~code)，先取反，再执行与操作： 1234567891011121314151617181920212223let r = 0b100let w = 0b010let x = 0b001let user = 0b110 // 有 r w 两个权限// 删除 r 权限user = user &amp; (~r)console.log((user &amp; r) === r) // false 没有 r 权限console.log((user &amp; w) === w) // true 有 w 权限console.log((user &amp; x) === x) // false 没有 x 权限console.log(user.toString(2)) // 现在 user 是 0b010// 再执行一次user = user &amp; (~r)console.log((user &amp; r) === r) // false 没有 r 权限console.log((user &amp; w) === w) // true 有 w 权限console.log((user &amp; x) === x) // false 没有 x 权限console.log(user.toString(2)) // 现在 user 还是 0b010，并不会新增复制代码 4. 局限性和解决办法前面我们回顾了 JavaScript 中的 Number 和位运算，并且了解了基于位运算的权限系统原理和 Linux 文件系统权限的实例。 上述的所有都有前提条件：1、每种权限码都是唯一的；2、每个权限码的二进制数形式，有且只有一位值为 1（2^n）。也就是说，权限码只能是 1, 2, 4, 8,…,1024,…而上文提到，一个数字的范围只能在 -(2^53 -1) 和 2^53 -1 之间，JavaScript 的按位操作符又是将其操作数当作 32 位比特序列的。那么同一个应用下可用的权限数就非常有限了。这也是该方案的局限性。 为了突破这个限制，这里提出一个叫“权限空间”的概念，既然权限数有限，那么不妨就多开辟几个空间来存放。 基于权限空间，我们定义两个格式： 权限 code，字符串，形如 index,pos。其中 pos 表示 32 位二进制数中 1 的位置（其余全是 0）； index 表示权限空间，用于突破 JavaScript 数字位数的限制，是从 0 开始的正整数，每个权限code都要归属于一个权限空间。index 和 pos 使用英文逗号隔开。 用户权限，字符串，形如 1,16,16。英文逗号分隔每一个权限空间的权限值。例如 1,16,16 的意思就是，权限空间 0 的权限值是 1，权限空间 1 的权限值是 16，权限空间 2 的权限是 16。 干说可能不好懂，直接上代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142// 用户的权限 codelet userCode = \"\"// 假设系统里有这些权限// 纯模拟，正常情况下是按顺序的，如 0,0 0,1 0,2 ...，尽可能占满一个权限空间，再使用下一个const permissions = &#123; SYS_SETTING: &#123; value: \"0,0\", // index = 0, pos = 0 info: \"系统权限\" &#125;, DATA_ADMIN: &#123; value: \"0,8\", info: \"数据库权限\" &#125;, USER_ADD: &#123; value: \"0,22\", info: \"用户新增权限\" &#125;, USER_EDIT: &#123; value: \"0,30\", info: \"用户编辑权限\" &#125;, USER_VIEW: &#123; value: \"1,2\", // index = 1, pos = 2 info: \"用户查看权限\" &#125;, USER_DELETE: &#123; value: \"1,17\", info: \"用户删除权限\" &#125;, POST_ADD: &#123; value: \"1,28\", info: \"文章新增权限\" &#125;, POST_EDIT: &#123; value: \"2,4\", info: \"文章编辑权限\" &#125;, POST_VIEW: &#123; value: \"2,19\", info: \"文章查看权限\" &#125;, POST_DELETE: &#123; value: \"2,26\", info: \"文章删除权限\" &#125;&#125;// 添加权限const addPermission = (userCode, permission) =&gt; &#123; const userPermission = userCode ? userCode.split(\",\") : [] const [index, pos] = permission.value.split(\",\") userPermission[index] = (userPermission[index] || 0) | Math.pow(2, pos) return userPermission.join(\",\")&#125;// 删除权限const delPermission = (userCode, permission) =&gt; &#123; const userPermission = userCode ? userCode.split(\",\") : [] const [index, pos] = permission.value.split(\",\") userPermission[index] = (userPermission[index] || 0) &amp; (~Math.pow(2, pos)) return userPermission.join(\",\")&#125;// 判断是否有权限const hasPermission = (userCode, permission) =&gt; &#123; const userPermission = userCode ? userCode.split(\",\") : [] const [index, pos] = permission.value.split(\",\") const permissionValue = Math.pow(2, pos) return (userPermission[index] &amp; permissionValue) === permissionValue&#125;// 列出用户拥有的全部权限const listPermission = userCode =&gt; &#123; const results = [] if (!userCode) &#123; return results &#125; Object.values(permissions).forEach(permission =&gt; &#123; if (hasPermission(userCode, permission)) &#123; results.push(permission.info) &#125; &#125;) return results&#125;const log = () =&gt; &#123; console.log(`userCode: $&#123;JSON.stringify(userCode, null, \" \")&#125;`) console.log(`权限列表: $&#123;listPermission(userCode).join(\"; \")&#125;`) console.log(\"\")&#125;userCode = addPermission(userCode, permissions.SYS_SETTING)log()// userCode: \"1\"// 权限列表: 系统权限userCode = addPermission(userCode, permissions.POST_EDIT)log()// userCode: \"1,,16\"// 权限列表: 系统权限; 文章编辑权限userCode = addPermission(userCode, permissions.USER_EDIT)log()// userCode: \"1073741825,,16\"// 权限列表: 系统权限; 用户编辑权限; 文章编辑权限userCode = addPermission(userCode, permissions.USER_DELETE)log()// userCode: \"1073741825,131072,16\"// 权限列表: 系统权限; 用户编辑权限; 用户删除权限; 文章编辑权限userCode = delPermission(userCode, permissions.USER_EDIT)log()// userCode: \"1,131072,16\"// 权限列表: 系统权限; 用户删除权限; 文章编辑权限userCode = delPermission(userCode, permissions.USER_EDIT)log()// userCode: \"1,131072,16\"// 权限列表: 系统权限; 用户删除权限; 文章编辑权限userCode = delPermission(userCode, permissions.USER_DELETE)userCode = delPermission(userCode, permissions.SYS_SETTING)userCode = delPermission(userCode, permissions.POST_EDIT)log()// userCode: \"0,0,0\"// 权限列表: userCode = addPermission(userCode, permissions.SYS_SETTING)log()// userCode: \"1,0,0\"// 权限列表: 系统权限复制代码 除了通过引入权限空间的概念突破二进制运算的位数限制，还可以使用 math.js 的 bignumber，直接运算超过 32 位的二进制数，具体可以看它的文档，这里就不细说了。 5. 适用场景和问题如果按照当前使用最广泛的 RBAC 模型设计权限系统，那么一般会有这么几个实体：应用，权限，角色，用户。用户权限可以直接来自权限，也可以来自角色： 一个应用下有多个权限 权限和角色是多对多的关系 用户和角色是多对多的关系 用户和权限是多对多的关系 在此种模型下，一般会有用户与权限，用户与角色，角色与权限的对应关系表。想象一个商城后台权限管理系统，可能会有上万，甚至十几万店铺（应用），每个店铺可能会有数十个用户，角色，权限。随着业务的不断发展，刚才提到的那三张对应关系表会越来越大，越来越难以维护。 而进制转换的方法则可以省略对应关系表，减少查询，节省空间。当然，省略掉对应关系不是没有坏处的，例如下面几个问题： 如何高效的查找我的权限？ 如何高效的查找拥有某权限的所有用户？ 如何控制权限的有效期？ 所以进制转换的方案比较适合刚才提到的应用极其多，而每个应用中用户，权限，角色数量较少的场景。 6. 其他方案除了二进制方案，当然还有其他方案可以达到类似的效果，例如直接使用一个1和0组成的字符串，权限点对应index，1表示拥有权限，0表示没有权限。举个例子：添加 0、删除 1、编辑 2，用户A拥有添加和编辑的权限，则 userCode 为 101；用户B拥有全部权限，userCode 为 111。这种方案比二进制转换简单，但是浪费空间。 还有利用质数的方案，权限点全部为质数，用户权限为他所拥有的全部权限点的乘积。如：权限点是 2、3、5、7、11，用户权限是 5 7 11 = 385。这种方案麻烦的地方在于获取质数（新增权限点）和质因数分解（判断权限），权限点特别多的时候就快成 RSA 了，如果只有增删改查个别几个权限，倒是可以考虑。 7. 参考 MDN：JavaScript 数字和日期 双精度浮点类型 MDN：按位操作符 【小知识大道理】被忽视的位运算 为什么不要在 JavaScript 中使用位操作符？ 角色权限设计的100种解法 权限系统与RBAC模型概述 权限设计及算法 基于角色的访问控制","tags":[{"name":"-算法","slug":"算法","permalink":"http://www.leqikeji.com/blog/tags/算法/"}]},{"title":"DFS和BFS小结","date":"2020-04-08T08:40:32.000Z","path":"2020/04/08/DFS和BFS/","text":"DFS（Deep First Search）深度优先遍历。 BFS（Breath First Search）广度优先遍历。 1.DFS（深度优先遍历）深度优先遍历的步骤分为 1.递归下去 2.回溯上来。顾名思义，深度优先，则是以深度为准则，先一条路走到底，直到达到目标。 否则既没有达到目标又无路可走了，那么则退回到上一步的状态，走其他路。这便是回溯上来。 DFS模板1234567891011121314151617181920function dfs() &#123; if(到达终点状态) &#123; //... 根据题意添加 return; &#125; if(越界或者是不合法状态) return; if(特殊状态)//剪枝 return ; for(扩展方式) &#123; if(扩展方式所达到状态合法) &#123; 修改操作;//根据题意来添加 标记； dfs（）； (还原标记)； //是否还原标记根据题意 //如果加上（还原标记）就是 回溯法 &#125; &#125; &#125; 2.BFS（广度优先遍历）广度优先遍历较之深度优先遍历之不同在于，深度优先遍历旨在不管有多少条岔路，先一条路走到底，不成功就返回上一个路口然后就选择下一条岔路，而广度优先遍历旨在面临一个路口时，把所有的岔路口都记下来，然后选择其中一个进入，然后将它的分路情况记录下来，然后再返回来进入另外一个岔路，并重复这样的操作 BFS模板12345678910function BFS(s) &#123; let queue = [s]; while(queue.length) &#123; const top = queue.shift() //取出队首元素top并出队; //... //访问队首元素top操作; //将top的下一层结点中未曾入队的结点全部入队，并设置为已入队; &#125;&#125; 3. 案例3.1机器人的运动范围地上有一个m行n列的方格，从坐标 [0,0] 到坐标 [m-1,n-1] 。一个机器人从坐标 [0, 0] 的格子开始移动，它每次可以向左、右、上、下移动一格（不能移动到方格外），也不能进入行坐标和列坐标的数位之和大于k的格子。例如，当k为18时，机器人能够进入方格 [35, 37] ，因为3+5+3+7=18。但它不能进入方格 [35, 38]，因为3+5+3+8=19。请问该机器人能够到达多少个格子？ 示例 1： 输入：m = 2, n = 3, k = 1输出：3 示例 2： 输入：m = 3, n = 1, k = 0输出：1 提示： 1 &lt;= n,m &lt;= 1000 &lt;= k &lt;= 20 思路：如果我们直接遍历检查所有的点，取出满足数位相加之和的条件，机器人不一定可以达到。例如当 m=38，n=15，k=9 时，由于只能向合法坐标移动 1 格，从(18,0)并不能到达(20, 0)，即使(20, 0)满足数位之和的条件。 所以我们应当采用DFS或者BFS的思想来处理 解法1 DFS123456789101112131415161718192021222324252627282930313233343536const bitSum = (num) =&gt; String(num).split('').reduce((_t, _n)=&gt; (Number(_t) + Number(_n)), 0)var movingCount = function(m, n, k) &#123; let res = 0; const directions = [ [-1, 0], [1, 0], [0, -1], [0, 1] ]; const visited = &#123;&#125;; dfs(0, 0); return res; function dfs(x, y) &#123; visited[`$&#123;x&#125;-$&#123;y&#125;`] = true; if (bitSum(x) + bitSum(y) &gt; k) &#123; return; &#125; ++res; for (const direction of directions) &#123; const newx = direction[0] + x; const newy = direction[1] + y; if ( !visited[`$&#123;newx&#125;-$&#123;newy&#125;`] &amp;&amp; newx &gt;= 0 &amp;&amp; newy &gt;= 0 &amp;&amp; newx &lt; m &amp;&amp; newy &lt; n ) &#123; dfs(newx, newy); &#125; &#125; &#125;&#125;; 解法2 BFS12345678910111213141516171819202122232425262728293031323334353637var movingCount = function(m, n, k) &#123; let res = 0; const directions = [ [1, 0], [0, 1] ]; const queue = [[0, 0]]; const visited = &#123; \"0-0\": true &#125;; while (queue.length) &#123; const [x, y] = queue.shift(); if (bitSum(x) + bitSum(y) &gt; k) &#123; continue; &#125; ++res; for (const direction of directions) &#123; const newx = direction[0] + x; const newy = direction[1] + y; if ( !visited[`$&#123;newx&#125;-$&#123;newy&#125;`] &amp;&amp; newx &gt;= 0 &amp;&amp; newy &gt;= 0 &amp;&amp; newx &lt; m &amp;&amp; newy &lt; n ) &#123; queue.push([newx, newy]); visited[`$&#123;newx&#125;-$&#123;newy&#125;`] = true; &#125; &#125; &#125; return res;&#125;; 4.总结对于这两个遍历方法，其实我们是可以轻松的看出来，他们有许多差异与许多相同点的。 1.数据结构上的运用 DFS用递归的形式，用到了栈结构，先进后出。 BFS选取状态用队列的形式，先进先出。 2.复杂度 DFS的复杂度与BFS的复杂度大体一致，不同之处在于遍历的方式与对于问题的解决出发点不同，DFS适合目标明确，而BFS适合大范围的寻找。 3.思想 思想上来说这两种方法都是穷竭列举所有的情况。","tags":[{"name":"dfs","slug":"dfs","permalink":"http://www.leqikeji.com/blog/tags/dfs/"},{"name":"bfs","slug":"bfs","permalink":"http://www.leqikeji.com/blog/tags/bfs/"}]},{"title":"回流和重绘","date":"2020-03-11T10:56:40.000Z","path":"2020/03/11/回流和重绘/","text":"你真的了解回流和重绘吗回流和重绘可以说是每一个web开发者都经常听到的两个词语，可是可能有很多人不是很清楚这两步具体做了什么事情。 浏览器的渲染过程本文先从浏览器的渲染过程来从头到尾的讲解一下回流重绘，如果大家想直接看如何减少回流和重绘，优化性能，可以跳到后面。 从上面这个图上，我们可以看到，浏览器渲染过程如下： 解析HTML，生成DOM树，解析CSS，生成CSSOM树 将DOM树和CSSOM树结合，生成渲染树(Render Tree) Layout(回流):根据生成的渲染树，进行回流(Layout)，得到节点的几何信息（位置，大小） Painting(重绘):根据渲染树以及回流得到的几何信息，得到节点的绝对像素 Display:将像素发送给GPU，展示在页面上。（这一步其实还有很多内容，比如会在GPU将多个合成层合并为同一个层，并展示在页面中。而css3硬件加速的原理则是新建合成层，这里我们不展开，之后有机会会写一篇博客） 渲染过程看起来很简单，让我们来具体了解下每一步具体做了什么。 生成渲染树为了构建渲染树，浏览器主要完成了以下工作： 从DOM树的根节点开始遍历每个可见节点。 对于每个可见的节点，找到CSSOM树中对应的规则，并应用它们。 根据每个可见节点以及其对应的样式，组合生成渲染树。 第一步中，既然说到了要遍历可见的节点，那么我们得先知道，什么节点是不可见的。不可见的节点包括： 一些不会渲染输出的节点，比如script、meta、link等。 一些通过css进行隐藏的节点。比如display:none。注意，利用visibility和opacity隐藏的节点，还是会显示在渲染树上的。只有display:none的节点才不会显示在渲染树上。 从上面的例子来讲，我们可以看到span标签的样式有一个display:none，因此，它最终并没有在渲染树上。 注意：渲染树只包含可见的节点 回流前面我们通过构造渲染树，我们将可见DOM节点以及它对应的样式结合起来，可是我们还需要计算它们在设备视口(viewport)内的确切位置和大小，这个计算的阶段就是回流。 为了弄清每个对象在网站上的确切大小和位置，浏览器从渲染树的根节点开始遍历，我们可以以下面这个实例来表示： 123456789101112&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,initial-scale=1&quot;&gt; &lt;title&gt;Critial Path: Hello world!&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div style=&quot;width: 50%&quot;&gt; &lt;div style=&quot;width: 50%&quot;&gt;Hello world!&lt;/div&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 我们可以看到，第一个div将节点的显示尺寸设置为视口宽度的50%，第二个div将其尺寸设置为父节点的50%。而在回流这个阶段，我们就需要根据视口具体的宽度，将其转为实际的像素值。（如下图） 重绘最终，我们通过构造渲染树和回流阶段，我们知道了哪些节点是可见的，以及可见节点的样式和具体的几何信息(位置、大小)，那么我们就可以将渲染树的每个节点都转换为屏幕上的实际像素，这个阶段就叫做重绘节点。 既然知道了浏览器的渲染过程后，我们就来探讨下，何时会发生回流重绘。 何时发生回流重绘我们前面知道了，回流这一阶段主要是计算节点的位置和几何信息，那么当页面布局和几何信息发生变化的时候，就需要回流。比如以下情况： 添加或删除可见的DOM元素 元素的位置发生变化 元素的尺寸发生变化（包括外边距、内边框、边框大小、高度和宽度等） 内容发生变化，比如文本变化或图片被另一个不同尺寸的图片所替代。 页面一开始渲染的时候（这肯定避免不了） 浏览器的窗口尺寸变化（因为回流是根据视口的大小来计算元素的位置和大小的） 注意：回流一定会触发重绘，而重绘不一定会回流 根据改变的范围和程度，渲染树中或大或小的部分需要重新计算，有些改变会触发整个页面的重排，比如，滚动条出现的时候或者修改了根节点。 浏览器的优化机制现代的浏览器都是很聪明的，由于每次重排都会造成额外的计算消耗，因此大多数浏览器都会通过队列化修改并批量执行来优化重排过程。浏览器会将修改操作放入到队列里，直到过了一段时间或者操作达到了一个阈值，才清空队列。但是！当你获取布局信息的操作的时候，会强制队列刷新，比如当你访问以下属性或者使用以下方法： offsetTop、offsetLeft、offsetWidth、offsetHeight scrollTop、scrollLeft、scrollWidth、scrollHeight clientTop、clientLeft、clientWidth、clientHeight getComputedStyle() getBoundingClientRect 具体可以访问这个网站：https://gist.github.com/paulirish/5d52fb081b3570c81e3a 以上属性和方法都需要返回最新的布局信息，因此浏览器不得不清空队列，触发回流重绘来返回正确的值。因此，我们在修改样式的时候，最好避免使用上面列出的属性，他们都会刷新渲染队列。如果要使用它们，最好将值缓存起来。 减少回流和重绘好了，到了我们今天的重头戏，前面说了这么多背景和理论知识，接下来让我们谈谈如何减少回流和重绘。 最小化重绘和重排由于重绘和重排可能代价比较昂贵，因此最好就是可以减少它的发生次数。为了减少发生次数，我们可以合并多次对DOM和样式的修改，然后一次处理掉。考虑这个例子 1234const el = document.getElementById(&apos;test&apos;);el.style.padding = &apos;5px&apos;;el.style.borderLeft = &apos;1px&apos;;el.style.borderRight = &apos;2px&apos;; 例子中，有三个样式属性被修改了，每一个都会影响元素的几何结构，引起回流。当然，大部分现代浏览器都对其做了优化，因此，只会触发一次重排。但是如果在旧版的浏览器或者在上面代码执行的时候，有其他代码访问了布局信息(上文中的会触发回流的布局信息)，那么就会导致三次重排。 因此，我们可以合并所有的改变然后依次处理，比如我们可以采取以下的方式： 使用cssText 12const el = document.getElementById(&apos;test&apos;);el.style.cssText += &apos;border-left: 1px; border-right: 2px; padding: 5px;&apos;; 修改CSS的class 12const el = document.getElementById(&apos;test&apos;);el.className += &apos; active&apos;; 批量修改DOM当我们需要对DOM对一系列修改的时候，可以通过以下步骤减少回流重绘次数： 使元素脱离文档流 对其进行多次修改 将元素带回到文档中。 该过程的第一步和第三步可能会引起回流，但是经过第一步之后，对DOM的所有修改都不会引起回流重绘，因为它已经不在渲染树了。 有三种方式可以让DOM脱离文档流： 隐藏元素，应用修改，重新显示 使用文档片段(document fragment)在当前DOM之外构建一个子树，再把它拷贝回文档。 将原始元素拷贝到一个脱离文档的节点中，修改节点后，再替换原始的元素。 考虑我们要执行一段批量插入节点的代码： 1234567891011function appendDataToElement(appendToElement, data) &#123; let li; for (let i = 0; i &lt; data.length; i++) &#123; li = document.createElement(&apos;li&apos;); li.textContent = &apos;text&apos;; appendToElement.appendChild(li); &#125;&#125;const ul = document.getElementById(&apos;list&apos;);appendDataToElement(ul, data); 如果我们直接这样执行的话，由于每次循环都会插入一个新的节点，会导致浏览器回流一次。 我们可以使用这三种方式进行优化: 隐藏元素，应用修改，重新显示 这个会在展示和隐藏节点的时候，产生两次回流 123456789101112function appendDataToElement(appendToElement, data) &#123; let li; for (let i = 0; i &lt; data.length; i++) &#123; li = document.createElement(&apos;li&apos;); li.textContent = &apos;text&apos;; appendToElement.appendChild(li); &#125;&#125;const ul = document.getElementById(&apos;list&apos;);ul.style.display = &apos;none&apos;;appendDataToElement(ul, data);ul.style.display = &apos;block&apos;; 使用文档片段(document fragment)在当前DOM之外构建一个子树，再把它拷贝回文档 1234const ul = document.getElementById(&apos;list&apos;);const fragment = document.createDocumentFragment();appendDataToElement(fragment, data);ul.appendChild(fragment); 将原始元素拷贝到一个脱离文档的节点中，修改节点后，再替换原始的元素。 1234const ul = document.getElementById(&apos;list&apos;);const clone = ul.cloneNode(true);appendDataToElement(clone, data);ul.parentNode.replaceChild(clone, ul); 对于上面这三种情况，我写了一个demo在safari和chrome上测试修改前和修改后的性能。然而实验结果不是很理想。 原因：原因其实上面也说过了，现代浏览器会使用队列来储存多次修改，进行优化，所以对这个优化方案，我们其实不用优先考虑。 避免触发同步布局事件上文我们说过，当我们访问元素的一些属性的时候，会导致浏览器强制清空队列，进行强制同步布局。举个例子，比如说我们想将一个p标签数组的宽度赋值为一个元素的宽度，我们可能写出这样的代码： 12345function initP() &#123; for (let i = 0; i &lt; paragraphs.length; i++) &#123; paragraphs[i].style.width = box.offsetWidth + &apos;px&apos;; &#125;&#125; 这段代码看上去是没有什么问题，可是其实会造成很大的性能问题。在每次循环的时候，都读取了box的一个offsetWidth属性值，然后利用它来更新p标签的width属性。这就导致了每一次循环的时候，浏览器都必须先使上一次循环中的样式更新操作生效，才能响应本次循环的样式读取操作。每一次循环都会强制浏览器刷新队列。我们可以优化为: 123456const width = box.offsetWidth;function initP() &#123; for (let i = 0; i &lt; paragraphs.length; i++) &#123; paragraphs[i].style.width = width + &apos;px&apos;; &#125;&#125; 同样，我也写了个demo来比较两者的性能差异。你可以自己点开这个demo体验下。这个对比的性能差距就比较明显。 对于复杂动画效果,使用绝对定位让其脱离文档流对于复杂动画效果，由于会经常的引起回流重绘，因此，我们可以使用绝对定位，让它脱离文档流。否则会引起父元素以及后续元素频繁的回流。这个我们就直接上个例子。 打开这个例子后，我们可以打开控制台，控制台上会输出当前的帧数(虽然不准)。 从上图中，我们可以看到，帧数一直都没到60。这个时候，只要我们点击一下那个按钮，把这个元素设置为绝对定位，帧数就可以稳定60。 css3硬件加速（GPU加速）比起考虑如何减少回流重绘，我们更期望的是，根本不要回流重绘。这个时候，css3硬件加速就闪亮登场啦！！ 划重点： 1. 使用css3硬件加速，可以让transform、opacity、filters这些动画不会引起回流重绘 。 2. 对于动画的其它属性，比如background-color这些，还是会引起回流重绘的，不过它还是可以提升这些动画的性能。 本篇文章只讨论如何使用，暂不考虑其原理，之后有空会另外开篇文章说明。 如何使用常见的触发硬件加速的css属性： transform opacity filters Will-change 效果我们可以先看个例子。我通过使用chrome的Performance捕获了动画一段时间里的回流重绘情况，实际结果如下图： 从图中我们可以看出，在动画进行的时候，没有发生任何的回流重绘。如果感兴趣你也可以自己做下实验。 重点 使用css3硬件加速，可以让transform、opacity、filters这些动画不会引起回流重绘 对于动画的其它属性，比如background-color这些，还是会引起回流重绘的，不过它还是可以提升这些动画的性能。 css3硬件加速的坑当然，任何美好的东西都是会有对应的代价的，过犹不及。css3硬件加速还是有坑的: 如果你为太多元素使用css3硬件加速，会导致内存占用较大，会有性能问题。 在GPU渲染字体会导致抗锯齿无效。这是因为GPU和CPU的算法不同。因此如果你不在动画结束的时候关闭硬件加速，会产生字体模糊。 总结本文主要讲了浏览器的渲染过程、浏览器的优化机制以及如何减少甚至避免回流和重绘，希望可以帮助大家更好的理解回流重绘。","tags":[{"name":"-浏览器渲染","slug":"浏览器渲染","permalink":"http://www.leqikeji.com/blog/tags/浏览器渲染/"}]},{"title":"Hook概要","date":"2019-06-10T06:50:40.000Z","path":"2019/06/10/Hook/","text":"什么是hook首先我们需要了解什么是hook，拿react的介绍来看，它的定义是： 它可以让你在不编写 class 的情况下使用 state 以及其他的 React 特性 在16.8以前的版本中，我们在写react组件的时候，大部分都都是class component，因为基于class的组件react提供了更多的可操作性，比如拥有自己的state，以及一些生命周期的实现，对于复杂的逻辑来讲class的支持程度是更高的：123456789101112131415161718192021class Hello extends React.Component &#123; constructor(props) &#123; super(props); this.state = &#123;date: new Date()&#125;; &#125; componentDidMount() &#123; // do sth... &#125; componentWillUnmount() &#123; // do sth... &#125; // other methods or lifecycle... render() &#123; return ( &lt;div&gt; &lt;h1&gt;Hello, world!&lt;/h1&gt; &lt;h2&gt;It is &#123;this.state.date.toLocaleTimeString()&#125;.&lt;/h2&gt; &lt;/div&gt; ); &#125;&#125; 同时，对于function component来说，react也是支持的，但是function component只能拥有props，不能拥有state，也就是只能实现stateless component： 123function Welcome(props) &#123; return &lt;h1&gt;Hello, &#123;props.name&#125;&lt;/h1&gt;;&#125; react 并没有提供在函数组件中设置state以及生命周期的一些操作方法，所以那个时候，极少的场景下适合采用函数组件，但是16.8版本出现hook以后情况得到了改变，hook的目标就是–让你在不编写 class 的情况下使用 state 以及其他的 React 特性，来看个例子： 123456789101112131415import React, &#123; useState &#125; from 'react';function Example() &#123; // 声明一个新的叫做 “count” 的 state 变量 const [count, setCount] = useState(0); return ( &lt;div&gt; &lt;p&gt;You clicked &#123;count&#125; times&lt;/p&gt; &lt;button onClick=&#123;() =&gt; setCount(count + 1)&#125;&gt; Click me &lt;/button&gt; &lt;/div&gt; );&#125; useState就是react提供的一个Hook，通过它我们就可以在function组件中设置自己想要的state了，不仅可以使用还可以很方便的去通过setState(注意不是class中的setState，这里指的是上述例子中的setCount)更改，当然，react提供了很多hook来支持不同的行为和操作，下面我们还会再简单介绍，我们在看下vue hook，这是尤大在vueconf上分享的一段代码： 123456789101112131415161718192021222324252627282930313233import &#123; value, computed, watch, onMounted &#125; from 'vue'const App = &#123; template: ` &lt;div&gt; &lt;span&gt;count is &#123;&#123; count &#125;&#125;&lt;/span&gt; &lt;span&gt;plusOne is &#123;&#123; plusOne &#125;&#125;&lt;/span&gt; &lt;button @click=\"increment\"&gt;count++&lt;/button&gt; &lt;/div&gt; `, setup() &#123; // reactive state const count = value(0) // computed state const plusOne = computed(() =&gt; count.value + 1) // method const increment = () =&gt; &#123; count.value++ &#125; // watch watch(() =&gt; count.value * 2, val =&gt; &#123; console.log(`count * 2 is $&#123;val&#125;`) &#125;) // lifecycle onMounted(() =&gt; &#123; console.log(`mounted`) &#125;) // expose bindings on render context return &#123; count, plusOne, increment &#125; &#125;&#125; 从上面的例子中不难看出，和react hook的用法非常相似，并且尤大也有说这个RFC是借鉴了react hook的想法，但是规避了一些react的问题，然后这里解释一下为什么我把vue的这个RFC也称为是hook，因为在react hook的介绍中有这么一句话，什么是hook–Hook 是一些可以让你在函数组件里“钩入” React state 及生命周期等特性的函数，那么vue提供的这些API的作用也是类似的–可以让你在函数组件里“钩入” value(2.x中的data) 及生命周期等特性的函数，所以，暂且就叫vue-hook吧~ hook的时代意义那么，hook的时代意义是什么？我们从头来说，框架是服务于业务的，业务中很难避免的一个问题就是– 逻辑复用，同样的功能，同样的组件，在不一样的场合下，我们有时候不得不去写2+次，为了避免耦合，后来各大框架纷纷想出了一些办法： mixin HOC slot 各大框架的使用情况： react 和 vue都曾用过mixin(react 目前已经废弃), Higher-Order-Components(HOC) react中用的相对多一点，vue的话，嵌套template有点。。别扭, slot vue中用的多一些，react基本不需要slot这种用法, 上述这些方法都可以实现逻辑上的复用，但是都有一些额外的问题: mixin的问题： 可能会相互依赖，相互耦合，不利于代码维护； 不同的mixin中的方法可能会相互冲突; mixin非常多时，组件是可以感知到的，甚至还要为其做相关处理， 这样会给代码造成滚雪球式的复杂性 HOC的问题： 需要在原组件上进行包裹或者嵌套，如果大量使用HOC， 将会产生非常多的嵌套，这让调试变得非常困难； HOC可以劫持props，在不遵守约定的情况下也可能造成冲突 props 也可能造成命名的冲突 wrapper hell 有没有见过这样的dom结构？ 这就是wrapper hell的典型代表~ 所以，hook的出现是划时代的，它通过function抽离的方式，实现了复杂逻辑的内部封装，根据上述我们提出的问题总结了hook的一些优点： 逻辑代码的复用 减小了代码体积 没有this的烦恼 带着这些思想，我们一起看下react和vue分别的实现： react hook简介 Dan 讲解hook的视频在这里，如果你看不了这个，可以尝试看官网介绍 我们用同样功能的代码来看react hook，实现一个监听鼠标变化，并实时查看位置的功能，同时我们把位置信息挂到title上面，用class component我们要这样写： 1234567891011121314151617181920212223242526272829303132333435import React, &#123; Component &#125; from 'react';export default class MyClassApp extends Component &#123; constructor(props) &#123; super(props); this.state = &#123; x: 0, y: 0 &#125;; this.handleUpdate = this.handleUpdate.bind(this); &#125; componentDidMount() &#123; document.addEventListener('mousemove', this.handleUpdate); &#125; componentDidUpdate() &#123; const &#123; x, y &#125; = this.state; document.title = `($&#123;x&#125;,$&#123;y&#125;)`; &#125; componentWillUnmount() &#123; window.removeEventListener('mousemove', this.handleUpdate); &#125; handleUpdate(e) &#123; this.setState(&#123; x: e.clientX, y: e.clientY &#125;); &#125; render() &#123; return ( &lt;div&gt; current position x:&#123;this.state.x&#125;, y:&#123;this.state.y&#125; &lt;/div&gt; ); &#125;&#125; 在线代码演示在这里 同样的逻辑我们换用hook来实现 12345678910111213141516171819202122232425262728293031323334import React, &#123; useState, useEffect &#125; from 'react';// 自定义hook useMousePostionconst useMousePostion = () =&gt; &#123; // 使用hookuseState初始化一个state const [postion, setPostion] = useState(&#123; x: 0, y: 0 &#125;); function handleMove(e) &#123; setPostion(&#123; x: e.clientX, y: e.clientY &#125;); &#125; // 使用useEffect处理class中生命周期可以做到的事情 // 注：效果一样，但是实际的原理并不同，有兴趣可以去官网仔细研究 useEffect(() =&gt; &#123; // 同时可以处理 componentDidMount 以及 componentDidUpdate 中的事情 window.addEventListener('mousemove', handleMove); document.title = `($&#123;postion.x&#125;,$&#123;postion.y&#125;)`; return () =&gt; &#123; // return的function 可以相当于在组件被卸载的时候执行 类似于 componentWillUnmount window.removeEventListener('mousemove', handleMove); &#125;; // [] 是参数，代表deps，也就是说react触发这个hook的时机会和传入的deps有关，内部利用objectIs实现 // 默认不给参数会在每次render的时候调用，给空数组会导致每次比较是一样的，只执行一次，这里正确的应该是给postion &#125;, [postion]); // postion 可以被直接return，这样达到了逻辑的复用~，哪里需要哪里调用就可以了。 return postion;&#125;;export default function App() &#123; const &#123; x, y &#125; = useMousePostion(); // 内部维护自己的postion相关的逻辑 return ( &lt;div&gt; current position x: &#123;x&#125;, y: &#123;y&#125; &lt;/div&gt; );&#125; 在线代码演示在这里 可以看出用了hook之后，我们把关于position的逻辑都放到一个自定义的hook–useMousePostion 中，之后复用是很方便的，而且可以在内部进行维护postion独有的逻辑而不影响外部内容，比起class组件，抽象能力更强。 下面给大家安利几个不错的资源： 入门： 官网传送门 深入： Dan自己写的关于hook的文章，写的很好强烈安利，深入内部实现 vue hook简介 尤大讲解的视频在这里 代码因为vue3.0尚未发布，我们还是看尤大给的demo代码： 12345678910111213141516171819202122232425262728import &#123; value, computed, watch, onMounted &#125; from 'vue'function useMouse() &#123; const x = value(0) const y = value(0) const update = e =&gt; &#123; x.value = e.pageX y.value = e.pageY &#125; onMounted(() =&gt; &#123; window.addEventListener('mousemove', update) &#125;) onUnmounted(() =&gt; &#123; window.removeEventListener('mousemove', update) &#125;) return &#123; x, y &#125;&#125;// 在组件中使用该函数const Component = &#123; setup() &#123; const &#123; x, y &#125; = useMouse() // 与其它函数配合使用 const &#123; z &#125; = useOtherLogic() return &#123; x, y, z &#125; &#125;, template: `&lt;div&gt;&#123;&#123; x &#125;&#125; &#123;&#123; y &#125;&#125; &#123;&#123; z &#125;&#125;&lt;/div&gt;`&#125; 可以看出来同样我们可以抽离一些需要复用的逻辑到一个单独的函数useMouse中，然后在这个函数里面定义的一些生命周期和value的内容会随着setup函数的调用被“钩入(hook)”到组件上，并且这个函数return出来的数据可以直接被用在模板上，更具体的玩法我们坐等3.0的出现吧。 基础内容不过多介绍，毕竟真实的api还没发布，想了解具体内容的可以来看尤大的讲解 same &amp; diff Point看完了2个框架关于hook的实现，我们来做个简单的对比 Same Point: 出现的背景，解决的问题是一样的，2个框架都是为了解决逻辑复用过乱，代码体积过大等一些问题，包括this问题，使用function函数我们很少会和this去打交道了。 使用方式类似，都是把可以复用的一些单独的逻辑抽离到一个单独的函数中去，同时返回组件中需要用到的数据，并且内部会自我维护数据的更新，从而触发视图的更新 Diff Point: 实现原理不同 react hook底层是基于链表实现，调用的条件是每次组件被render的时候都会顺序执行所有的hooks，所以下面的代码会报错 123456function App()&#123; const [name, setName] = useState('demo'); if(condition)&#123; const [val, setVal] = useState(''); &#125;&#125; 因为底层是链表，每一个hook的next是指向下一个hook的，if会导致顺序不正确，从而导致报错，所以react是不允许这样使用hook的。 vue hook只会在setup函数被调用的时候被注册一次，react数据更改的时候，会导致重新render，重新render又会重新把hooks重新注册一次，所以react的上手难度更高一些，而vue之所以能避开这些麻烦的问题，根本原因在于它对数据的响应是基于proxy的，这种场景下，只要任何一个更改data的地方，相关的function或者template都会被重新计算，因此避开了react可能遇到的性能上的问题 当然react对这些都有解决方案，想了解的同学可以去看官网有介绍，比如useCallback，useMemo等hook的作用，我们看下尤大对vue和react hook的总结对比： 1.整体上更符合 JavaScript 的直觉； 2.不受调用顺序的限制，可以有条件地被调用； 3.不会在后续更新时不断产生大量的内联函数而影响引擎优化或是导致 GC 压力； 4.不需要总是使用 useCallback 来缓存传给子组件的回调以防止过度更新； 5.不需要担心传了错误的依赖数组给 useEffect/useMemo/useCallback 从而导致回调中使用了过期的值 —— Vue 的依赖追踪是全自动的。 不得不说，青出于蓝而胜于蓝，vue虽然借鉴了react，但是天然的响应式数据，完美的避开了一些react hook遇到的短板~ 总结 function component 将会是接下来各大框架发展的一个方向，function天然对TS的友好也是一个重要的影响; react hook的上手成本相对于vue会难一些，vue天生规避了一些react中比较难处理的地方; hook一定是大前端的一个趋势，现在才是刚刚开始的阶段：SwiftUI-Hooks, flutter_hooks…","tags":[{"name":"hook","slug":"hook","permalink":"http://www.leqikeji.com/blog/tags/hook/"}]},{"title":"js 数组排序和算法排序","date":"2019-04-12T02:19:40.000Z","path":"2019/04/12/js数组排序和算法排序/","text":"概述对所有的排序算法进行综合整理 1.插入排序原理 它的原理是每插入一个数都要将它和之前的已经完成排序的序列进行重新排序，也就是要找到新插入的数对应原序列中的位置。那么也就是说，每次插入一个数都要对原来排序好的那部分序列进行重新的排序，时间复杂度同样为O（n²）。 这种算法是稳定的排序方法。 图解123456789101112131415161718192021var arr = [23,34,3,4,23,44,333,444];var arrShow = (function insertionSort(array)&#123; if(Object.prototype.toString.call(array).slice(8,-1) ==='Array')&#123; for (var i = 1; i &lt; array.length; i++) &#123; var key = array[i]; var j = i - 1; while (j &gt;= 0 &amp;&amp; array[j] &gt; key) &#123; array[j + 1] = array[j]; j--; &#125; array[j + 1] = key; &#125; return array; &#125;else&#123; return 'array is not an Array!'; &#125;&#125;)(arr);console.log(arrShow);//[3, 4, 23, 23, 34, 44, 333, 444] 2.二分插入排序算法思想 1.二分插入排序的基本思想和插入排序一致；都是将某个元素插入到已经有序的序列的正确的位置； 2.和直接插入排序的最大区别是，元素A[i]的位置的方法不一样；直接插入排序是从A[i-1]往前一个个比较，从而找到正确的位置；而二分插入排序，利用前i-1个元素已经是有序的特点结合二分查找的特点，找到正确的位置，从而将A[i]插入，并保持新的序列依旧有序； 3.时间复杂度：T(n) = O(n);12345678910111213141516171819202122function binaryInsertionSort(array) &#123; if (Object.prototype.toString.call(array).slice(8, -1) === 'Array') &#123; for (var i = 1; i &lt; array.length; i++) &#123; var key = array[i], left = 0, right = i - 1; while (left &lt;= right) &#123; var middle = parseInt((left + right) / 2); if (key &lt; array[middle]) &#123; right = middle - 1; &#125; else &#123; left = middle + 1; &#125; &#125; for (var j = i - 1; j &gt;= left; j--) &#123; array[j + 1] = array[j]; &#125; array[left] = key; &#125; return array; &#125; else &#123; return 'array is not an Array!'; &#125;&#125; 3.选择排序工作原理 它的工作原理是每一次从待排序的数据元素中选出最小（或最大）的一个元素，存放在序列的起始位置，直到全部待排序的数据元素排完。 图解选择排序就是对数组中的元素进行比较选择，然后直接放置在排序后的位置。首先指针K先指向数组0号位置，K相当于指明一个目标位置。然后另一个指针min从K开始，往后一次比较，找到最小的值，并存储在min中，比较了一轮后，min中存储的数就是整个数组中最小的数字。这是直接将min中的数字和K指向的数字交换即可。然后找到数组中第二小的数，让他跟数组中第二个元素交换一下值，以此类推。12345678910111213141516171819function selectionSort(array) &#123; if (Object.prototype.toString.call(array).slice(8, -1) === 'Array') &#123; var len = array.length, temp; for (var i = 0; i &lt; len - 1; i++) &#123; var min = array[i]; for (var j = i + 1; j &lt; len; j++) &#123; if (array[j] &lt; min) &#123; temp = min; min = array[j]; array[j] = temp; &#125; &#125; array[i] = min; &#125; return array; &#125; else &#123; return 'array is not an Array!'; &#125;&#125; 4.冒泡排序 原理：比较两个相邻的元素，将值大的元素交换至右端。 思路：依次比较相邻的两个数，将小数放在前面，大数放在后面。即在第一趟：首先比较第1个和第2个数，将小数放前，大数放后。然后比较第2个数和第3个数，将小数放前，大数放后，如此继续，直至比较最后两个数，将小数放前，大数放后。重复第一趟步骤，直至全部排序完成。1234567891011121314151617function bubbleSort(array) &#123; if (Object.prototype.toString.call(array).slice(8, -1) === 'Array') &#123; var len = array.length, temp; for (var i = 0; i &lt; len - 1; i++) &#123; for (var j = len - 1; j &gt;= i; j--) &#123; if (array[j] &lt; array[j - 1]) &#123; temp = array[j]; array[j] = array[j - 1]; array[j - 1] = temp; &#125; &#125; &#125; return array; &#125; else &#123; return 'array is not an Array!'; &#125;&#125; 5.快速排序基本思想 基本思想是：通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列。 算法介绍设要排序的数组是A[0]……A[N-1]，首先任意选取一个数据（通常选用数组的第一个数）作为关键数据，然后将所有比它小的数都放到它左边，所有比它大的数都放到它右边，这个过程称为一趟快速排序。值得注意的是，快速排序不是一种稳定的排序算法，也就是说，多个相同的值的相对位置也许会在算法结束时产生变动。一趟快速排序的算法是：1）设置两个变量i、j，排序开始的时候：i=0，j=N-1；2）以第一个数组元素作为关键数据，赋值给key，即key=A[0]；3）从j开始向前搜索，即由后开始向前搜索(j–)，找到第一个小于key的值A[j]，将A[j]和A[i]的值交换；4）从i开始向后搜索，即由前开始向后搜索(i++)，找到第一个大于key的A[i]，将A[i]和A[j]的值交换；5）重复第3、4步，直到i=j； (3,4步中，没找到符合条件的值，即3中A[j]不小于key,4中A[i]不大于key的时候改变j、i的值，使得j=j-1，i=i+1，直至找到为止。找到符合条件的值，进行交换的时候i， j指针位置不变。另外，i==j这一过程一定正好是i+或j-完成的时候，此时令循环结束）。1234567891011121314151617181920212223242526272829303132333435363738394041//方法一function quickSort(array, left, right) &#123; if (Object.prototype.toString.call(array).slice(8, -1) === 'Array' &amp;&amp; typeof left === 'number' &amp;&amp; typeof right === 'number') &#123; if (left &lt; right) &#123; var x = array[right], i = left - 1, temp; for (var j = left; j &lt;= right; j++) &#123; if (array[j] &lt;= x) &#123; i++; temp = array[i]; array[i] = array[j]; array[j] = temp; &#125; &#125; quickSort(array, left, i - 1); quickSort(array, i + 1, right); &#125;; &#125; else &#123; return 'array is not an Array or left or right is not a number!'; &#125;&#125;var aaa = [3, 5, 2, 9, 1];quickSort(aaa, 0, aaa.length - 1);console.log(aaa); //方法二var quickSort = function(arr) &#123; if (arr.length &lt;= 1) &#123; return arr; &#125; var pivotIndex = Math.floor(arr.length / 2); var pivot = arr.splice(pivotIndex, 1)[0]; var left = []; var right = []; for (var i = 0; i &lt; arr.length; i++)&#123; if (arr[i] &lt; pivot) &#123; left.push(arr[i]); &#125; else &#123; right.push(arr[i]); &#125; &#125; return quickSort(left).concat([pivot], quickSort(right));&#125;; 6.堆排序1234567891011121314151617181920212223242526272829303132333435363738394041424344/*方法说明：堆排序@param array 待排序数组*/function heapSort(array) &#123; if (Object.prototype.toString.call(array).slice(8, -1) === 'Array') &#123; //建堆 var heapSize = array.length, temp; for (var i = Math.floor(heapSize / 2); i &gt;= 0; i--) &#123; heapify(array, i, heapSize); &#125; //堆排序 for (var j = heapSize - 1; j &gt;= 1; j--) &#123; temp = array[0]; array[0] = array[j]; array[j] = temp; heapify(array, 0, --heapSize); &#125; &#125; else &#123; return 'array is not an Array!'; &#125;&#125;/*方法说明：维护堆的性质@param arr 数组@param x 数组下标@param len 堆大小*/function heapify(arr, x, len) &#123; if (Object.prototype.toString.call(arr).slice(8, -1) === 'Array' &amp;&amp; typeof x === 'number') &#123; var l = 2 * x, r = 2 * x + 1, largest = x, temp; if (l &lt; len &amp;&amp; arr[l] &gt; arr[largest]) &#123; largest = l; &#125; if (r &lt; len &amp;&amp; arr[r] &gt; arr[largest]) &#123; largest = r; &#125; if (largest != x) &#123; temp = arr[x]; arr[x] = arr[largest]; arr[largest] = temp; heapify(arr, largest, len); &#125; &#125; else &#123; return 'arr is not an Array or x is not a number!'; &#125;&#125; 7.归并排序123456789101112131415161718192021222324252627function mergeSort(array, p, r) &#123; if (p &lt; r) &#123; var q = Math.floor((p + r) / 2); mergeSort(array, p, q); mergeSort(array, q + 1, r); merge(array, p, q, r); &#125;&#125;function merge(array, p, q, r) &#123; var n1 = q - p + 1, n2 = r - q, left = [], right = [], m = n = 0; for (var i = 0; i &lt; n1; i++) &#123; left[i] = array[p + i]; &#125; for (var j = 0; j &lt; n2; j++) &#123; right[j] = array[q + 1 + j]; &#125; left[n1] = right[n2] = Number.MAX_VALUE; for (var k = p; k &lt;= r; k++) &#123; if (left[m] &lt;= right[n]) &#123; array[k] = left[m]; m++; &#125; else &#123; array[k] = right[n]; n++; &#125; &#125;&#125; 8.桶排序12345678910111213141516171819202122232425262728293031323334/*方法说明：桶排序@param array 数组@param num 桶的数量*/function bucketSort(array, num) &#123; if (array.length &lt;= 1) &#123; return array; &#125; var len = array.length, buckets = [], result = [], min = max = array[0], regex = '/^[1-9]+[0-9]*$/', space, n = 0; num = num || ((num &gt; 1 &amp;&amp; regex.test(num)) ? num : 10); for (var i = 1; i &lt; len; i++) &#123; min = min &lt;= array[i] ? min : array[i]; max = max &gt;= array[i] ? max : array[i]; &#125; space = (max - min + 1) / num; for (var j = 0; j &lt; len; j++) &#123; var index = Math.floor((array[j] - min) / space); if (buckets[index]) &#123; // 非空桶，插入排序 var k = buckets[index].length - 1; while (k &gt;= 0 &amp;&amp; buckets[index][k] &gt; array[j]) &#123; buckets[index][k + 1] = buckets[index][k]; k--; &#125; buckets[index][k + 1] = array[j]; &#125; else &#123; //空桶，初始化 buckets[index] = []; buckets[index].push(array[j]); &#125; &#125; while (n &lt; num) &#123; result = result.concat(buckets[n]); n++; &#125; return result;&#125; 9.计数排序12345678910111213141516function countingSort(array) &#123; var len = array.length, B = [], C = [], min = max = array[0]; for (var i = 0; i &lt; len; i++) &#123; min = min &lt;= array[i] ? min : array[i]; max = max &gt;= array[i] ? max : array[i]; C[array[i]] = C[array[i]] ? C[array[i]] + 1 : 1; &#125; for (var j = min; j &lt; max; j++) &#123; C[j + 1] = (C[j + 1] || 0) + (C[j] || 0); &#125; for (var k = len - 1; k &gt;=0; k--) &#123; B[C[array[k]] - 1] = array[k]; C[array[k]]--; &#125; return B;&#125;","tags":[{"name":"-排序","slug":"排序","permalink":"http://www.leqikeji.com/blog/tags/排序/"}]},{"title":"diff算法","date":"2019-03-10T07:57:40.000Z","path":"2019/03/10/diff/","text":"Diff三种策略 Diff算法的作用是用来计算出 Virtual DOM 中被改变的部分，然后针对该部分进行原生DOM操作，而不用重新渲染整个页面。Diff算法有三大策略： Tree Diff Component Diff Element Diff 三种策略的执行顺序也是顺序依次执行。Tree Diff 是对树每一层进行遍历，找出不同，如图所示。 Component Diff 是数据层面的差异比较 如果都是同一类型的组件(即：两节点是同一个组件类的两个不同实例，比如：与)，按照原策略继续比较Virtual DOM树即可 如果出现不是同一类型的组件，则将该组件判断为dirty component，从而替换整个组件下的所有子节点 Element Diff真实DOM渲染，结构差异的比较 首先进行第一层比较，第一层都是R，不发生变化；然后进入第二层Component Diff，发现A组件没有，则删除A及其子组件B、C；最后比较第三层，创建A及其子组件B、C。 当节点处于同一层级时，Diff提供三种DOM操作：删除、移动、插入。 如图所示，首先将OldVnode 和 NewVnode的首尾位置分别标记为oldS、oldE、newS、newE。 (1) oldS和newS相同，不发生变化，oldS++，newS++。 oldS = a，oldE = d newS = a, newE = c (2) newS与OldVnode不匹配，oldS前面插入f，newS++。 oldS = b，oldE = d newS = f， newE = c (3) newS与oldE相同，oldE移动到oldS前面，newS++，oldE–。 oldS = b，oldE = d newS = d， newE = c (4) newE与oldE相同，不发生变化，newE–，oldE–。 oldS = b，oldE = c newS = e， newE = c (5) 都不相同，oldS前插入newE，删除oldS，oldS++，newS++，newE–，oldE–。 oldS = b，oldE = b newS = e， newE = e (6) oldS &gt; oldE，Diff结束，最后结果为：a、f、d、e、c。 最后附上核心源码分析：patch 123456789101112131415161718192021222324252627282930313233343536function patch (oldVnode, vnode) &#123; // some code if (sameVnode(oldVnode, vnode)) &#123; patchVnode(oldVnode, vnode) &#125; else &#123; const oEl = oldVnode.el // 当前oldVnode对应的真实元素节点 let parentEle = api.parentNode(oEl) // 父元素 createEle(vnode) // 根据Vnode生成新元素 if (parentEle !== null) &#123; api.insertBefore(parentEle, vnode.el, api.nextSibling(oEl)) // 将新元素添加进父元素 api.removeChild(parentEle, oldVnode.el) // 移除以前的旧元素节点 oldVnode = null &#125; &#125; // some code return vnode&#125;patchVnode (oldVnode, vnode) &#123; const el = vnode.el = oldVnode.el let i, oldCh = oldVnode.children, ch = vnode.children if (oldVnode === vnode) return if (oldVnode.text !== null &amp;&amp; vnode.text !== null &amp;&amp; oldVnode.text !== vnode.text) &#123; api.setTextContent(el, vnode.text) &#125;else &#123; updateEle(el, vnode, oldVnode) if (oldCh &amp;&amp; ch &amp;&amp; oldCh !== ch) &#123; updateChildren(el, oldCh, ch) &#125;else if (ch)&#123; createEle(vnode) //create el's children dom &#125;else if (oldCh)&#123; api.removeChildren(el) &#125; &#125;&#125; 这个函数做了以下事情： 找到对应的真实dom，称为el 判断Vnode和oldVnode是否指向同一个对象，如果是，那么直接return 如果他们都有文本节点并且不相等，那么将el的文本节点设置为Vnode的文本节点。 如果oldVnode有子节点而Vnode没有，则删除el的子节点 如果oldVnode没有子节点而Vnode有，则将Vnode的子节点真实化之后添加到el 如果两者都有子节点，则执行updateChildren函数比较子节点 updateChildren 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283function updateChildren (parentElm, oldCh, newCh, insertedVnodeQueue, removeOnly) &#123; var oldStartIdx = 0; var newStartIdx = 0; var oldEndIdx = oldCh.length - 1; var oldStartVnode = oldCh[0]; var oldEndVnode = oldCh[oldEndIdx]; var newEndIdx = newCh.length - 1; var newStartVnode = newCh[0]; var newEndVnode = newCh[newEndIdx]; var oldKeyToIdx, idxInOld, vnodeToMove, refElm; var canMove = !removeOnly; &#123; checkDuplicateKeys(newCh); &#125; // oldVnode起始位置小于结束位置并且newVnode起始位置小于结束位置 while (oldStartIdx &lt;= oldEndIdx &amp;&amp; newStartIdx &lt;= newEndIdx) &#123; // isUndef 用来判断对象是否等于undefined或者为空，是的话返回true if (isUndef(oldStartVnode)) &#123; // oldVnode 起始位置oldS++ oldStartVnode = oldCh[++oldStartIdx]; // Vnode has been moved left &#125; else if (isUndef(oldEndVnode)) &#123; // oldVnode 结束位置oldE-- oldEndVnode = oldCh[--oldEndIdx]; &#125; else if (sameVnode(oldStartVnode, newStartVnode)) &#123; // oldS和newS相同，不变化，进行patch，oldS++，newS++ patchVnode(oldStartVnode, newStartVnode, insertedVnodeQueue, newCh, newStartIdx); oldStartVnode = oldCh[++oldStartIdx]; newStartVnode = newCh[++newStartIdx]; &#125; else if (sameVnode(oldEndVnode, newEndVnode)) &#123; // oldE和newE相同，不变化，进行patch，oldE--，newE-- patchVnode(oldEndVnode, newEndVnode, insertedVnodeQueue, newCh, newEndIdx); oldEndVnode = oldCh[--oldEndIdx]; newEndVnode = newCh[--newEndIdx]; &#125; else if (sameVnode(oldStartVnode, newEndVnode)) &#123; // Vnode moved right // oldS和newE相同，oldS移动到oldE之后，进行patch，oldS++，newE-- patchVnode(oldStartVnode, newEndVnode, insertedVnodeQueue, newCh, newEndIdx); canMove &amp;&amp; nodeOps.insertBefore(parentElm, oldStartVnode.elm, nodeOps.nextSibling(oldEndVnode.elm)); oldStartVnode = oldCh[++oldStartIdx]; newEndVnode = newCh[--newEndIdx]; &#125; else if (sameVnode(oldEndVnode, newStartVnode)) &#123; // Vnode moved left // oldE和newS相同，oldE移动到oldS之前，进行patch，oldE--，newS++ patchVnode(oldEndVnode, newStartVnode, insertedVnodeQueue, newCh, newStartIdx); canMove &amp;&amp; nodeOps.insertBefore(parentElm, oldEndVnode.elm, oldStartVnode.elm); oldEndVnode = oldCh[--oldEndIdx]; newStartVnode = newCh[++newStartIdx]; &#125; else &#123; // 全都不相同情况下 // 获取oldVnode-&gt;index的key if (isUndef(oldKeyToIdx)) &#123; oldKeyToIdx = createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx); &#125; idxInOld = isDef(newStartVnode.key) ? oldKeyToIdx[newStartVnode.key] : findIdxInOld(newStartVnode, oldCh, oldStartIdx, oldEndIdx); if (isUndef(idxInOld)) &#123; // New element // oldVnode-&gt;index为undefined或null，说明没有该元素，创建新的元素 createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm, false, newCh, newStartIdx); &#125; else &#123; // 获取oldVnode vnodeToMove = oldCh[idxInOld]; if (sameVnode(vnodeToMove, newStartVnode)) &#123; // 创建的Vnode和newS相同，插入到oldS之前，进行patch patchVnode(vnodeToMove, newStartVnode, insertedVnodeQueue, newCh, newStartIdx); oldCh[idxInOld] = undefined; canMove &amp;&amp; nodeOps.insertBefore(parentElm, vnodeToMove.elm, oldStartVnode.elm); &#125; else &#123; // 相同的key但是不一样的element. 被视为新的element createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm, false, newCh, newStartIdx); &#125; &#125; newStartVnode = newCh[++newStartIdx]; &#125; &#125; // 当oldS&gt;oldE时，将newS至newE间的全部插入 if (oldStartIdx &gt; oldEndIdx) &#123; refElm = isUndef(newCh[newEndIdx + 1]) ? null : newCh[newEndIdx + 1].elm; addVnodes(parentElm, refElm, newCh, newStartIdx, newEndIdx, insertedVnodeQueue); &#125; else if (newStartIdx &gt; newEndIdx) &#123; // 当newS&gt;newE，将oldS至oldE间的全部删除 removeVnodes(parentElm, oldCh, oldStartIdx, oldEndIdx); &#125;&#125;","tags":[{"name":"算法","slug":"算法","permalink":"http://www.leqikeji.com/blog/tags/算法/"}]},{"title":"3分钟了解BFC","date":"2018-07-11T10:56:40.000Z","path":"2018/07/11/3分钟了解BFC/","text":"一、常见定位方案在讲 BFC 之前，我们先来了解一下常见的定位方案，定位方案是控制元素的布局，有三种常见方案: 普通流 (normal flow) 在普通流中，元素按照其在 HTML 中的先后位置至上而下布局，在这个过程中，行内元素水平排列，直到当行被占满然后换行，块级元素则会被渲染为完整的一个新行，除非另外指定，否则所有元素默认都是普通流定位，也可以说，普通流中元素的位置由该元素在 HTML 文档中的位置决定。 浮动 (float) 在浮动布局中，元素首先按照普通流的位置出现，然后根据浮动的方向尽可能的向左边或右边偏移，其效果与印刷排版中的文本环绕相似。 绝对定位 (absolute positioning) 在绝对定位布局中，元素会整体脱离普通流，因此绝对定位元素不会对其兄弟元素造成影响，而元素具体的位置由绝对定位的坐标决定。 二、BFC 概念Formatting context(格式化上下文) 是 W3C CSS2.1 规范中的一个概念。它是页面中的一块渲染区域，并且有一套渲染规则，它决定了其子元素将如何定位，以及和其他元素的关系和相互作用。 那么 BFC 是什么呢？ BFC 即 Block Formatting Contexts (块级格式化上下文)，它属于上述定位方案的普通流。 具有 BFC 特性的元素可以看作是隔离了的独立容器，容器里面的元素不会在布局上影响到外面的元素，并且 BFC 具有普通容器所没有的一些特性。 通俗一点来讲，可以把 BFC 理解为一个封闭的大箱子，箱子内部的元素无论如何翻江倒海，都不会影响到外部。 三、触发 BFC只要元素满足下面任一条件即可触发 BFC 特性： body 根元素 浮动元素：float 除 none 以外的值 绝对定位元素：position (absolute、fixed) display 为 inline-block、table-cells、flex overflow 除了 visible 以外的值 (hidden、auto、scroll) 四、BFC 特性及应用1. 同一个 BFC 下外边距会发生折叠 123456789101112&lt;head&gt;div&#123; width: 100px; height: 100px; background: lightblue; margin: 100px;&#125;&lt;/head&gt;&lt;body&gt; &lt;div&gt;&lt;/div&gt; &lt;div&gt;&lt;/div&gt;&lt;/body&gt; 从效果上看，因为两个 div 元素都处于同一个 BFC 容器下 (这里指 body 元素) 所以第一个 div 的下边距和第二个 div 的上边距发生了重叠，所以两个盒子之间距离只有 100px，而不是 200px。 首先这不是 CSS 的 bug，我们可以理解为一种规范，如果想要避免外边距的重叠，可以将其放在不同的 BFC 容器中。 123456789101112131415&lt;div class=\"container\"&gt; &lt;p&gt;&lt;/p&gt;&lt;/div&gt;&lt;div class=\"container\"&gt; &lt;p&gt;&lt;/p&gt;&lt;/div&gt;.container &#123; overflow: hidden;&#125;p &#123; width: 100px; height: 100px; background: lightblue; margin: 100px;&#125; 这时候，两个盒子边距就变成了 200px 2. BFC 可以包含浮动的元素（清除浮动） 我们都知道，浮动的元素会脱离普通文档流，来看下下面一个例子 123&lt;div style=\"border: 1px solid #000;\"&gt; &lt;div style=\"width: 100px;height: 100px;background: #eee;float: left;\"&gt;&lt;/div&gt;&lt;/div&gt; 由于容器内元素浮动，脱离了文档流，所以容器只剩下 2px 的边距高度。如果使触发容器的 BFC，那么容器将会包裹着浮动元素。 123&lt;div style=\"border: 1px solid #000;overflow: hidden\"&gt; &lt;div style=\"width: 100px;height: 100px;background: #eee;float: left;\"&gt;&lt;/div&gt;&lt;/div&gt; 效果如图： 3. BFC 可以阻止元素被浮动元素覆盖 先来看一个文字环绕效果： 123&lt;div style=\"height: 100px;width: 100px;float: left;background: lightblue\"&gt;我是一个左浮动的元素&lt;/div&gt;&lt;div style=\"width: 200px; height: 200px;background: #eee\"&gt;我是一个没有设置浮动, 也没有触发 BFC 元素, width: 200px; height:200px; background: #eee;&lt;/div&gt; 这时候其实第二个元素有部分被浮动元素所覆盖，(但是文本信息不会被浮动元素所覆盖) 如果想避免元素被覆盖，可触第二个元素的 BFC 特性，在第二个元素中加入 overflow: hidden，就会变成： 这个方法可以用来实现两列自适应布局，效果不错，这时候左边的宽度固定，右边的内容自适应宽度(去掉上面右边内容的宽度)。","tags":[{"name":"-bfc","slug":"bfc","permalink":"http://www.leqikeji.com/blog/tags/bfc/"}]},{"title":"markdown摘要","date":"2018-05-11T09:57:40.000Z","path":"2018/05/11/markdown摘要/","text":"概述出发点本文主要是针对Markdown的中文文档进行整理，筛选出一些重点，查看更完整描述异步中文文档 兼容HTMLMarkdown 语法的目标是：成为一种适用于网络的书写语言。HTML 是一种发布的格式，Markdown 是一种书写的格式。 不在 Markdown 涵盖范围之内的标签，都可以直接在文档里面用 HTML 撰写。不需要额外标注这是 HTML 或是 Markdown；只要直接加标签就可以了。 请注意，在 HTML 区块标签间的 Markdown 格式语法将不会被处理。比如，你在 HTML 区块内使用 Markdown 样式的强调会没有效果。 HTML 的区段（行内）标签如 &lt;span&gt;、&lt;cite&gt;、&lt;del&gt; 可以在 Markdown 的段落、列表或是标题里随意使用。依照个人习惯，甚至可以不用 Markdown 格式，而直接采用 HTML 标签来格式化。举例说明：如果比较喜欢 HTML 的 &lt;a&gt; 或 &lt;img&gt; 标签，可以直接使用这些标签，而不用 Markdown 提供的链接或是图像标签语法。 和处在 HTML 区块标签间不同，Markdown 语法在 HTML 区段标签间是有效的。 标题Markdown 支持两种标题的语法，类 Setext 和类 atx 形式。 类 Setext 形式是用底线的形式，利用 = （最高阶标题）和 - （第二阶标题），例如：12345This is an H1=============This is an H2------------- 任何数量的 = 和 - 都可以有效果。(大于等于2) 类 Atx 形式则是在行首插入 1 到 6 个 # ，对应到标题 1 到 6 阶，例如：12345# 这是 H1## 这是 H2###### 这是 H6 区块引用 BlockquotesMarkdown 标记区块引用是使用类似 email 中用 &gt; 的引用方式。如果你还熟悉在 email 信件中的引言部分，你就知道怎么在 Markdown 文件中建立一个区块引用，那会看起来像是你自己先断好行，然后在每行的最前面加上 &gt;： 123456&gt; This is a blockquote with two paragraphs. Lorem ipsum dolor sit amet,&gt; consectetuer adipiscing elit. Aliquam hendrerit mi posuere lectus.&gt; Vestibulum enim wisi, viverra nec, fringilla in, laoreet vitae, risus.&gt;&gt; Donec sit amet nisl. Aliquam semper ipsum sit amet velit. Suspendisse&gt; id sem consectetuer libero luctus adipiscing. Markdown 也允许你偷懒只在整个段落的第一行最前面加上 &gt; ：123456&gt; This is a blockquote with two paragraphs. Lorem ipsum dolor sit amet,consectetuer adipiscing elit. Aliquam hendrerit mi posuere lectus.Vestibulum enim wisi, viverra nec, fringilla in, laoreet vitae, risus.&gt; Donec sit amet nisl. Aliquam semper ipsum sit amet velit. Suspendisseid sem consectetuer libero luctus adipiscing. 区块引用可以嵌套（例如：引用内的引用），只要根据层次加上不同数量的 &gt; ：12345&gt; This is the first level of quoting.&gt;&gt; &gt; This is nested blockquote.&gt;&gt; Back to the first level. 引用的区块内也可以使用其他的 Markdown 语法，包括标题、列表、代码区块等：12345678&gt; ## 这是一个标题。&gt;&gt; 1. 这是第一行列表项。&gt; 2. 这是第二行列表项。&gt;&gt; 给出一些例子代码：&gt;&gt; return shell_exec(\"echo $input | $markdown_script\"); 列表Markdown 支持有序列表和无序列表。 无序列表使用星号、加号或是减号作为列表标记：123* Red* Green* Blue 等同于：123+ Red+ Green+ Blue 也等同于123- Red- Green- Blue 有序列表则使用数字接着一个英文句点：1231. Amy2. Bob3. John 代码区块和程序相关的写作或是标签语言原始码通常会有已经排版好的代码区块，通常这些区块我们并不希望它以一般段落文件的方式去排版，而是照原来的样子显示，Markdown 会用 &lt;pre&gt; 和 &lt;code&gt; 标签来把代码区块包起来。 要在 Markdown 中建立代码区块很简单，只要简单地缩进 4 个空格或是 1 个制表符就可以，例如，下面的输入： 123这是一个普通段落： 这是一个代码区块。 Markdown 会转换成： 1234&lt;p&gt;这是一个普通段落：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;这是一个代码区块。&lt;/code&gt;&lt;/pre&gt; 分隔线你可以在一行中用三个以上的星号、减号、底线来建立一个分隔线，行内不能有其他东西。你也可以在星号或是减号中间插入空格。下面每种写法都可以建立分隔线： 123456789* * *********- - ---------------------------------------- 链接Markdown 支持两种形式的链接语法： 行内式和参考式两种形式。 不管是哪一种，链接文字都是用 [方括号] 来标记。 要建立一个行内式的链接，只要在方块括号后面紧接着圆括号并插入网址链接即可，如果你还想要加上链接的 title 文字，只要在网址后面，用双引号把 title 文字包起来即可，例如： 123This is [an example](http://example.com/ \"Title\") inline link.[This link](http://example.net/) has no title attribute. 如果你是要链接到同样主机的资源，你可以使用相对路径： See my [About](/about/) page for details. 参考式的链接是在链接文字的括号后面再接上另一个方括号，而在第二个方括号里面要填入用以辨识链接的标记： This is [an example][id] reference-style link. 强调Markdown 使用星号（）和底线（_）作为标记强调字词的符号，被 或 _ 包围的字词会被转成用 标签包围，用两个 * 或 _ 包起来的话，则会被转成 ，例如： 1234567*single asterisks*_single underscores_**double asterisks**__double underscores__ 图片很明显地，要在纯文字应用中设计一个「自然」的语法来插入图片是有一定难度的。 Markdown 使用一种和链接很相似的语法来标记图片，同样也允许两种样式： 行内式和参考式。 行内式的图片语法看起来像是： ![Alt text](/path/to/img.jpg &quot;Optional title&quot;) 详细叙述如下： 一个惊叹号 ! 接着一个方括号，里面放上图片的替代文字 接着一个普通括号，里面放上图片的网址，最后还可以用引号包住并加上 选择性的 ‘title’ 文字。 参考式的图片语法则长得像这样： ![Alt text][id] ####其它 #####自动链接Markdown 支持以比较简短的自动链接形式来处理网址和电子邮件信箱，只要是用尖括号包起来， Markdown 就会自动把它转成链接。一般网址的链接文字就和链接地址一样，例如： &lt;http://example.com/&gt; Markdown 会转为： &lt;a href=&quot;http://example.com/&quot;&gt;http://example.com/&lt;/a&gt; 反斜杠Markdown 可以利用反斜杠来插入一些在语法中有其它意义的符号，例如：如果你想要用星号加在文字旁边的方式来做出强调效果（但不用 标签），你可以在星号的前面加上反斜杠：1\\*literal asterisks\\* Markdown 支持以下这些符号前面加上反斜杠来帮助插入普通的符号：123456789101112\\ 反斜线` 反引号* 星号_ 底线&#123;&#125; 花括号[] 方括号() 括弧# 井字号+ 加号- 减号. 英文句点! 惊叹号","tags":[{"name":"-markdown","slug":"markdown","permalink":"http://www.leqikeji.com/blog/tags/markdown/"}]},{"title":"实现双向绑定Proxy比defineproperty优劣","date":"2018-05-08T03:00:13.000Z","path":"2018/05/08/vue-proxy_defineproperty优劣/","text":"前言双向绑定其实已经是一个老掉牙的问题了,只要涉及到MVVM框架就不得不谈的知识点,但它毕竟是Vue的三要素之一. Vue三要素 响应式: 例如如何监听数据变化,其中的实现方法就是我们提到的双向绑定 模板引擎: 如何解析模板 渲染: Vue如何将监听到的数据变化和解析后的HTML进行渲染 可以实现双向绑定的方法有很多,KnockoutJS基于观察者模式的双向绑定,Ember基于数据模型的双向绑定,Angular基于脏检查的双向绑定,本篇文章我们重点讲面试中常见的基于数据劫持的双向绑定。常见的基于数据劫持的双向绑定有两种实现,一个是目前Vue在用的Object.defineProperty,另一个是ES2015中新增的Proxy,而Vue的作者宣称将在Vue3.0版本后加入Proxy从而代替Object.defineProperty,通过本文你也可以知道为什么Vue未来会选择Proxy。 严格来讲Proxy应该被称为『代理』而非『劫持』,不过由于作用有很多相似之处,我们在下文中就不再做区分,统一叫『劫持』。 我们可以通过下图清楚看到以上两种方法在双向绑定体系中的关系. 基于数据劫持的当然还有已经凉透的Object.observe方法,已被废弃。提前声明: 我们没有对传入的参数进行及时判断而规避错误,仅仅对核心方法进行了实现. 1.基于数据劫持实现的双向绑定的特点1.1 什么是数据劫持数据劫持比较好理解,通常我们利用Object.defineProperty劫持对象的访问器,在属性值发生变化时我们可以获取变化,从而进行进一步操作。12345678910111213141516171819202122232425262728293031323334// 这是将要被劫持的对象const data = &#123; name: '',&#125;;function say(name) &#123; if (name === '古天乐') &#123; console.log('给大家推荐一款超好玩的游戏'); &#125; else if (name === '渣渣辉') &#123; console.log('戏我演过很多,可游戏我只玩贪玩懒月'); &#125; else &#123; console.log('来做我的兄弟'); &#125;&#125;// 遍历对象,对其属性值进行劫持Object.keys(data).forEach(function(key) &#123; Object.defineProperty(data, key, &#123; enumerable: true, configurable: true, get: function() &#123; console.log('get'); &#125;, set: function(newVal) &#123; // 当属性值发生变化时我们可以进行额外操作 console.log(`大家好,我系$&#123;newVal&#125;`); say(newVal); &#125;, &#125;);&#125;);data.name = '渣渣辉';//大家好,我系渣渣辉//戏我演过很多,可游戏我只玩贪玩懒月 1.2 数据劫持的优势目前业界分为两个大的流派,一个是以React为首的单向数据绑定,另一个是以Angular、Vue为主的双向数据绑定。 其实三大框架都是既可以双向绑定也可以单向绑定,比如React可以手动绑定onChange和value实现双向绑定,也可以调用一些双向绑定库,Vue也加入了props这种单向流的api,不过都并非主流卖点。 单向或者双向的优劣不在我们的讨论范围,我们需要讨论一下对比其他双向绑定的实现方法,数据劫持的优势所在。 无需显示调用: 例如Vue运用数据劫持+发布订阅,直接可以通知变化并驱动视图,上面的例子也是比较简单的实现data.name = &#39;渣渣辉&#39;后直接触发变更,而比如Angular的脏检测则需要显示调用markForCheck(可以用zone.js避免显示调用,不展开),react需要显示调用setState。 可精确得知变化数据：还是上面的小例子，我们劫持了属性的setter,当属性值改变,我们可以精确获知变化的内容newVal,因此在这部分不需要额外的diff操作,否则我们只知道数据发生了变化而不知道具体哪些数据变化了,这个时候需要大量diff来找出变化值,这是额外性能损耗。 1.3 基于数据劫持双向绑定的实现思路数据劫持是双向绑定各种方案中比较流行的一种,最著名的实现就是Vue。 基于数据劫持的双向绑定离不开Proxy与Object.defineProperty等方法对对象/对象属性的”劫持”,我们要实现一个完整的双向绑定需要以下几个要点。 利用Proxy或Object.defineProperty生成的Observer针对对象/对象的属性进行”劫持”,在属性发生变化后通知订阅者 解析器Compile解析模板中的Directive(指令)，收集指令所依赖的方法和数据,等待数据变化然后进行渲染 Watcher属于Observer和Compile桥梁,它将接收到的Observer产生的数据变化,并根据Compile提供的指令进行视图渲染,使得数据变化促使视图变化 我们看到，虽然Vue运用了数据劫持，但是依然离不开发布订阅的模式，之所以在系列2做了Event Bus的实现,就是因为我们不管在学习一些框架的原理还是一些流行库（例如Redux、Vuex）,基本上都离不开发布订阅模式,而Event模块则是此模式的经典实现,所以如果不熟悉发布订阅模式,建议读一下系列2的文章。 2.基于Object.defineProperty双向绑定的特点关于Object.defineProperty的文章在网络上已经汗牛充栋,我们不想花过多时间在Object.defineProperty上面,本节我们主要讲解Object.defineProperty的特点,方便接下来与Proxy进行对比。 对Object.defineProperty还不了解的请阅读文档 两年前就有人写过基于Object.defineProperty实现的文章,想深入理解Object.defineProperty实现的推荐阅读,本文也做了相关参考。 上面我们推荐的文章为比较完整的实现(400行代码),我们在本节只提供一个极简版(20行)和一个简化版(150行)的实现,读者可以循序渐进地阅读。 2.1 极简版的双向绑定我们都知道,Object.defineProperty的作用就是劫持一个对象的属性,通常我们对属性的getter和setter方法进行劫持,在对象的属性发生变化时进行特定的操作。 我们就对对象obj的text属性进行劫持,在获取此属性的值时打印&#39;get val&#39;,在更改属性值的时候对DOM进行操作,这就是一个极简的双向绑定。 12345678910111213141516const obj = &#123;&#125;;Object.defineProperty(obj, 'text', &#123; get: function() &#123; console.log('get val');&amp;emsp; &#125;, set: function(newVal) &#123; console.log('set val:' + newVal); document.getElementById('input').value = newVal; document.getElementById('span').innerHTML = newVal; &#125;&#125;);const input = document.getElementById('input');input.addEventListener('keyup', function(e)&#123; obj.text = e.target.value;&#125;) 在线示例极简版双向绑定 2.2 升级改造我们很快会发现，这个所谓的双向绑定貌似并没有什么乱用。。。 原因如下: 我们只监听了一个属性,一个对象不可能只有一个属性,我们需要对对象每个属性进行监听。 违反开放封闭原则,我们如果了解开放封闭原则的话,上述代码是明显违反此原则,我们每次修改都需要进入方法内部,这是需要坚决杜绝的。 代码耦合严重,我们的数据、方法和DOM都是耦合在一起的，就是传说中的面条代码。 那么如何解决上述问题？ Vue的操作就是加入了发布订阅模式，结合Object.defineProperty的劫持能力，实现了可用性很高的双向绑定。 首先，我们以发布订阅的角度看我们第一部分写的那一坨代码,会发现它的监听、发布和订阅都是写在一起的,我们首先要做的就是解耦。 我们先实现一个订阅发布中心，即消息管理员（Dep）,它负责储存订阅者和消息的分发,不管是订阅者还是发布者都需要依赖于它。 123456789101112131415161718192021222324let uid = 0; // 用于储存订阅者并发布消息 class Dep &#123; constructor() &#123; // 设置id,用于区分新Watcher和只改变属性值后新产生的Watcher this.id = uid++; // 储存订阅者的数组 this.subs = []; &#125; // 触发target上的Watcher中的addDep方法,参数为dep的实例本身 depend() &#123; Dep.target.addDep(this); &#125; // 添加订阅者 addSub(sub) &#123; this.subs.push(sub); &#125; notify() &#123; // 通知所有的订阅者(Watcher)，触发订阅者的相应逻辑处理 this.subs.forEach(sub =&gt; sub.update()); &#125; &#125; // 为Dep类设置一个静态属性,默认为null,工作时指向当前的Watcher Dep.target = null; 现在我们需要实现监听者(Observer),用于监听属性值的变化。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950// 监听者,监听对象属性值的变化 class Observer &#123; constructor(value) &#123; this.value = value; this.walk(value); &#125; // 遍历属性值并监听 walk(value) &#123; Object.keys(value).forEach(key =&gt; this.convert(key, value[key])); &#125; // 执行监听的具体方法 convert(key, val) &#123; defineReactive(this.value, key, val); &#125; &#125; function defineReactive(obj, key, val) &#123; const dep = new Dep(); // 给当前属性的值添加监听 let chlidOb = observe(val); Object.defineProperty(obj, key, &#123; enumerable: true, configurable: true, get: () =&gt; &#123; // 如果Dep类存在target属性，将其添加到dep实例的subs数组中 // target指向一个Watcher实例，每个Watcher都是一个订阅者 // Watcher实例在实例化过程中，会读取data中的某个属性，从而触发当前get方法 if (Dep.target) &#123; dep.depend(); &#125; return val; &#125;, set: newVal =&gt; &#123; if (val === newVal) return; val = newVal; // 对新值进行监听 chlidOb = observe(newVal); // 通知所有订阅者，数值被改变了 dep.notify(); &#125;, &#125;); &#125; function observe(value) &#123; // 当值不存在，或者不是复杂数据类型时，不再需要继续深入监听 if (!value || typeof value !== 'object') &#123; return; &#125; return new Observer(value); &#125; 那么接下来就简单了,我们需要实现一个订阅者(Watcher)。12345678910111213141516171819202122232425262728293031323334353637class Watcher &#123; constructor(vm, expOrFn, cb) &#123; this.depIds = &#123;&#125;; // hash储存订阅者的id,避免重复的订阅者 this.vm = vm; // 被订阅的数据一定来自于当前Vue实例 this.cb = cb; // 当数据更新时想要做的事情 this.expOrFn = expOrFn; // 被订阅的数据 this.val = this.get(); // 维护更新之前的数据 &#125; // 对外暴露的接口，用于在订阅的数据被更新时，由订阅者管理员(Dep)调用 update() &#123; this.run(); &#125; addDep(dep) &#123; // 如果在depIds的hash中没有当前的id,可以判断是新Watcher,因此可以添加到dep的数组中储存 // 此判断是避免同id的Watcher被多次储存 if (!this.depIds.hasOwnProperty(dep.id)) &#123; dep.addSub(this); this.depIds[dep.id] = dep; &#125; &#125; run() &#123; const val = this.get(); console.log(val); if (val !== this.val) &#123; this.val = val; this.cb.call(this.vm, val); &#125; &#125; get() &#123; // 当前订阅者(Watcher)读取被订阅数据的最新更新后的值时，通知订阅者管理员收集当前订阅者 Dep.target = this; const val = this.vm._data[this.expOrFn]; // 置空，用于下一个Watcher使用 Dep.target = null; return val; &#125; &#125; 那么我们最后完成Vue,将上述方法挂载在Vue上。1234567891011121314151617181920212223242526class Vue &#123; constructor(options = &#123;&#125;) &#123; // 简化了$options的处理 this.$options = options; // 简化了对data的处理 let data = (this._data = this.$options.data); // 将所有data最外层属性代理到Vue实例上 Object.keys(data).forEach(key =&gt; this._proxy(key)); // 监听数据 observe(data); &#125; // 对外暴露调用订阅者的接口，内部主要在指令中使用订阅者 $watch(expOrFn, cb) &#123; new Watcher(this, expOrFn, cb); &#125; _proxy(key) &#123; Object.defineProperty(this, key, &#123; configurable: true, enumerable: true, get: () =&gt; this._data[key], set: val =&gt; &#123; this._data[key] = val; &#125;, &#125;); &#125; &#125; 看下效果：&emsp;&emsp;&emsp;&emsp; 在线示例双向绑定实现—无漏洞版 至此,一个简单的双向绑定算是被我们实现了。 2.3 Object.defineProperty的缺陷其实我们升级版的双向绑定依然存在漏洞,比如我们将属性值改为数组。123456789101112131415161718192021222324252627282930313233let demo = new Vue(&#123; data: &#123; list: [1], &#125;,&#125;);const list = document.getElementById('list');const btn = document.getElementById('btn');btn.addEventListener('click', function() &#123; demo.list.push(1);&#125;);const render = arr =&gt; &#123; const fragment = document.createDocumentFragment(); for (let i = 0; i &lt; arr.length; i++) &#123; const li = document.createElement('li'); li.textContent = arr[i]; fragment.appendChild(li); &#125; list.appendChild(fragment);&#125;;// 监听数组,每次数组变化则触发渲染函数,然而...无法监听demo.$watch('list', list =&gt; render(list));setTimeout( function() &#123; alert(demo.list); &#125;, 5000,); 在线示例 双向绑定-数组漏洞 是的,Object.defineProperty的第一个缺陷,无法监听数组变化。 然而Vue的文档提到了Vue是可以检测到数组变化的，但是只有以下八种方法,vm.items[indexOfItem] = newValue这种是无法检测的。 1234567push()pop()shift()unshift()splice()sort()reverse() 其实作者在这里用了一些奇技淫巧,把无法监听数组的情况hack掉了,以下是方法示例。12345678910111213141516171819202122232425262728const aryMethods = ['push', 'pop', 'shift', 'unshift', 'splice', 'sort', 'reverse'];const arrayAugmentations = [];aryMethods.forEach((method)=&gt; &#123; // 这里是原生Array的原型方法 let original = Array.prototype[method]; // 将push, pop等封装好的方法定义在对象arrayAugmentations的属性上 // 注意：是属性而非原型属性 arrayAugmentations[method] = function () &#123; console.log('我被改变啦!'); // 调用对应的原生方法并返回结果 return original.apply(this, arguments); &#125;;&#125;);let list = ['a', 'b', 'c'];// 将我们要监听的数组的原型指针指向上面定义的空数组对象// 别忘了这个空数组的属性上定义了我们封装好的push等方法list.__proto__ = arrayAugmentations;list.push('d'); // 我被改变啦！ 4// 这里的list2没有被重新定义原型指针，所以就正常输出let list2 = ['a', 'b', 'c'];list2.push('d'); // 4 由于只针对了八种方法进行了hack,所以其他数组的属性也是检测不到的,其中的坑很多,可以阅读上面提到的文档。 我们应该注意到在上文中的实现里,我们多次用遍历方法遍历对象的属性，这就引出了Object.defineProperty的第二个缺陷,只能劫持对象的属性,因此我们需要对每个对象的每个属性进行遍历，如果属性值也是对象那么需要深度遍历,显然能劫持一个完整的对象是更好的选择。 Object.keys(value).forEach(key =&gt; this.convert(key, value[key])); ####3.Proxy实现的双向绑定的特点Proxy在ES2015规范中被正式发布,它在目标对象之前架设一层“拦截”，外界对该对象的访问，都必须先通过这层拦截，因此提供了一种机制，可以对外界的访问进行过滤和改写,我们可以这样认为,Proxy是Object.defineProperty的全方位加强版,具体的文档可以查看此处; 3.1 Proxy可以直接监听对象而非属性我们还是以上文中用Object.defineProperty实现的极简版双向绑定为例,用Proxy进行改写。12345678910111213141516171819202122const input = document.getElementById('input');const p = document.getElementById('p');const obj = &#123;&#125;;const newObj = new Proxy(obj, &#123; get: function(target, key, receiver) &#123; console.log(`getting $&#123;key&#125;!`); return Reflect.get(target, key, receiver); &#125;, set: function(target, key, value, receiver) &#123; console.log(target, key, value, receiver); if (key === 'text') &#123; input.value = value; p.innerHTML = value; &#125; return Reflect.set(target, key, value, receiver); &#125;,&#125;);input.addEventListener('keyup', function(e) &#123; newObj.text = e.target.value;&#125;); 在线示例 Proxy版 我们可以看到,Proxy直接可以劫持整个对象,并返回一个新对象,不管是操作便利程度还是底层功能上都远强于Object.defineProperty。 3.2 Proxy可以直接监听数组的变化当我们对数组进行操作(push、shift、splice等)时，会触发对应的方法名称和length的变化，我们可以借此进行操作,以上文中Object.defineProperty无法生效的列表渲染为例。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950const list = document.getElementById('list');const btn = document.getElementById('btn');// 渲染列表const Render = &#123; // 初始化 init: function(arr) &#123; const fragment = document.createDocumentFragment(); for (let i = 0; i &lt; arr.length; i++) &#123; const li = document.createElement('li'); li.textContent = arr[i]; fragment.appendChild(li); &#125; list.appendChild(fragment); &#125;, // 我们只考虑了增加的情况,仅作为示例 change: function(val) &#123; const li = document.createElement('li'); li.textContent = val; list.appendChild(li); &#125;,&#125;;// 初始数组const arr = [1, 2, 3, 4];// 监听数组const newArr = new Proxy(arr, &#123; get: function(target, key, receiver) &#123; console.log(key); return Reflect.get(target, key, receiver); &#125;, set: function(target, key, value, receiver) &#123; console.log(target, key, value, receiver); if (key !== 'length') &#123; Render.change(value); &#125; return Reflect.set(target, key, value, receiver); &#125;,&#125;);// 初始化window.onload = function() &#123; Render.init(arr);&#125;// push数字btn.addEventListener('click', function() &#123; newArr.push(6);&#125;); 在线示例 Proxy列表渲染 很显然,Proxy不需要那么多hack（即使hack也无法完美实现监听）就可以无压力监听数组的变化,我们都知道,标准永远优先于hack。 3.3 Proxy的其他优势Proxy有多达13种拦截方法,不限于apply、ownKeys、deleteProperty、has等等是Object.defineProperty不具备的。 Proxy返回的是一个新对象,我们可以只操作新的对象达到目的,而Object.defineProperty只能遍历对象属性直接修改。 Proxy作为新标准将受到浏览器厂商重点持续的性能优化，也就是传说中的新标准的性能红利。 当然,Proxy的劣势就是兼容性问题,而且无法用polyfill磨平,因此Vue的作者才声明需要等到下个大版本(3.0)才能用Proxy重写。","tags":[{"name":"vue","slug":"vue","permalink":"http://www.leqikeji.com/blog/tags/vue/"},{"name":"proxy","slug":"proxy","permalink":"http://www.leqikeji.com/blog/tags/proxy/"},{"name":"defineproperty","slug":"defineproperty","permalink":"http://www.leqikeji.com/blog/tags/defineproperty/"}]},{"title":"前端路由的实现","date":"2018-05-05T08:57:51.000Z","path":"2018/05/05/js-实现路由/","text":"前言&emsp;&emsp;前端路由是现代SPA应用必备的功能,每个现代前端框架都有对应的实现,例如vue-router、react-router。 我们不想探究vue-router或者react-router们的实现，因为不管是哪种路由无外乎用兼容性更好的hash实现或者是H5 History实现，与框架几个只需要做相应的封装即可。 提前声明: 我们没有对传入的参数进行及时判断而规避错误,也没有考虑兼容性问题,仅仅对核心方法进行了实现. 1.hash路由hash路由一个明显的标志是带有#,我们主要是通过监听url中的hash变化来进行路由跳转。 hash的优势就是兼容性更好,在老版IE中都有运行,问题在于url中一直存在#不够美观,而且hash路由更像是Hack而非标准,相信随着发展更加标准化的History API会逐步蚕食掉hash路由的市场。 1.1 初始化class我们用Class关键字初始化一个路由.12345678class Routers &#123; constructor() &#123; // 以键值对的形式储存路由 this.routes = &#123;&#125;; // 当前路由的URL this.currentUrl = ''; &#125;&#125; 1.2 实现路由hash储存与执行在初始化完毕后我们需要思考两个问题: 将路由的hash以及对应的callback函数储存 触发路由hash变化后,执行对应的callback函数 1234567891011121314151617class Routers &#123; constructor() &#123; this.routes = &#123;&#125;; this.currentUrl = ''; &#125; // 将path路径与对应的callback函数储存 route(path, callback) &#123; this.routes[path] = callback || function() &#123;&#125;; &#125; // 刷新 refresh() &#123; // 获取当前URL中的hash路径 this.currentUrl = location.hash.slice(1) || '/'; // 执行当前hash路径的callback函数 this.routes[this.currentUrl](); &#125;&#125; 1.3 监听对应事件那么我们只需要在实例化Class的时候监听上面的事件即可.123456789101112131415161718class Routers &#123; constructor() &#123; this.routes = &#123;&#125;; this.currentUrl = ''; this.refresh = this.refresh.bind(this); window.addEventListener('load', this.refresh, false); window.addEventListener('hashchange', this.refresh, false); &#125; route(path, callback) &#123; this.routes[path] = callback || function() &#123;&#125;; &#125; refresh() &#123; this.currentUrl = location.hash.slice(1) || '/'; this.routes[this.currentUrl](); &#125;&#125; 2.增加回退功能上一节我们只实现了简单的路由功能,没有我们常用的回退与前进功能,所以我们需要进行改造。 2.1 实现后退功能我们在需要创建一个数组history来储存过往的hash路由例如/blue,并且创建一个指针currentIndex来随着后退和前进功能移动来指向不同的hash路由。12345678910111213141516171819202122232425262728293031323334353637383940class Routers &#123; constructor() &#123; // 储存hash与callback键值对 this.routes = &#123;&#125;; // 当前hash this.currentUrl = ''; // 记录出现过的hash this.history = []; // 作为指针,默认指向this.history的末尾,根据后退前进指向history中不同的hash this.currentIndex = this.history.length - 1; this.refresh = this.refresh.bind(this); this.backOff = this.backOff.bind(this); window.addEventListener('load', this.refresh, false); window.addEventListener('hashchange', this.refresh, false); &#125; route(path, callback) &#123; this.routes[path] = callback || function() &#123;&#125;; &#125; refresh() &#123; this.currentUrl = location.hash.slice(1) || '/'; // 将当前hash路由推入数组储存 this.history.push(this.currentUrl); // 指针向前移动 this.currentIndex++; this.routes[this.currentUrl](); &#125; // 后退功能 backOff() &#123; // 如果指针小于0的话就不存在对应hash路由了,因此锁定指针为0即可 this.currentIndex &lt;= 0 ? (this.currentIndex = 0) : (this.currentIndex = this.currentIndex - 1); // 随着后退,location.hash也应该随之变化 location.hash = `#$&#123;this.history[this.currentIndex]&#125;`; // 执行指针目前指向hash路由对应的callback this.routes[this.history[this.currentIndex]](); &#125;&#125; 我们看起来实现的不错,可是出现了Bug,在后退的时候我们往往需要点击两下。 问题在于,我们每次在后退都会执行相应的callback,这会触发refresh()执行,因此每次我们后退,history中都会被push新的路由hash,currentIndex也会向前移动,这显然不是我们想要的。 12345678refresh() &#123; this.currentUrl = location.hash.slice(1) || '/'; // 将当前hash路由推入数组储存 this.history.push(this.currentUrl); // 指针向前移动 this.currentIndex++; this.routes[this.currentUrl](); &#125; 2.2 完整实现hash Router我们必须做一个判断,如果是后退的话,我们只需要执行回调函数,不需要添加数组和移动指针。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849class Routers &#123; constructor() &#123; // 储存hash与callback键值对 this.routes = &#123;&#125;; // 当前hash this.currentUrl = ''; // 记录出现过的hash this.history = []; // 作为指针,默认指向this.history的末尾,根据后退前进指向history中不同的hash this.currentIndex = this.history.length - 1; this.refresh = this.refresh.bind(this); this.backOff = this.backOff.bind(this); // 默认不是后退操作 this.isBack = false; window.addEventListener('load', this.refresh, false); window.addEventListener('hashchange', this.refresh, false); &#125; route(path, callback) &#123; this.routes[path] = callback || function() &#123;&#125;; &#125; refresh() &#123; this.currentUrl = location.hash.slice(1) || '/'; if (!this.isBack) &#123; // 如果不是后退操作,且当前指针小于数组总长度,直接截取指针之前的部分储存下来 // 此操作来避免当点击后退按钮之后,再进行正常跳转,指针会停留在原地,而数组添加新hash路由 // 避免再次造成指针的不匹配,我们直接截取指针之前的数组 // 此操作同时与浏览器自带后退功能的行为保持一致 if (this.currentIndex &lt; this.history.length - 1) this.history = this.history.slice(0, this.currentIndex + 1); this.history.push(this.currentUrl); this.currentIndex++; &#125; this.routes[this.currentUrl](); console.log('指针:', this.currentIndex, 'history:', this.history); this.isBack = false; &#125; // 后退功能 backOff() &#123; // 后退操作设置为true this.isBack = true; this.currentIndex &lt;= 0 ? (this.currentIndex = 0) : (this.currentIndex = this.currentIndex - 1); location.hash = `#$&#123;this.history[this.currentIndex]&#125;`; this.routes[this.history[this.currentIndex]](); &#125;&#125; 前进的部分就不实现了,思路我们已经讲得比较清楚了,可以看出来,hash路由这种方式确实有点繁琐,所以HTML5标准提供了History API供我们使用。 3. HTML5新路由方案3.1 History API我们只简单看一下history常用的三个API.123window.history.back(); // 后退window.history.forward(); // 前进window.history.go(-3); // 后退三个页面 history.pushState用于在浏览历史中添加历史记录,但是并不触发跳转,此方法接受三个参数，依次为： state:一个与指定网址相关的状态对象，popstate事件触发时，该对象会传入回调函数。如果不需要这个对象，此处可以填null。title：新页面的标题，但是所有浏览器目前都忽略这个值，因此这里可以填null。url：新的网址，必须与当前页面处在同一个域。浏览器的地址栏将显示这个网址。 history.replaceState方法的参数与pushState方法一模一样，区别是它修改浏览历史中当前纪录,而非添加记录,同样不触发跳转。 popstate事件,每当同一个文档的浏览历史（即history对象）出现变化时，就会触发popstate事件。 需要注意的是，仅仅调用pushState方法或replaceState方法 ，并不会触发该事件，只有用户点击浏览器倒退按钮和前进按钮，或者使用 JavaScript 调用back、forward、go方法时才会触发。 另外，该事件只针对同一个文档，如果浏览历史的切换，导致加载不同的文档，该事件也不会触发。 3.2 新标准下路由的实现上一节我们介绍了新标准的History API,相比于我们在Hash 路由实现的那些操作,很显然新标准让我们的实现更加方便和可读。 所以一个mini路由实现起来其实很简单1234567891011121314151617181920212223242526272829class Routers &#123; constructor() &#123; this.routes = &#123;&#125;; // 在初始化时监听popstate事件 this._bindPopState(); &#125; // 初始化路由 init(path) &#123; history.replaceState(&#123;path: path&#125;, null, path); this.routes[path] &amp;&amp; this.routes[path](); &#125; // 将路径和对应回调函数加入hashMap储存 route(path, callback) &#123; this.routes[path] = callback || function() &#123;&#125;; &#125; // 触发路由对应回调 go(path) &#123; history.pushState(&#123;path: path&#125;, null, path); this.routes[path] &amp;&amp; this.routes[path](); &#125; // 监听popstate事件 _bindPopState() &#123; window.addEventListener('popstate', e =&gt; &#123; const path = e.state &amp;&amp; e.state.path; this.routes[path] &amp;&amp; this.routes[path](); &#125;); &#125;&#125; 点击查看H5路由 H5 Router 小结我们大致探究了前端路由的两种实现方法,在没有兼容性要求的情况下显然符合标准的History API实现的路由是更好的选择。 想更深入了解前端路由实现可以阅读vue-router代码，除去开发模式代码、注释和类型检测代码，核心代码并不多，适合阅读。","tags":[{"name":"route","slug":"route","permalink":"http://www.leqikeji.com/blog/tags/route/"}]},{"title":"Bus进行组件通信,你可以实现下吗?","date":"2018-04-23T08:19:11.000Z","path":"2018/04/23/vue-react-EventBus/","text":"前言本文标题的题目是由其他问题延伸而来,面试中面试官的常用套路,揪住一个问题一直深挖,在产生这个问题之前一定是这个问题. React/Vue不同组件之间是怎么通信的? Vue 父子组件用Props通信 非父子组件用Event Bus通信 如果项目够复杂,可能需要Vuex等全局状态管理库通信 $dispatch(已经废除)和$broadcast(已经废除) React 父子组件,父-&gt;子直接用Props,子-&gt;父用callback回调 非父子组件,用发布订阅模式的Event模块 项目复杂的话用Redux、Mobx等全局状态管理管库 用新的Context Api 我们大体上都会有以上回答,接下来很可能会问到如何实现Event(Bus),因为这个东西太重要了,几乎所有的模块通信都是基于类似的模式,包括安卓开发中的Event Bus,Node.js中的Event模块(Node中几乎所有的模块都依赖于Event,包括不限于http、stream、buffer、fs等). 我们仿照Node中Event API实现一个简单的Event库,他是发布订阅模式的典型应用. 提前声明: 我们没有对传入的参数进行及时判断而规避错误,仅仅对核心方法进行了实现. 1.基本构造1.1初始化class我们利用ES6的class关键字对Event进行初始化,包括Event的事件清单和监听者上限. 我们选择了Map作为储存事件的结构,因为作为键值对的储存方式Map比一般对象更加适合,我们操作起来也更加简洁,可以先看一下Map的基本用法与特点. 123456class EventEmeitter &#123; constructor() &#123; this._events = this._events || new Map(); // 储存事件/回调键值对 this._maxListeners = this._maxListeners || 10; // 设立监听上限 &#125;&#125; 1.2 监听与触发触发监听函数我们可以用apply与call两种方法,在少数参数时call的性能更好,多个参数时apply性能更好,当年Node的Event模块就在三个参数以下用call否则用apply. 当然当Node全面拥抱ES6+之后,相应的call/apply操作用Reflect新关键字重写了,但是我们不想写的那么复杂,就做了一个简化版. 1234567891011121314151617181920// 触发名为type的事件EventEmeitter.prototype.emit = function(type, ...args) &#123; let handler; // 从储存事件键值对的this._events中获取对应事件回调函数 handler = this._events.get(type); if (args.length &gt; 0) &#123; handler.apply(this, args); &#125; else &#123; handler.call(this); &#125; return true;&#125;;// 监听名为type的事件EventEmeitter.prototype.addListener = function(type, fn) &#123; // 将type事件以及对应的fn函数放入this._events中储存 if (!this._events.get(type)) &#123; this._events.set(type, fn); &#125;&#125;; 我们实现了触发事件的emit方法和监听事件的addListener方法,至此我们就可以进行简单的实践了. 12345678910// 实例化const emitter = new EventEmeitter();// 监听一个名为arson的事件对应一个回调函数emitter.addListener('arson', man =&gt; &#123; console.log(`expel $&#123;man&#125;`);&#125;);// 我们触发arson事件,发现回调成功执行emitter.emit('arson', 'low-end'); // expel low-end 似乎不错,我们实现了基本的触发/监听,但是如果有多个监听者呢?123456789// 重复监听同一个事件名emitter.addListener('arson', man =&gt; &#123; console.log(`expel $&#123;man&#125;`);&#125;);emitter.addListener('arson', man =&gt; &#123; console.log(`save $&#123;man&#125;`);&#125;);emitter.emit('arson', 'low-end'); // expel low-end 是的,只会触发第一个,因此我们需要进行改造. 2.升级改造2.1 监听/触发器升级我们的addListener实现方法还不够健全,在绑定第一个监听者之后,我们就无法对后续监听者进行绑定了,因此我们需要将后续监听者与第一个监听者函数放到一个数组里.123456789101112131415161718192021222324252627282930313233343536// 触发名为type的事件EventEmeitter.prototype.emit = function(type, ...args) &#123; let handler; handler = this._events.get(type); if (Array.isArray(handler)) &#123; // 如果是一个数组说明有多个监听者,需要依次此触发里面的函数 for (let i = 0; i &lt; handler.length; i++) &#123; if (args.length &gt; 0) &#123; handler[i].apply(this, args); &#125; else &#123; handler[i].call(this); &#125; &#125; &#125; else &#123; // 单个函数的情况我们直接触发即可 if (args.length &gt; 0) &#123; handler.apply(this, args); &#125; else &#123; handler.call(this); &#125; &#125; return true;&#125;;// 监听名为type的事件EventEmeitter.prototype.addListener = function(type, fn) &#123; const handler = this._events.get(type); // 获取对应事件名称的函数清单 if (!handler) &#123; this._events.set(type, fn); &#125; else if (handler &amp;&amp; typeof handler === 'function') &#123; // 如果handler是函数说明只有一个监听者 this._events.set(type, [handler, fn]); // 多个监听者我们需要用数组储存 &#125; else &#123; handler.push(fn); // 已经有多个监听者,那么直接往数组里push函数即可 &#125;&#125;; 是的,从此以后可以愉快的触发多个监听者的函数了.1234567891011121314151617// 监听同一个事件名emitter.addListener('arson', man =&gt; &#123; console.log(`expel $&#123;man&#125;`);&#125;);emitter.addListener('arson', man =&gt; &#123; console.log(`save $&#123;man&#125;`);&#125;);emitter.addListener('arson', man =&gt; &#123; console.log(`kill $&#123;man&#125;`);&#125;);// 触发事件emitter.emit('arson', 'low-end');//expel low-end//save low-end//kill low-end 2.2 移除监听我们会用removeListener函数移除监听函数,但是匿名函数是无法移除的.1234567891011121314151617181920212223242526272829EventEmeitter.prototype.removeListener = function(type, fn) &#123; const handler = this._events.get(type); // 获取对应事件名称的函数清单 // 如果是函数,说明只被监听了一次 if (handler &amp;&amp; typeof handler === 'function') &#123; this._events.delete(type, fn); &#125; else &#123; let postion; // 如果handler是数组,说明被监听多次要找到对应的函数 for (let i = 0; i &lt; handler.length; i++) &#123; if (handler[i] === fn) &#123; postion = i; &#125; else &#123; postion = -1; &#125; &#125; // 如果找到匹配的函数,从数组中清除 if (postion !== -1) &#123; // 找到数组对应的位置,直接清除此回调 handler.splice(postion, 1); // 如果清除后只有一个函数,那么取消数组,以函数形式保存 if (handler.length === 1) &#123; this._events.set(type, handler[0]); &#125; &#125; else &#123; return this; &#125; &#125;&#125;; 3.发现问题我们已经基本完成了Event最重要的几个方法,也完成了升级改造,可以说一个Event的骨架是被我们开发出来了,但是它仍然有不足和需要补充的地方. 1.我们没有对参数进行充分的判断,没有完善的报错机制.2.模拟不够充分: 除了removeAllListeners这些方法没有实现以外,例如监听时间后会触发newListener事件,我们也没有实现,另外最开始的监听者上限我们也没有利用到. 当然,这在面试中现场写一个Event已经是很够意思了,主要是体现出来对发布-订阅模式的理解,以及针对多个监听状况下的处理,不可能现场撸几百行写一个完整Event. 索性Event库帮我们实现了完整的特性,整个代码量有300多行,很适合阅读,你可以花十分钟的时间通读一下,见识一下完整的Event实现.","tags":[{"name":"Event Bus","slug":"Event-Bus","permalink":"http://www.leqikeji.com/blog/tags/Event-Bus/"}]},{"title":"请你实现一个深克隆","date":"2018-04-07T08:13:25.000Z","path":"2018/04/07/js-clone/","text":"前言&emsp;&emsp;实现一个深克隆是面试中常见的问题的,可是绝大多数面试者的答案都是不完整的,甚至是错误的,这个时候面试官会不断追问,看看你到底理解不理解深克隆的原理,很多情况下一些一知半解的面试者就原形毕漏了.我们就来看一下如何实现一个深克隆,当然面试中没有让你完整实现的时候,但是你一定要搞清楚其中的坑在哪里,才可以轻松应对面试官的追问. 在要实现一个深克隆之前我们需要了解一下javascript中的基础类型. javascript基础类型 JavaScript原始类型:Undefined、Null、Boolean、Number、String、Symbol JavaScript引用类型:Object 1.浅克隆&emsp;&emsp;浅克隆之所以被称为浅克隆，是因为对象只会被克隆最外部的一层,至于更深层的对象,则依然是通过引用指向同一块堆内存. 123456789101112131415161718// 浅克隆函数function shallowClone(o) &#123; const obj = &#123;&#125;; for ( let i in o) &#123; obj[i] = o[i]; &#125; return obj;&#125;// 被克隆对象const oldObj = &#123; a: 1, b: [ 'e', 'f', 'g' ], c: &#123; h: &#123; i: 2 &#125; &#125;&#125;;const newObj = shallowClone(oldObj);console.log(newObj.c.h, oldObj.c.h); // &#123; i: 2 &#125; &#123; i: 2 &#125;console.log(oldObj.c.h === newObj.c.h); // true 我们可以看到,很明显虽然oldObj.c.h被克隆了,但是它还与oldObj.c.h相等,这表明他们依然指向同一段堆内存,这就造成了如果对newObj.c.h进行修改,也会影响oldObj.c.h,这就不是一版好的克隆. 12newObj.c.h.i = 'change';console.log(newObj.c.h, oldObj.c.h); // &#123; i: 'change' &#125; &#123; i: 'change' &#125; 我们改变了newObj.c.h.i的值,oldObj.c.h.i也被改变了,这就是浅克隆的问题所在. 当然有一个新的apiObject.assign()也可以实现浅复制,但是效果跟上面没有差别,所以我们不再细说了. 2.深克隆2.1 JSON.parse方法&emsp;&emsp;前几年微博上流传着一个传说中最便捷实现深克隆的方法, JSON对象parse方法可以将JSON字符串反序列化成JS对象，stringify方法可以将JS对象序列化成JSON字符串,这两个方法结合起来就能产生一个便捷的深克隆. const newObj = JSON.parse(JSON.stringify(oldObj)); 我们依然用上一节的例子进行测试 1234567891011const oldObj = &#123; a: 1, b: [ 'e', 'f', 'g' ], c: &#123; h: &#123; i: 2 &#125; &#125;&#125;;const newObj = JSON.parse(JSON.stringify(oldObj));console.log(newObj.c.h, oldObj.c.h); // &#123; i: 2 &#125; &#123; i: 2 &#125;console.log(oldObj.c.h === newObj.c.h); // falsenewObj.c.h.i = 'change';console.log(newObj.c.h, oldObj.c.h); // &#123; i: 'change' &#125; &#123; i: 2 &#125; 果然,这是一个实现深克隆的好方法,但是这个解决办法是不是太过简单了. 确实,这个方法虽然可以解决绝大部分是使用场景,但是却有很多坑. 1.他无法实现对函数 、RegExp等特殊对象的克隆 2.会抛弃对象的constructor,所有的构造函数会指向Object 3.对象有循环引用,会报错 主要的坑就是以上几点,我们一一测试下.1234567891011121314151617181920212223242526272829// 构造函数function person(pname) &#123; this.name = pname;&#125;const Messi = new person('Messi');// 函数function say() &#123; console.log('hi');&#125;;const oldObj = &#123; a: say, b: new Array(1), c: new RegExp('ab+c', 'i'), d: Messi&#125;;const newObj = JSON.parse(JSON.stringify(oldObj));// 无法复制函数console.log(newObj.a, oldObj.a); // undefined [Function: say]// 稀疏数组复制错误console.log(newObj.b[0], oldObj.b[0]); // null undefined// 无法复制正则对象console.log(newObj.c, oldObj.c); // &#123;&#125; /ab+c/i// 构造函数指向错误console.log(newObj.d.constructor, oldObj.d.constructor); // [Function: Object] [Function: person] 我们可以看到在对函数、正则对象、稀疏数组等对象克隆时会发生意外，构造函数指向也会发生错误。123456const oldObj = &#123;&#125;;oldObj.a = oldObj;const newObj = JSON.parse(JSON.stringify(oldObj));console.log(newObj.a, oldObj.a); // TypeError: Converting circular structure to JSON 对象的循环引用会抛出错误. 2.2 构造一个深克隆函数我们知道要想实现一个靠谱的深克隆方法,上一节提到的序列/反序列是不可能了,而通常教程里提到的方法也是不靠谱的,他们存在的问题跟上一届序列反序列操作中凸显的问题是一致的.12345678910111213141516function isArray(arr)&#123; return Object.prototype.toString.call(arr) == '[object Array]'&#125;//深度克隆function deepClone(obj)&#123; if(typeof obj !== 'object' &amp;&amp; typeof obj !== 'function')&#123; return obj; //原始类型直接返回 &#125; var o = isArray(obj) ? [] : &#123;&#125;; for(i in obj)&#123; if(obj.hasOwnProperty(i))&#123; o[i] = typeof[i] === 'object' ? deepClone(obj[i]) : obj[i]; &#125; &#125; return o;&#125; (这个方法也会出现上一节提到的问题) 由于要面对不同的对象(正则、数组、Date等)要采用不同的处理方式，我们需要实现一个对象类型判断函数。 12345678910111213141516171819const isType = (obj, type) =&gt; &#123; if (typeof obj !== 'object') return false; const typeString = Object.prototype.toString.call(obj); let flag; switch (type) &#123; case 'Array': flag = typeString === '[object Array]'; break; case 'Date': flag = typeString === '[object Date]'; break; case 'RegExp': flag = typeString === '[object RegExp]'; break; default: flag = false; &#125; return flag;&#125;; 这样我们就可以对特殊对象进行类型判断了,从而采用针对性的克隆策略.123const arr = Array.of(3, 4, 5, 2);console.log(isType(arr, 'Array')); // true 对于正则对象,我们在处理之前要先补充一点新知识. 我们需要通过正则的扩展了解到flags属性等等,因此我们需要实现一个提取flags的函数.1234567const getRegExp = re =&gt; &#123; var flags = ''; if (re.global) flags += 'g'; if (re.ignoreCase) flags += 'i'; if (re.multiline) flags += 'm'; return flags;&#125;; 做好了这些准备工作,我们就可以进行深克隆的实现了.12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152/*** deep clone* @param &#123;[type]&#125; parent object 需要进行克隆的对象* @return &#123;[type]&#125; 深克隆后的对象*/const clone = parent =&gt; &#123; // 维护两个储存循环引用的数组 const parents = []; const children = []; const _clone = parent =&gt; &#123; if (parent === null) return null; if (typeof parent !== 'object') return parent; let child, proto; if (isType(parent, 'Array')) &#123; // 对数组做特殊处理 child = []; &#125; else if (isType(parent, 'RegExp')) &#123; // 对正则对象做特殊处理 child = new RegExp(parent.source, getRegExp(parent)); if (parent.lastIndex) child.lastIndex = parent.lastIndex; &#125; else if (isType(parent, 'Date')) &#123; // 对Date对象做特殊处理 child = new Date(parent.getTime()); &#125; else &#123; // 处理对象原型 proto = Object.getPrototypeOf(parent); // 利用Object.create切断原型链 child = Object.create(proto); &#125; // 处理循环引用 const index = parents.indexOf(parent); if (index != -1) &#123; // 如果父数组存在本对象,说明之前已经被引用过,直接返回此对象 return children[index]; &#125; parents.push(parent); children.push(child); for (let i in parent) &#123; // 递归 child[i] = _clone(parent[i]); &#125; return child; &#125;; return _clone(parent);&#125;; 我们做一下测试123456789101112131415161718192021222324function person(pname) &#123; this.name = pname;&#125;const Messi = new person('Messi');function say() &#123; console.log('hi');&#125;const oldObj = &#123; a: say, c: new RegExp('ab+c', 'i'), d: Messi,&#125;;oldObj.b = oldObj;const newObj = clone(oldObj);console.log(newObj.a, oldObj.a); // [Function: say] [Function: say]console.log(newObj.b, oldObj.b); // &#123; a: [Function: say], c: /ab+c/i, d: person &#123; name: 'Messi' &#125;, b: [Circular] &#125; &#123; a: [Function: say], c: /ab+c/i, d: person &#123; name: 'Messi' &#125;, b: [Circular] &#125;console.log(newObj.c, oldObj.c); // /ab+c/i /ab+c/iconsole.log(newObj.d.constructor, oldObj.d.constructor); // [Function: person] [Function: person] 当然,我们这个深克隆还不算完美,例如Buffer对象、Promise、Set、Map可能都需要我们做特殊处理，另外对于确保没有循环引用的对象，我们可以省去对循环引用的特殊处理，因为这很消耗时间，不过一个基本的深克隆函数我们已经实现了。 总结实现一个完整的深克隆是由许多坑要踩的,npm上一些库的实现也不够完整,在生产环境中最好用lodash的深克隆实现.在面试过程中,我们上面提到的众多坑是面试官很可能追问你的,要知道坑在哪里,能答出来才是你的加分项,在面试过程中必须要有一两个闪光点,如果只知道序列/反序列这种投机取巧的方法,在追问下不仅拿不到分,很可能造成只懂个皮毛的印象,毕竟,面试面得就是你知识的深度.","tags":[{"name":"javascript深克隆","slug":"javascript深克隆","permalink":"http://www.leqikeji.com/blog/tags/javascript深克隆/"}]},{"title":"你可能真的不懂JavaScript中最基础类型","date":"2018-03-06T06:11:42.000Z","path":"2018/03/06/js-dataType/","text":"前言 众所周知,JavaScript是动态弱类型的多范式编程语言,由于设计时的粗糙(当时设计js的初衷就是在浏览器中处理表单这种简单事件)导致JavaScript在许多方面表现出了这样或者那样的问题,其中’类型’便是语法层面最常见的’埋坑’重灾区. JavaScript原始类型:Undefined、Null、Boolean、Number、String、Symbol JavaScript引用类型:Object 1.原始类型与引用类型1.1&emsp;&emsp;原始类型又被称为引用类型，原始类型保存的变量和值直接保存在栈内存(Stack)中,且空间相互独立,通过值来访问,说到这里肯定一同懵逼,不过我们可以通过一个例子来解释.12var person = 'Messi';var person1 = person; 上述代码在栈内存的示意图是这样的,可以看到,虽然person赋值给了person1.但是两个变量并没有指向同一个值,而是person1自己单独建立一个内存空间,虽然两个变量的值相等,但却是相互独立的. personMessiperson1Messi 1234567var person = 'Messi';var person1 = person;var person = 1;console.log(person); //1console.log(person1); //'Messi' 上述代码示意图是这样的,person的值虽然改变,但是由于person1的值是独立储存的,因此不受影响. 值得一提的是,虽然原始类型的值是储存在相对独立空间,但是它们之间的比较是按值比较的.123var person = 'Messi';var person1 = 'Messi';console.log(person === person1); //true 1.2引用类型剩下的就是引用类型了,即Object 类型,再往下细分，还可以分为：Object 类型、Array 类型、Date 类型、Function 类型 等。 与原始类型不同的是,引用类型的内容是保存在堆内存中,而栈内存(Heap)中会有一个堆内存地址,通过这个地址变量被指向堆内存中Object真正的值,因此引用类型是按照引用访问的. 下例能很清楚的说明引用类型的特质.123456789101112var a = &#123;name:\"percy\"&#125;;var b;b = a;a.name = \"zyj\";console.log(b.name); // zyjb.age = 22;console.log(a.age); // 22var c = &#123; name: \"zyj\", age: 22&#125;;console.log(a === c); //false 我们可以逐行分析:1.b = a,如果是原始类型的话,b会在栈内自己独自创建一个内存空间保存值,但是引用类型只是b的产生一个对内存地址,指向堆内存中的Object.2.a.name = &quot;zyj&quot;,这个操作属于改变了变量的值,在原始类型中会重新建立新的内存空间(可以看上一节的示意图),而引用类型只需要自己在堆内存中更新自己的属性即可.3.最后创建了一个新的对象c,看似跟b a一样,但是在堆内存中确实两个相互独立的Object,引用类型是按照引用比较,由于a c引用的是不同的Object所以得到的结果是fasle. 2. 类型中的坑2.1数组是JavaScript中最常见的类型之一了,但是在我们实践过程中同样会遇到各种各样的麻烦. 稀疏数组:指的是含有空白或空缺单元的数组12345678910111213var a = [];console.log(a.length); //0a[4] = a[5];console.log(a.length); //5a.forEach(elem =&gt; &#123; console.log(elem); //undefined&#125;);console.log(a); //[,,,,undefined] 这里有几个坑需要注意: 1.一开始建立的空数组a的长度为0,这可以理解,但是在a[4] = a[5]之后出现了问题,a的长度居然变成了5,此时a数组是[,,,,undefined]这种形态. 2.我们通过遍历,只得到了undefined这一个值,这个undefind是由于a[4] = a[5]赋值,由于a[5]没有定义值为undefined被赋给了a[4],可以等价为a[4] = undefined. 字符串索引123456var a = [];a[0] = 'Bale';a['age'] = 28;console.log(a.length); //1console.log(a['age']); //28console.log(a); //[ 'Bale', age: 28 ] 数组不仅可以通过数字索引,也可以通过字符串索引,但值得注意的是,字符串索引的键值对并不算在数组的长度里. 2.2 二进制浮点数JavaScript 中的数字类型是基于“二进制浮点数”实现的,使用的是“双精度”格式,这就带来了一些反常的问题,我们那一道经典面试提来讲解下.123var a = 0.1 + 0.2;var b = 0.3;console.log(a === b); //false 这是个出人意料的结果,实际上a的值约为0.30000000000000004这并不是一个整数值,这就是二进制浮点数带来的副作用.123456var a = 0.1 + 0.2;var b = 0.3;console.log(a === b); //falseconsole.log(Number.isInteger(a*10)); //falseconsole.log(Number.isInteger(b*10)); //trueconsole.log(a); //0.30000000000000004 我们可以用Number.isInteger()来判断一个数字是否为整数. NaN1234var a = 1/new Object();console.log(typeof a); //Numberconsole.log(a); //NaNconsole.log(isNaN(a)); //true NaN属于特殊的Number类型,我们可以把它理解为坏数值,因为它属于数值计算中的错误,更加特殊的是它自己都不等价于自己NaN === NaN //false,我们只能用isNaN()来检测一个数字是否为NaN. 3.类型转换原理类型转换指的是将一种类型转换为另一种类型,例如:123var b = 2;var a = String(b);console.log(typeof a); //string 当然,类型转换分为显式和隐式,但是不管是隐式转换还是显式转换,都会遵循一定的原理,由于JavaScript是一门动态类型的语言,可以随时赋予任意值,但是各种运算符或条件判断中是需要特定类型的,因此JavaScript引擎会在运算时为变量设定类型. 这看起来很美好,JavaScript引擎帮我们搞定了类型的问题,但是引擎毕竟不是ASI(超级人工智能),它的很多动作会跟我们预期相去甚远,我们可以从一道面试题开始. {}+[] //0 答案是0 是什么原因造成了上述结果呢?那么我们得从ECMA-262中提到的转换规则和抽象操作说起,有兴趣的童鞋可以仔细阅读下这浩如烟海的语言规范,如果没这个耐心还是往下看. 这是JavaScript种类型转换可以从原始类型转为引用类型,同样可以将引用类型转为原始类型,转为原始类型的抽象操作为ToPrimitive,而后续更加细分的操作为:ToNumber ToString ToBoolean,这三种抽象操作的转换表如下所示 如果想应付面试,我觉得这张表就差不多了,但是为了更深入的探究JavaScript引擎是如何处理代码中类型转换问题的,就需要看 ECMA-262详细的规范,从而探究其内部原理,我们从这段内部原理示意代码开始. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647// ECMA-262, section 9.1, page 30. Use null/undefined for no hint,// (1) for number hint, and (2) for string hint.function ToPrimitive(x, hint) &#123; // Fast case check. if (IS_STRING(x)) return x; // Normal behavior. if (!IS_SPEC_OBJECT(x)) return x; if (IS_SYMBOL_WRAPPER(x)) throw MakeTypeError(kSymbolToPrimitive); if (hint == NO_HINT) hint = (IS_DATE(x)) ? STRING_HINT : NUMBER_HINT; return (hint == NUMBER_HINT) ? DefaultNumber(x) : DefaultString(x);&#125;// ECMA-262, section 8.6.2.6, page 28.function DefaultNumber(x) &#123; if (!IS_SYMBOL_WRAPPER(x)) &#123; var valueOf = x.valueOf; if (IS_SPEC_FUNCTION(valueOf)) &#123; var v = %_CallFunction(x, valueOf); if (IsPrimitive(v)) return v; &#125; var toString = x.toString; if (IS_SPEC_FUNCTION(toString)) &#123; var s = %_CallFunction(x, toString); if (IsPrimitive(s)) return s; &#125; &#125; throw MakeTypeError(kCannotConvertToPrimitive);&#125;// ECMA-262, section 8.6.2.6, page 28.function DefaultString(x) &#123; if (!IS_SYMBOL_WRAPPER(x)) &#123; var toString = x.toString; if (IS_SPEC_FUNCTION(toString)) &#123; var s = %_CallFunction(x, toString); if (IsPrimitive(s)) return s; &#125; var valueOf = x.valueOf; if (IS_SPEC_FUNCTION(valueOf)) &#123; var v = %_CallFunction(x, valueOf); if (IsPrimitive(v)) return v; &#125; &#125; throw MakeTypeError(kCannotConvertToPrimitive);&#125; 上面代码的逻辑是这样的： 如果变量为字符串，直接返回. 如果!IS_SPEC_OBJECT(x)，直接返回. 如果IS_SYMBOL_WRAPPER(x)，则抛出异常. 否则会根据传入的hint来调用DefaultNumber和DefaultString，比如如果为Date对象，会调用DefaultString. DefaultNumber：首先x.valueOf，如果为primitive，则返回valueOf后的值，否则继续调用x.toString，如果为primitive，则返回toString后的值，否则抛出异常 DefaultString：和DefaultNumber正好相反，先调用toString，如果不是primitive再调用valueOf. 那讲了实现原理，这个ToPrimitive有什么用呢？实际很多操作会调用ToPrimitive，比如加、相等或比较操。在进行加操作时会将左右操作数转换为primitive，然后进行相加。 下面来个实例，({}) + 1（将{}放在括号中是为了内核将其认为一个代码块）会输出啥？可能日常写代码并不会这样写，不过网上出过类似的面试题。 加操作只有左右运算符同时为String或Number时会执行对应的%_StringAdd或%NumberAdd，下面看下({}) + 1内部会经过哪些步骤： {}和1首先会调用ToPrimitive {}会走到DefaultNumber，首先会调用valueOf，返回的是Object {}，不是primitive类型，从而继续走到toString，返回[object Object]，是String类型 最后加操作，结果为[object Object]1 再比如有人问你[] + 1输出啥时，你可能知道应该怎么去计算了，先对[]调用ToPrimitive，返回空字符串，最后结果为&quot;1&quot;。","tags":[{"name":"javascript数据类型","slug":"javascript数据类型","permalink":"http://www.leqikeji.com/blog/tags/javascript数据类型/"}]},{"title":"好用的Web包管理器-Bower","date":"2017-12-03T08:38:54.000Z","path":"2017/12/03/Bower/","text":"Bower是twitter推出的客户端包管理工具，用于命令行操作包的搜索、下载、更新、卸载(如jQuery、Bootstrap、JavaScript、HTML、CSS之类的网络资源)。Bower对包结构没有强制规范，可以很方便获取各种Web模块文件，但bower本身不存储模块文件和模块版本信息，模块发布者通过register方式将模块可访问的公开的git地址记录在bower的数据库中，而所有版本都是通过代码库的tag来决定的。 开始之前在安装bower之前，必须确认你已经安装了Node.js和Git。 1.安装Bower使用npm，打开终端，键入：1npm install -g bower #全局安装bower 移步这里查看不同平台上安装的问题。 2.使用Bower使用help命令查看帮助。123456789101112131415161718192021222324252627282930313233bower helpUsage: bower &lt;command&gt; [&lt;args&gt;] [&lt;options&gt;]Commands: cache Manage bower cache help Display help information about Bower home Opens a package homepage into your favorite browser info Info of a particular package init Interactively create a bower.json file install Install a package locally link Symlink a package folder list List local packages - and possible updates login Authenticate with GitHub and store credentials lookup Look up a package URL by name prune Removes local extraneous packages register Register a package search Search for a package by name update Update a local package uninstall Remove a local package unregister Remove a package from the registry version Bump a package versionOptions: -f, --force Makes various commands more forceful -j, --json Output consumable JSON -l, --loglevel What level of logs to report -o, --offline Do not hit the network -q, --quiet Only output important information -s, --silent Do not output anything, besides errors -V, --verbose Makes output more verbose --allow-root Allows running commands as root -v, --version Output Bower version --no-color Disable colorsSee 'bower help &lt;command&gt;' for more information on a specific command. 3.安装包到本地通过命令bower install安装软件包默认到bower_components/目录。1bower install &lt;package&gt; #package为包名 想要下载的包可以是GitHub上的短链接（如jquery/jquery）、.git 、一个URL或者其它。 12345bower install # 通过 bower.json 文件安装bower install jquery # 通过在github上注册的包名安装bower install desandro/masonry # GitHub短链接bower install git://github.com/user/package.git # Github上的 .gitbower install http://example.com/script.js # URL 安装选项12345-F, --force-latest: Force latest version on conflict-p, --production: Do not install project devDependencies-S, --save: Save installed packages into the project’s bower.json dependencies-D, --save-dev: Save installed packages into the project’s bower.json devDependencies-E, --save-exact: Configure installed packages with an exact version rather than semver 4.用bower.json文件来管理依赖发布项目的时候没有必要把所有依赖的库发布上去，只需在根目录生成一个bower.json文件即可，别人使用时在根目录执行bower install就可根据bower.json来安装依赖的包。在项目中执行1bower init 会提示你输入一些基本信息，根据提示按回车或者空格即可，然后会生成一个bower.json文件，用来保存该项目的配置.如果想保存依赖信息(dependencies)到你的bower.json文件，安装包时，命令后面跟上–save即可。 5.使用下载好的包对于已经下载下来的包，默认在当前目录的bower_components文件夹。你可以直接在项目里引用。例如： 12&lt;link rel=\"stylesheet\" href=\"bower_components/bootstrap/dist/css/bootstrap.min.css\"&gt;&lt;script type=\"text/javascript\" src=\"bower_components/jquery/dist/jquery.min.js\"&gt;&lt;/script&gt; 6.更新包若下载的包升级了，只需执行update命令即可更新，例如：1bower update jquery 这样就可以自动升级到最新版的jquery了。更新选项 1234-F, --force-latest: Force latest version on conflict-p, --production: Do not install project devDependencies-S, --save: Update dependencies in bower.json-D, --save-dev: Update devDependencies in bower.json 7.搜索包12bower search #搜索所有包bower search &lt;packageName&gt; #搜索指定名称的包 或者可以在这里搜索喜欢的包. 8.卸载包1bower uninstall &lt;name&gt; [&lt;name&gt; ..] [&lt;options&gt;] 卸载选项12-S, --save: Remove uninstalled packages from the project’s bower.json dependencies-D, --save-dev: Remove uninstalled packages from the project’s bower.json devDependencies","tags":[{"name":"Bower","slug":"Bower","permalink":"http://www.leqikeji.com/blog/tags/Bower/"}]},{"title":"Git基本操作","date":"2017-11-07T14:38:50.000Z","path":"2017/11/07/git-usage/","text":"版本移动回退到上个版本 git reset –hard HEAD^ 前进到之后版本（可以找到commit id） git reset –hard [commit id ] 前进到之后版本（找不到commit id） git reflog git reset –hard [commit id ] 撤销更改未保存至暂存区或恢复到暂存区时的状态 git checkout – [file] 已保存至暂存区 git reset HEAD [file] (取消暂存区存储) git checkout [file] 删除文件从版本库中删除文件 git rm [file] git commit -m “remove file” 找回文件 git checkout – [file] 分支操作创建分支 git checkout -b [branch name] 或 git branch [branch name] git checkout [branch name] 查看分支 git branch 切换分支 git checkout [branch name] 合并分支 git merge [branch name] 删除分支 git branch -d [branch name]","tags":[{"name":"git","slug":"git","permalink":"http://www.leqikeji.com/blog/tags/git/"}]},{"title":"js原生拖拽","date":"2017-08-16T05:58:37.000Z","path":"2017/08/16/js-drag/","text":"原理 鼠标按下：状态=1；记录鼠标的X和Y坐标；记录元素的X和Y偏移值 鼠标在元素上移动：若状态=0，什么也不做；若状态为1，元素的新X的偏移量 = X2-X1+X(鼠标按下时的元素偏移)，新Y偏移量 = Y2-Y1+Y 鼠标放开，状态=0 在线预览See the Pen oLVgvp by abcdGJJ (@abcdGJJ) on CodePen. 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556var state = false;var obj, objLeft, objTop, posX, posY,wrap;window.onload = function() &#123; obj = document.getElementById('drop'); wrap = document.getElementById('wrap'); obj.onmousedown = down; obj.onmousemove = move; obj.onmouseup = up;&#125;function down(e) &#123; obj.style.cursor = \"move\"; state = true; objLeft = obj.offsetLeft;//obj左上角距离父节点左边距偏移像素值 objTop = obj.offsetTop; posX = parseInt(getPostion(e).x);//鼠标位置 posY = parseInt(getPostion(e).y);&#125;function move(e) &#123; if(state == true) &#123; var x = parseInt(getPostion(e).x - posX + objLeft); var y = parseInt(getPostion(e).y - posY +objTop); var w = parseInt(wrap.clientWidth - obj.offsetWidth); var h = parseInt(wrap.clientHeight - obj.offsetHeight); // console.log(x,y); if(x &lt; 0) &#123; x = 0; &#125; else if(x &gt; w) &#123; x = w; &#125; if(y &lt; 0) &#123; y = 0; &#125; else if(y &gt; h) &#123; y = h; &#125; obj.style.left = x + 'px'; obj.style.top = y +'px'; &#125;&#125;function up() &#123; state = false;&#125;function getPostion(e) &#123; var xpos, ypos; e = e || window.event;//浏览器兼容 if(e.pageX) &#123; xpos = e.pageX; ypos = e.pageY; &#125; else &#123; xpos = e.clientX + document.body.scrollLeft - document.body.clientLeft; ypos = e.clientY + document.body.scrollTop - document.body.clientTop; &#125; return &#123; x: xpos, y: ypos &#125;&#125; 面向对象版本版本：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172function Drag(config) &#123; this.target = document.getElementById(config.id) this.state = false if (config.parentElementId) &#123; this.targetParent = document.getElementById(config.parentElementId) this.maxLeft = parseInt(this.targetParent.clientWidth - this.target.clientWidth) this.maxTop = parseInt(this.targetParent.clientHeight - this.target.clientHeight) &#125; else &#123; this.maxLeft = parseInt(document.documentElement.clientWidth - this.target.clientWidth) this.maxTop = parseInt(document.documentElement.clientHeight - this.target.clientHeight) &#125;&#125;Drag.prototype = &#123; constructor: Drag, start: function() &#123; this.target.onmousedown = function(e) &#123; this.down(e) &#125;.bind(this) //或 // var _this = this // this.target.onmousedown = function(e) &#123; // _this.down(e) // &#125; this.target.onmousemove = function(e) &#123; this.move(e) &#125;.bind(this) this.target.onmouseup = function(e) &#123; this.up(e) &#125;.bind(this) &#125;, getPostion: function(e) &#123; var posX, posY e = e || window.event if (e.pageX) &#123; posX = e.pageX posY = e.pageY &#125; else &#123; posX = e.clientX + document.body.scrollLeft - document.body.clientLeft posY = e.clientY + document.body.scrollTop - document.body.clientTop &#125; return &#123; x: posX, y: posY &#125; &#125;, down: function(e) &#123; this.target.style.cursor = \"move\" this.state = true this.left = this.target.offsetLeft this.top = this.target.offsetTop this.posX = parseInt(this.getPostion(e).x) this.posY = parseInt(this.getPostion(e).y) &#125;, move: function(e) &#123; if (this.state === true) &#123; var x = parseInt(this.getPostion(e).x - this.posX + this.left) var y = parseInt(this.getPostion(e).y - this.posY + this.top) if (x &lt; 0) &#123; x = 0 &#125; else if (x &gt; this.maxLeft) &#123; x = this.maxLeft &#125; if (y &lt; 0) &#123; y = 0 &#125; else if (y &gt; this.maxTop) &#123; y = this.maxTop &#125; this.target.style.left = x + 'px'this.target.style.top = y + 'px' &#125; &#125;, up: function(e) &#123; this.state = false // this.target.onmousedown = null // this.target.onmousemove = null &#125;&#125;","tags":[]},{"title":"javascript中Array中的indexOf方法","date":"2017-05-18T03:17:11.000Z","path":"2017/05/18/js-Array-indexOf方法/","text":"前言想必String的indexOf方法大家都已经很熟悉，用来判断字符串中是否含有某个字符串片段，对于正则不熟悉的人可谓利器，这里不在赘述。但是Array的indexOf方法却很容易被大家忽略。 简述Array.prototype.indexOf()该indexOf()方法返回在数组中可以找到给定元素的第一个索引，如果不存在则返回-1。 句法arr.indexOf（searchElement [，fromIndex]） 参数searchElement要在数组中找到的元素。fromIndex 可选的开始搜索的索引。如果索引大于或等于数组的长度，则返回-1，这意味着数组将不会被搜索。如果提供的索引值是负数，则将其作为数组末尾的偏移量。注意：如果提供的索引是负数，则数组仍然是从前到后搜索。如果计算出的索引小于0，则将搜索整个数组。默认值：0（整个数组被搜索）。 返回值数组中元素的第一个索引; -1如果没有找到。 描述indexOf()与searchElement使用严格等式的数组的元素进行比较（与=== 三等于运算符使用的方法相同）即不会进行隐式类型转换。 栗子在数组中定位值。123456ar array = [2, 9, 9];array.indexOf(2); // 0array.indexOf(7); // -1array.indexOf(9, 2); // 2array.indexOf(2, -1); // -1array.indexOf(2, -3); // 0 查找元素所有位置12345678910var indices = [];var array = ['a', 'b', 'a', 'c', 'a', 'd'];var element = 'a';var idx = array.indexOf(element);while (idx != -1) &#123; indices.push(idx); idx = array.indexOf(element, idx + 1);&#125;console.log(indices);// [0, 2, 4] 查找数组中是否存在元素并更新数组123456789101112131415function updateVegetablesCollection (veggies, veggie) &#123; if (veggies.indexOf(veggie) === -1) &#123; veggies.push(veggie); console.log('New veggies collection is : ' + veggies); &#125; else if (veggies.indexOf(veggie) &gt; -1) &#123; console.log(veggie + ' already exists in the veggies collection.'); &#125;&#125;var veggies = ['potato', 'tomato', 'chillies', 'green-pepper'];updateVegetablesCollection(veggies, 'spinach');// New veggies collection is : potato,tomato,chillies,green-pepper,spinachupdateVegetablesCollection(veggies, 'spinach');// spinach already exists in the veggies collection. 兼容性咱只说IE, 支持IE9以上","tags":[{"name":"indexOf","slug":"indexOf","permalink":"http://www.leqikeji.com/blog/tags/indexOf/"}]}]